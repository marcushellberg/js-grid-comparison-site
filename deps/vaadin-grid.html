<html><head></head><body><div hidden="" by-polymer-bundler=""><link rel="import" href="elements.html"><dom-module id="vaadin-grid-active-item-themability-styles" assetpath="../bower_components/vaadin-grid/"><template><style>table tr[active] .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{@apply (--vaadin-grid-body-row-active-cell);}</style></template></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.ActiveItemBehavior
 */
vaadin.elements.grid.ActiveItemBehavior = {

  properties: {
    /*
     * The item user has last interacted with. Turns to `null` after user deactivates
     * the item by re-interacting with the currently active item.
     */
    activeItem: {
      type: Object,
      notify: true,
      value: null
    }
  },

  listeners: {
    'cell-activate': '_activateItem'
  },

  observers: ['_activeItemChanged(activeItem)'],

  _activateItem: function _activateItem(e) {
    var clickedItem = e.detail.model.item;

    this.activeItem = this.activeItem !== clickedItem ? clickedItem : null;

    e.stopImmediatePropagation();
  },

  _activeItemChanged: function _activeItemChanged() {
    if (this.$.scroller._physicalItems) {
      this.$.scroller._physicalItems.forEach(function (row) {
        this._updateItem(row, row.item);
      }.bind(this));
    }
  }
};</script><dom-module id="vaadin-grid-table-scroll-styles" assetpath="../bower_components/vaadin-grid/"><template><style>:host{transform:translateZ(0);}thead{position:absolute;top:0;width:100%;}tfoot{position:absolute;bottom:0;width:100%;}tbody{z-index:-1;}table{position:relative;overflow:auto;-webkit-overflow-scrolling:touch;z-index:-2;}:host([ios]) table{transform:none;}:host([fixed-sections]){transform:translateZ(0);overflow:hidden;}:host([fixed-sections]) thead,
      :host([fixed-sections]) tfoot{position:fixed;}:host([fixed-sections]) tbody#items{position:fixed;width:100%;will-change:transform;}:host([fixed-sections]) table{transform:none;}</style></template></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.TableScrollBehaviorImpl
 */
vaadin.elements.grid.TableScrollBehaviorImpl = {

  properties: {

    _vidxOffset: {
      type: Number,
      value: 0
    },

    ios: {
      type: Boolean,
      value: navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/),
      reflectToAttribute: true
    },

    fixedSections: {
      type: Boolean,
      reflectToAttribute: true,
      computed: '_hasFixedSections(scrollbarWidth)'
    },

    // Cached array of frozen cells
    _frozenCells: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    scrolling: {
      type: Boolean,
      reflectToAttribute: true
    }
  },

  listeners: {
    'table.wheel': '_onWheel'
  },

  ready: function ready() {
    this.scrollTarget = this.$.table;
  },

  /**
   * Scroll to a specific index (also scaled indexes) in the virtual list.
   */
  scrollToScaledIndex: function scrollToScaledIndex(idx) {
    this._pendingScrollToScaledIndex = null;
    if (!this.$.items.style.borderTopWidth) {
      // Schedule another scroll to be invoked once init is complete
      this._pendingScrollToScaledIndex = idx;
    }

    idx = Math.min(Math.max(idx, 0), this.size - 1);
    this.$.table.scrollTop = idx / this.size * this.$.table.scrollHeight;
    this._scrollHandler();
    this.scrollToIndex(idx - this._vidxOffset);
    // _scrollTop is not up-to-date at this point, update and run scrollhandler
    this._resetScrollPosition(this._scrollPosition);
    this._scrollHandler();

    // TODO: This is a hack to get around offset issues when scrolling to bottom.
    // Revisit iron-list-behavior for cleaner fix.
    if (this._vidxOffset + this.lastVisibleIndex === this.size - 1) {
      this.$.table.scrollTop = this.$.table.scrollHeight - this.$.table.offsetHeight;
      this._scrollHandler();
    }
  },

  _hasFixedSections: function _hasFixedSections(scrollbarWidth) {
    return navigator.userAgent.match(/Edge/) && scrollbarWidth === 0;
  },

  _onWheel: function _onWheel(e) {
    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
      return;
    }

    var table = this.$.table;
    var momentum = Math.abs(e.deltaX) + Math.abs(e.deltaY);

    if (this._canScroll(table, e.deltaX, e.deltaY)) {
      e.preventDefault();
      table.scrollTop += e.deltaY;
      table.scrollLeft += e.deltaX;
      this._scrollHandler();
      this._hasResidualMomentum = true;

      this._ignoreNewWheel = this.debounce('ignore-new-wheel', function () {
        this._ignoreNewWheel = null;
      }, 500);
    } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
      e.preventDefault();
    } else if (momentum > this._previousMomentum) {
      this._hasResidualMomentum = false;
    }
    this._previousMomentum = momentum;
  },

  /**
   * Determines if the element has an ancestor prior to this
   * cell content that handles the scroll delta
   */
  _hasScrolledAncestor: function _hasScrolledAncestor(el, deltaX, deltaY) {
    if (this._canScroll(el, deltaX, deltaY)) {
      return true;
    } else if (el.localName !== 'vaadin-grid-cell-content' && el !== this && el.parentElement) {
      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
    }
  },

  /**
   * Determines if the the given scroll deltas can be applied to the element
   * (fully or partially)
   */
  _canScroll: function _canScroll(el, deltaX, deltaY) {
    return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;
  },

  /**
   * Update the models, the position of the
   * items in the viewport and recycle tiles as needed.
   */
  _scrollHandler: function _scrollHandler(e) {
    // clamp the `scrollTop` value
    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
    var delta = scrollTop - this._scrollPosition;
    var tileHeight, kth, recycledTileSet, scrollBottom, physicalBottom;
    var ratio = this._ratio;
    var recycledTiles = 0;
    var hiddenContentSize = this._hiddenContentSize;
    var currentRatio = ratio;
    var movingUp = [];

    // track the last `scrollTop`
    this._scrollPosition = scrollTop;

    // clear cached visible indexes
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;

    scrollBottom = this._scrollBottom;
    physicalBottom = this._physicalBottom;

    // random access
    if (Math.abs(delta) > this._physicalSize) {
      this._physicalTop += delta;
      recycledTiles = Math.round(delta / this._physicalAverage);
      // scroll up
    } else if (delta < 0) {
      var topSpace = scrollTop - this._physicalTop;
      var virtualStart = this._virtualStart;

      recycledTileSet = [];

      kth = this._physicalEnd;
      currentRatio = topSpace / hiddenContentSize;

      // move tiles from bottom to top
      while (
      // approximate `currentRatio` to `ratio`
      currentRatio < ratio &&
      // recycle less physical items than the total
      recycledTiles < this._physicalCount &&
      // ensure that these recycled tiles are needed
      virtualStart - recycledTiles > 0 &&
      // ensure that the tile is not visible
      physicalBottom - this._getPhysicalSizeIncrement(kth) > scrollBottom) {

        tileHeight = this._getPhysicalSizeIncrement(kth);
        currentRatio += tileHeight / hiddenContentSize;
        physicalBottom -= tileHeight;
        recycledTileSet.push(kth);
        recycledTiles++;
        kth = kth === 0 ? this._physicalCount - 1 : kth - 1;
      }

      movingUp = recycledTileSet;
      recycledTiles = -recycledTiles;
      // scroll down
    } else if (delta > 0) {
      var bottomSpace = physicalBottom - scrollBottom;
      var virtualEnd = this._virtualEnd;
      var lastVirtualItemIndex = this._virtualCount - 1;

      recycledTileSet = [];

      kth = this._physicalStart;
      currentRatio = bottomSpace / hiddenContentSize;

      // move tiles from top to bottom
      while (
      // approximate `currentRatio` to `ratio`
      currentRatio < ratio &&
      // recycle less physical items than the total
      recycledTiles < this._physicalCount &&
      // ensure that these recycled tiles are needed
      virtualEnd + recycledTiles < lastVirtualItemIndex &&
      // ensure that the tile is not visible
      this._physicalTop + this._getPhysicalSizeIncrement(kth) < scrollTop) {

        tileHeight = this._getPhysicalSizeIncrement(kth);
        currentRatio += tileHeight / hiddenContentSize;

        this._physicalTop += tileHeight;
        recycledTileSet.push(kth);
        recycledTiles++;
        kth = (kth + 1) % this._physicalCount;
      }
    }

    if (this._virtualCount < this.size) {
      this._adjustVirtualIndexOffset(delta);
    }

    if (recycledTiles === 0) {
      // Try to increase the pool if the list's client height isn't filled up with physical items
      if (physicalBottom < scrollBottom || this._physicalTop > scrollTop) {
        this._increasePoolIfNeeded();
      }
    } else {
      this._virtualStart = this._virtualStart + recycledTiles;
      this._physicalStart = this._physicalStart + recycledTiles;
      this._update(recycledTileSet, movingUp);
    }

    this._translateStationaryElements();

    if (!this.hasAttribute('reordering')) {
      this.scrolling = true;
    }
    this.debounce('vaadin-grid-scrolling', function () {
      this.scrolling = false;
      this._reorderRows();
    }, 100);
  },

  _adjustVirtualIndexOffset: function _adjustVirtualIndexOffset(delta) {
    if (Math.abs(delta) > 10000) {
      if (this._noScale) {
        this._noScale = false;
        return;
      }

      var scale = Math.round(this._scrollPosition / this._scrollHeight * 1000) / 1000;
      var offset = scale * this.size;

      this._vidxOffset = Math.round(offset - scale * this._virtualCount);

      if (this._scrollTop === 0) {
        // fixes issues when scrolling to start but correct items are not bound. :-()
        this.scrollToIndex(0);
      }
    } else {
      // Make sure user can always swipe/wheel scroll to the start and end
      // TODO: causes a small jump in the scroll handle

      var oldOffset = this._vidxOffset || 0;
      var threshold = 1000;
      var maxShift = 100;

      // At start
      if (this._scrollTop === 0) {
        this._vidxOffset = 0;
        if (oldOffset !== this._vidxOffset) {
          this.scrollToIndex(0);
        }
      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {
        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);
        this.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset) + 1);
        this._noScale = true;
      }

      // At end
      var maxOffset = this.size - this._virtualCount;
      if (this._scrollTop >= this._maxScrollTop) {
        this._vidxOffset = maxOffset;
        if (oldOffset !== this._vidxOffset) {
          this.scrollToIndex(this._virtualCount);
        }
      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {
        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);
        this.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));
        this._noScale = true;
      }
    }
  },

  _reorderRows: function _reorderRows() {
    var tbody = Polymer.dom(this.$.items);
    var items = tbody.querySelectorAll('tr');
    var _adjustedVirtualStart = this._virtualStart + this._vidxOffset;

    // DOM index of the element with the lowest index
    var physicalIndexOfFirst = items.length - (items[0].index - _adjustedVirtualStart);

    // Reorder the DOM elements
    if (physicalIndexOfFirst < items.length / 2) {
      // Append all the preceding elements after the last element
      for (var i = 0; i < physicalIndexOfFirst; i++) {
        tbody.appendChild(items[i]);
      }
    } else {
      // Prepend all the trailing elements before the first element
      for (var j = physicalIndexOfFirst; j < items.length; j++) {
        tbody.insertBefore(items[j], items[0]);
      }
    }
  },

  _frozenCellsChanged: function _frozenCellsChanged() {
    this.debounce('cache-elements', function () {
      Polymer.dom(this.root).querySelectorAll('td, th').forEach(function (cell) {
        cell.style.transform = '';
      });
      this._frozenCells = Polymer.dom(this.root).querySelectorAll('[frozen]');
      this._translateStationaryElements();
    });
    this._updateLastFrozen();
  },

  _updateLastFrozen: function _updateLastFrozen() {
    var columnsRow = this.columnTree[this.columnTree.length - 1].slice(0);
    columnsRow.sort(function (a, b) {
      return a._order - b._order;
    });
    var lastFrozen = columnsRow.reduce(function (prev, col, index) {
      col._lastFrozen = false;
      return col.frozen && !col.hidden ? index : prev;
    }, undefined);
    if (lastFrozen !== undefined) {
      columnsRow[lastFrozen]._lastFrozen = true;
    }
  },

  _translateStationaryElements: function _translateStationaryElements() {
    if (this.fixedSections) {
      this.$.items.style.transform = this._getTranslate(-this._scrollLeft || 0, -this._scrollTop || 0);

      this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(-this._scrollLeft || 0, 0);
    } else {
      this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(0, this._scrollTop);
    }

    var frozenCellTransform = this._getTranslate(this._scrollLeft, 0);
    for (var i = 0; i < this._frozenCells.length; i++) {
      this._frozenCells[i].style.transform = frozenCellTransform;
    }
  },

  _getTranslate: function _getTranslate(x, y) {
    return 'translate(' + x + 'px,' + y + 'px)';
  }

};

/**
 * @polymerBehavior vaadin.elements.grid.TableScrollBehavior
 */
vaadin.elements.grid.TableScrollBehavior = [Polymer.IronScrollTargetBehavior, vaadin.elements.grid.TableScrollBehaviorImpl];</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.CellClickBehavior
 */
vaadin.elements.grid.CellClickBehavior = {

  listeners: {
    'click': '_onClick'
  },

  attached: function attached() {
    this._cellContentFocusHandler = function (e) {
      // IE11 fires `focus` events for the cell content element even when nothing
      // focusable was clicked.
      if (e.target !== this._cellContent) {
        this.fire('cell-content-focus', { cell: this });
      }
    }.bind(this);

    // we need to capture focus events originating from elements inside this cell,
    // capture mode seems to be required in order it to work.
    this.addEventListener('focus', this._cellContentFocusHandler, true);
  },

  detached: function detached() {
    this.removeEventListener('focus', this._cellContentFocusHandler, true);
  },

  // we need to listen to click instead of tap because on mobile safari, the
  // document.activeElement has not been updated (focus has not been shifted)
  // yet at the point when tap event is being executed.
  _onClick: function _onClick(e) {
    // this event is only supposed to be fired from cells.
    if (this.localName !== 'vaadin-grid-sorter') {
      this.fire('cell-focus', { cell: this });
    }

    // Prevent item action if cell itself is not focused.
    if (this._cellClick) {
      var target = Polymer.dom(e).localTarget;
      // Polymer.dom(e).localTarget usually returns <content> element in shady
      // DOM. We'll get and use the cell-content wrapper in that case.
      if (target.getDistributedNodes) {
        target = Polymer.dom(target).getDistributedNodes()[0];
      }

      var path = Polymer.dom(e).path;
      var elementsClicked = Array.prototype.slice.call(path, 0, path.indexOf(target) + 1);
      if (!target.contains(this.target && this.target.root.activeElement || document.activeElement) && !elementsClicked.some(this._isFocusable)) {
        this._cellClick(e);
      }
    }
  },

  _isFocusable: function _isFocusable(target) {
    var parent = Polymer.dom(target).parentNode;
    var isFocusableElement = Polymer.dom(parent).querySelectorAll('[tabindex], button, input, select, textarea, object, iframe, label, a[href], area[href]').indexOf(target) !== -1;
    return !target.disabled && isFocusableElement;
  }
};</script><dom-module id="vaadin-grid-table-cell" assetpath="../bower_components/vaadin-grid/"></dom-module><dom-module id="vaadin-grid-table-header-cell" assetpath="../bower_components/vaadin-grid/"></dom-module><dom-module id="vaadin-grid-table-footer-cell" assetpath="../bower_components/vaadin-grid/"></dom-module><dom-module id="vaadin-grid-sizer-cell" assetpath="../bower_components/vaadin-grid/"></dom-module><script>
(function () {

  /**
   * @polymerBehavior vaadinGridTableCellBehavior
   */
  var vaadinGridTableCellBehavior = {
    properties: {
      column: Object,
      expanded: Boolean,
      flexGrow: Number,
      focused: {
        type: Boolean,
        reflectToAttribute: true
      },
      frozen: {
        type: Boolean,
        reflectToAttribute: true
      },
      lastFrozen: {
        type: Boolean,
        reflectToAttribute: true
      },
      hidden: {
        type: Boolean,
        reflectToAttribute: true
      },
      instance: Object,
      index: Number,
      item: Object,
      selected: Boolean,
      template: Object,
      target: Object,
      width: String,
      order: Number,
      reorderStatus: {
        type: String,
        reflectToAttribute: true
      },

      _childColumns: Array,

      _cellContent: Object,
      _insertionPoint: Object,
      _templatizer: Object
    },

    observers: ['_columnChanged(column)', '_cellAttached(column, isAttached)', '_expandedChanged(expanded, instance)', '_flexGrowChanged(flexGrow)', '_indexChanged(index, instance)', '_itemChanged(item, instance)', '_instanceChanged(instance, target)', '_selectedChanged(selected, instance)', '_toggleContent(isAttached, _cellContent, _insertionPoint)', '_toggleInstance(isAttached, _templatizer, instance)', '_widthChanged(width)', '_orderChanged(order)', '_visibleChildColumnsChanged(_visibleChildColumns)', '_childColumnsChanged(_childColumns)'],

    created: function created() {
      this.classList.add('vaadin-grid-cell');
    },

    _columnChanged: function _columnChanged(column) {
      this.flexGrow = column.flexGrow;
      this.frozen = column.frozen;
      this.lastFrozen = column._lastFrozen;
      this.headerTemplate = column.headerTemplate;
      this.footerTemplate = column.footerTemplate;
      this.template = column.template;
      this.width = column.width;
      this.hidden = column.hidden;
      this.resizable = column.resizable;
      this._childColumns = column._childColumns;
      this.order = column._order;

      // Assigning undefined to element.colSpan will set colSpan attribute to 0
      if (column.colSpan) {
        this.setAttribute('colspan', column.colSpan);
      }

      this.listen(column, 'property-changed', '_columnPropChanged');
    },

    _cellAttached: function _cellAttached(column, isAttached) {
      // Cells get detached when the column tree changes and new cells are created.
      // Also, cells get detached and attached during row reordering after scrolling.
      if (isAttached) {
        this.listen(column, 'property-changed', '_columnPropChanged');
      } else {
        this.unlisten(column, 'property-changed', '_columnPropChanged');
      }
    },

    _columnPropChanged: function _columnPropChanged(e) {
      if (e.target == this.column) {
        if (e.detail.path === 'colSpan') {
          this.setAttribute('colspan', e.detail.value);
        } else {
          this[e.detail.path] = e.detail.value;
        }
      }
    },

    _expandedChanged: function _expandedChanged(expanded, instance) {
      instance.__expanded__ = expanded;
      instance.expanded = expanded;
    },

    _flexGrowChanged: function _flexGrowChanged(flexGrow) {
      this.style.flexGrow = flexGrow;
    },

    _indexChanged: function _indexChanged(index, instance) {
      instance.index = index;
    },

    _itemChanged: function _itemChanged(item, instance) {
      instance.item = item;
    },

    _selectedChanged: function _selectedChanged(selected, instance) {
      instance.__selected__ = selected;
      instance.selected = selected;
    },

    _childColumnsChanged: function _childColumnsChanged(childColumns) {
      this.setAttribute('colspan', childColumns.length);
    },

    _toggleContent: function _toggleContent(isAttached, cellContent, insertionPoint) {
      if (isAttached) {
        if (Polymer.dom(cellContent).parentNode !== this.target) {
          Polymer.dom(this.target).appendChild(cellContent);
        }
        Polymer.dom(this).appendChild(insertionPoint);
      } else {
        this.async(function () {
          if (!this.isAttached && Polymer.dom(cellContent).parentNode === this.target) {
            Polymer.dom(this.target).removeChild(cellContent);
          }
        });
      }
    },

    _toggleInstance: function _toggleInstance(isAttached, templatizer, instance) {
      if (isAttached) {
        templatizer.addInstance(instance);
      } else {
        templatizer.removeInstance(instance);
      }
    },

    _widthChanged: function _widthChanged(width) {
      this.style.width = width;
    },

    _orderChanged: function _orderChanged(order) {
      this.style.order = order;
    },

    _templateChanged: function _templateChanged(template) {
      this.instance = template.templatizer.createInstance();
      this._templatizer = template.templatizer;
    },

    _instanceChanged: function _instanceChanged(instance, target) {
      this.style.height = '';

      this._cellContent = document.createElement('vaadin-grid-cell-content');

      var contentId = vaadin.elements.grid._contentIndex = vaadin.elements.grid._contentIndex + 1 || 0;
      var id = 'vaadin-grid-cell-content-' + contentId;
      this._cellContent.setAttribute('id', id);

      Polymer.dom(this._cellContent).appendChild(this.instance.root);

      this._insertionPoint = document.createElement('content');
      this._insertionPoint.setAttribute('select', '#' + id);
    }
  };

  Polymer({
    is: 'vaadin-grid-table-cell',

    extends: 'td',

    behaviors: [vaadinGridTableCellBehavior, vaadin.elements.grid.CellClickBehavior],

    observers: ['_templateChanged(template)'],

    _cellClick: function _cellClick(e) {
      if (!e.defaultPrevented) {
        this.fire('cell-activate', {
          model: this.instance
        });
      }
    }
  });

  Polymer({
    is: 'vaadin-grid-table-header-cell',

    extends: 'th',

    properties: {
      headerTemplate: Object,

      resizable: Boolean,

      columnResizing: {
        type: Boolean,
        reflectToAttribute: true
      }
    },

    behaviors: [vaadinGridTableCellBehavior, vaadin.elements.grid.CellClickBehavior],

    observers: ['_headerTemplateChanged(headerTemplate, isAttached)', '_resizableChanged(resizable)'],

    listeners: {
      'mousedown': '_cancelMouseDownOnResize',
      'mousemove': '_enableDrag',
      'mouseout': '_disableDrag',
      'touchstart': '_onTouchStart',
      'touchmove': '_onTouchMove',
      'touchend': '_onTouchEnd',
      'contextmenu': '_onContextMenu'
    },

    _onContextMenu: function _onContextMenu(e) {
      if (this._reorderGhost) {
        e.preventDefault();
      }
    },

    _onTouchStart: function _onTouchStart(e) {
      if (e.target !== this._resizeHandle && this.target.columnReorderingAllowed) {
        this._startReorderTimeout = setTimeout(this._startReorder.bind(this, e), 100);
      }
    },

    _startReorder: function _startReorder(e) {
      this._reorderGhost = this._getGhost();
      this._reorderGhost.style.visibility = 'visible';

      var dragStart = new CustomEvent('dragstart', { bubbles: true });
      this._cellContent.dispatchEvent(dragStart);

      this._reorderXY = {
        x: e.touches[0].clientX - this.getBoundingClientRect().left,
        y: e.touches[0].clientY - this.getBoundingClientRect().top
      };

      this._updateGhostPosition(e.touches[0].clientX, e.touches[0].clientY);
    },

    _onTouchMove: function _onTouchMove(e) {
      if (this._reorderGhost) {
        e.preventDefault();
        var dragOver = new CustomEvent('dragover', { bubbles: true });
        dragOver.clientX = e.touches[0].clientX;
        dragOver.clientY = e.touches[0].clientY;

        var target = this._contentFromPoint(dragOver.clientX, dragOver.clientY);
        if (target) {
          target.dispatchEvent(dragOver);
        }
        this._updateGhostPosition(e.touches[0].clientX, e.touches[0].clientY);
      } else {
        clearTimeout(this._startReorderTimeout);
      }
    },

    _updateGhostPosition: function _updateGhostPosition(eventClientX, eventClientY) {
      // This is where we want to position the ghost
      var targetLeft = eventClientX - this._reorderXY.x;
      var targetTop = eventClientY - this._reorderXY.y - 50;

      // Current position
      var _left = parseInt(this._reorderGhost.style.left || 0);
      var _top = parseInt(this._reorderGhost.style.top || 0);

      // Reposition the ghost
      var ghostRect = this._reorderGhost.getBoundingClientRect();
      this._reorderGhost.style.left = _left - (ghostRect.left - targetLeft) + 'px';
      this._reorderGhost.style.top = _top - (ghostRect.top - targetTop) + 'px';
    },

    _onTouchEnd: function _onTouchEnd(e) {
      clearTimeout(this._startReorderTimeout);
      if (this._reorderGhost) {
        e.preventDefault();
        var event = new CustomEvent('dragend', { bubbles: true });
        this.dispatchEvent(event);
        this._reorderGhost.style.visibility = 'hidden';
        this._reorderGhost = null;
      }
    },

    _contentFromPoint: function _contentFromPoint(x, y) {
      if (Polymer.Settings.useShadow) {
        var scroller = this.target.$.scroller;
        scroller.toggleAttribute('no-content-pointer-events', true);
        var cell = scroller.root.elementFromPoint(x, y);
        scroller.toggleAttribute('no-content-pointer-events', false);
        if (cell && cell.getContentChildren) {
          return cell.getContentChildren('content')[0];
        }
      } else {
        return document.elementFromPoint(x, y);
      }
    },

    _getGhost: function _getGhost() {
      var ghost = this.target.$.scroller.$.reorderghost;
      ghost.innerText = this._cellContent.innerText;
      var style = window.getComputedStyle(this._cellContent);
      ['boxSizing', 'display', 'width', 'height', 'background', 'alignItems', 'padding', 'border', 'flex-direction', 'overflow'].forEach(function (propertyName) {
        ghost.style[propertyName] = style[propertyName];
      }, this);
      return ghost;
    },

    _enableDrag: function _enableDrag() {
      // Text inside draggable grid cells can't be selected. Thus we need to
      // check the global selection state here to avoid a cell becoming
      // draggable while text is being selected.
      this._cellContent.draggable = this.target.columnReorderingAllowed && !window.getSelection().toString();
    },

    _disableDrag: function _disableDrag() {
      this._cellContent.draggable = false;
    },

    _cancelMouseDownOnResize: function _cancelMouseDownOnResize(e) {
      if (e.target === this._resizeHandle) {
        e.preventDefault();
      }
    },

    _resizableChanged: function _resizableChanged(resizable) {
      if (resizable) {
        this._resizeHandle = document.createElement('div');
        this._resizeHandle.classList.add('vaadin-grid-column-resize-handle');
        this.listen(this._resizeHandle, 'track', '_onTrack');
        Polymer.dom(this).appendChild(this._resizeHandle);
      } else if (this._resizeHandle) {
        this.unlisten(this._resizeHandle, 'track', '_onTrack');
        Polymer.dom(this).removeChild(this._resizeHandle);
      }
    },

    _onTrack: function _onTrack(e) {
      this.columnResizing = true;

      // Get the target column to resize
      var column = this.column;
      if (column.localName === 'vaadin-grid-column-group') {
        column = column._childColumns.slice(0).sort(function (a, b) {
          return a._order - b._order;
        }).filter(function (column) {
          return !column.hidden;
        }).pop();
      }
      var targetCell = this._getHeaderCellByColumn(column);

      // Resize the target column
      if (targetCell.offsetWidth) {
        var style = window.getComputedStyle(targetCell._cellContent);
        var minWidth = 10 + parseInt(style.paddingLeft) + parseInt(style.paddingRight);
        column.width = Math.max(minWidth, targetCell.offsetWidth + e.detail.x - targetCell.getBoundingClientRect().right) + 'px';
        column.flexGrow = 0;
      }

      // Fix width and flex-grow for all preceding columns
      var thead = this.parentElement.parentElement;
      Polymer.dom(thead).querySelectorAll('tr:last-child th').sort(function (a, b) {
        return a.column._order - b.column._order;
      }).forEach(function (cell, index, array) {
        if (index < array.indexOf(targetCell)) {
          cell.column.width = cell.offsetWidth + 'px';
          cell.column.flexGrow = 0;
        }
      });

      if (this.columnResizing && e.detail.state === 'end') {
        this.columnResizing = false;
      }

      this.fire('column-resizing');
    },

    _getHeaderCellByColumn: function _getHeaderCellByColumn(column) {
      var thead = this.parentElement.parentElement;
      return Polymer.dom(thead).querySelectorAll('tr:last-child th').filter(function (cell) {
        return cell.column === column;
      })[0];
    },

    _headerTemplateChanged: function _headerTemplateChanged(headerTemplate, isAttached) {
      if (headerTemplate !== null && (this._isColumnRow || this.column.localName === 'vaadin-grid-column-group')) {
        this._isEmpty = false;
        this.instance = this.instance || headerTemplate.templatizer.createInstance();
        this._templatizer = headerTemplate.templatizer;
      } else {
        this._isEmpty = true;
        this.instance = this.instance || { root: document.createElement('div') };
      }

      // Safari 9 doesn't bubble events while not attached to the DOM. #552
      if (isAttached) {
        this.fire('cell-empty-changed');
      }
    }
  });

  Polymer({
    is: 'vaadin-grid-table-footer-cell',

    extends: 'td',

    properties: {
      footerTemplate: Object
    },

    behaviors: [vaadinGridTableCellBehavior, vaadin.elements.grid.CellClickBehavior],

    observers: ['_footerTemplateChanged(footerTemplate, isAttached)'],

    _footerTemplateChanged: function _footerTemplateChanged(footerTemplate, isAttached) {
      if (footerTemplate !== null && (this._isColumnRow || this.column.localName === 'vaadin-grid-column-group')) {
        this._isEmpty = false;
        this.instance = this.instance || footerTemplate.templatizer.createInstance();
        this._templatizer = footerTemplate.templatizer;
      } else {
        this._isEmpty = true;
        this.instance = this.instance || { root: document.createElement('div') };
      }

      // Safari 9 doesn't bubble events while not attached to the DOM. #552
      if (isAttached) {
        this.fire('cell-empty-changed');
      }
    }
  });

  Polymer({
    is: 'vaadin-grid-sizer-cell',

    behaviors: [vaadinGridTableCellBehavior]
  });
})();</script><dom-module id="vaadin-grid-sizer" assetpath="../bower_components/vaadin-grid/"><template><style>:host{display:flex;position:relative;width:100%;visibility:hidden;}.cell{display:block;flex-shrink:0;line-height:0;font-size:1px;margin-top:-1em;}.cell[hidden]{display:none;}</style><template is="dom-repeat" items="[[_columns]]" as="column"><vaadin-grid-sizer-cell class="cell" column="[[column]]">&nbsp;</vaadin-grid-sizer-cell></template></template><script>
Polymer({
  is: 'vaadin-grid-sizer',

  extends: 'div',

  properties: {
    columnTree: Array,

    top: Number,

    _columns: Array
  },

  observers: ['_columnTreeChanged(columnTree)', '_topChanged(top)'],

  _columnTreeChanged: function _columnTreeChanged(columnTree) {
    this._columns = columnTree[columnTree.length - 1];
  },

  _topChanged: function _topChanged(top) {
    this.style.top = top + 'px';
  }
});</script></dom-module><dom-module id="vaadin-grid-table-outer-scroller" assetpath="../bower_components/vaadin-grid/"><template><style>:host{display:block;height:100%;width:100%;position:absolute;top:0;box-sizing:border-box;overflow:auto;}:host([passthrough]){pointer-events:none;}:host([ios]){pointer-events:all;z-index:-3;}:host([ios][scrolling]){z-index:0;}</style><content></content></template><script>
Polymer({
  is: 'vaadin-grid-table-outer-scroller',

  properties: {
    scrollTarget: {
      type: Object,
      observer: '_scrollTargetChanged'
    },

    passthrough: {
      type: Boolean,
      reflectToAttribute: true,
      value: true
    }
  },

  listeners: {
    'scroll': '_syncScrollTarget'
  },

  attached: function attached() {
    this.listen(this.domHost, 'mousemove', '_onMouseMove');

    // for some reason scroll bars are hidden in iOS if this style is
    // added in stylesheets or before attaching.
    this.style.webkitOverflowScrolling = 'touch';
  },

  detached: function detached() {
    this.unlisten(this.domHost, 'mousemove', '_onMouseMove');
  },

  _scrollTargetChanged: function _scrollTargetChanged(scrollTarget, oldScrollTarget) {
    if (oldScrollTarget) {
      this.unlisten(oldScrollTarget, 'scroll', '_syncOuterScroller');
    }
    this.listen(scrollTarget, 'scroll', '_syncOuterScroller');
  },

  _onMouseMove: function _onMouseMove(e) {
    this.passthrough = e.offsetY <= this.clientHeight && e.offsetX <= this.clientWidth;
  },

  _syncOuterScroller: function _syncOuterScroller() {
    if (!this._syncingScrollTarget) {
      this._syncingOuterScroller = true;
      this.scrollTop = this.domHost._scrollTop;
      this.scrollLeft = this.domHost._scrollLeft;
    }
    this._syncingScrollTarget = false;
  },

  _syncScrollTarget: function _syncScrollTarget() {
    if (!this._syncingOuterScroller) {
      this._syncingScrollTarget = true;
      this.scrollTarget.scrollTop = this.scrollTop;
      this.scrollTarget.scrollLeft = this.scrollLeft;
      this.domHost._scrollHandler();
    }
    this._syncingOuterScroller = false;
  }

});</script></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.FocusableCellContainerBehavior
 */
vaadin.elements.grid.FocusableCellContainerBehavior = {
  properties: {
    focused: {
      type: Boolean,
      reflectToAttribute: true
    },
    _focusedRow: Object,
    _focusedRowIndex: Number,
    _focusedCell: Object,
    _focusedCellIndex: Number,
    _lastFocusedCell: Object
  },

  observers: ['_announceFocusedCell(_focusedCell, focused)', '_dispatchEvents(_focusedCell, focused)', '_focusedCellChanged(_focusedRowIndex, _focusedCellIndex)'],

  _announceFocusedCell: function _announceFocusedCell(cell, focused) {
    // changing activeTarget steals focus so we don't want to do that while interacting with
    // cell contents.
    // TODO: remember to change activeTarget when navigation mode is activated back.
    if (!this.domHost.navigating || !focused) {
      return;
    }
    // note: VoiceOver doesn't work with dynamic IDs.
    var activeTarget = cell._cellContent.id;
    if (this.is === 'vaadin-grid-table-body' && !cell.hasAttribute('detailscell')) {
      // note: having `cell.column.name` property for announcing would maybe be a good option here?
      var index = Polymer.dom(cell.parentElement).querySelectorAll('td').indexOf(cell);
      var lastHeaderRow = this.domHost.$.header.lastElementChild;
      var headerCell = lastHeaderRow.children[index];
      activeTarget = headerCell._cellContent.id + ' ' + activeTarget;
    }
    this._getFocusTrap().activeTarget = activeTarget;
  },

  _dispatchEvents: function _dispatchEvents(cell, focused) {
    // Dispatches cell-focusin and cell-focusout events on the cell content
    // for the virtual focus. This helps cell contents to detect if the cell
    // has focus, which is useful for the accessibility reasons. Used by
    // <vaadin-grid-sorter>.
    if (this._lastFocusedCell) {
      this._lastFocusedCell._cellContent.dispatchEvent(new CustomEvent('cell-focusout'));
      this._lastFocusedCell = undefined;
    }
    if (focused) {
      cell._cellContent.dispatchEvent(new CustomEvent('cell-focusin'));
      this._lastFocusedCell = cell;
    }
  },

  _focusedCellChanged: function _focusedCellChanged(rowIndex, cellIndex) {
    Polymer.dom(this).children.forEach(function (row, i) {
      row.focused = i === rowIndex;

      if (row.focused) {
        this._focusedRow = row;
        this._focusedCellIndex = Math.min(cellIndex, row.children.length - 1);
        this._focusedCell = row.children[this._focusedCellIndex];
      }

      row.cells.forEach(function (cell, j) {
        cell.focused = j === this._focusedCellIndex;
      }.bind(this));
    }.bind(this));
  },

  _getFocusTrap: function _getFocusTrap() {
    switch (this.is) {
      case 'vaadin-grid-table-header':
        return this.domHost.$.headerFocusTrap;
      case 'vaadin-grid-table-body':
        return this.domHost.$.bodyFocusTrap;
      case 'vaadin-grid-table-footer':
        return this.domHost.$.footerFocusTrap;
    }
  },

  focusLeft: function focusLeft() {
    if (this._focusedCell.hasAttribute('detailscell')) {
      return;
    }

    var visibleCells = this._visibleCellIndexes();
    if (visibleCells.length > 0) {
      var current = visibleCells.indexOf(this._focusedCellIndex);
      this._focusedCellIndex = visibleCells[Math.max(0, current - 1)];
    }
  },

  focusDown: function focusDown() {
    this._focusedRowIndex = Math.min(this._focusedRowIndex + 1, this.children.length - 1);
  },

  _visibleCellIndexes: function _visibleCellIndexes() {
    var indexes = [];
    if (this._focusedRow && this._focusedRow.children) {
      var children = this._focusedRow.children;
      for (var i = 0; i < children.length; i++) {
        if (!children[i].hidden && children[i] !== this._focusedRow._rowDetailsCell) {
          indexes.push(i);
        }
      }

      indexes.sort(function (i1, i2) {
        return children[i1].column._order < children[i2].column._order ? -1 : 1;
      });
    }

    return indexes;
  },

  focusPageDown: function focusPageDown() {
    this._focusedRowIndex = Math.min(this._focusedRowIndex + 10, this.children.length - 1);
  },

  focusPageUp: function focusPageUp() {
    this._focusedRowIndex = Math.max(0, this._focusedRowIndex - 10);
  },

  focusRight: function focusRight() {
    if (this._focusedCell.hasAttribute('detailscell')) {
      return;
    }

    var visibleCells = this._visibleCellIndexes();
    if (visibleCells.length > 0) {
      var current = visibleCells.indexOf(this._focusedCellIndex);
      this._focusedCellIndex = visibleCells[Math.min(current + 1, visibleCells.length - 1)];
    }
  },

  focusUp: function focusUp() {
    this._focusedRowIndex = Math.max(0, this._focusedRowIndex - 1);
  },

  focusHome: function focusHome() {
    if (this._focusedCell.hasAttribute('detailscell')) {
      return;
    }

    var visibleCells = this._visibleCellIndexes();
    if (visibleCells.length > 0) {
      this._focusedCellIndex = visibleCells[0];
    }
  },

  focusEnd: function focusEnd() {
    if (this._focusedCell.hasAttribute('detailscell')) {
      return;
    }

    var visibleCells = this._visibleCellIndexes();
    if (visibleCells.length > 0) {
      this._focusedCellIndex = visibleCells[visibleCells.length - 1];
    }
  },

  focusFirst: function focusFirst(e) {
    this._focusedRowIndex = 0;
    this.focusHome();
  },

  focusLast: function focusLast(e) {
    this._focusedRowIndex = this.children.length - 1;
    this.focusEnd();
  }
};</script><script>
(function () {

  /**
   * @polymerBehavior vaadinGridTableRowContainerBehavior
   */
  var vaadinGridTableRowContainerBehavior = {
    properties: {
      columnTree: Array,
      target: Object,
      _rows: Array
    },

    observers: ['_columnTreeChanged(columnTree, target)', '_rowsChanged(_rows)'],

    _columnTreeChanged: function _columnTreeChanged(columnTree, target) {
      if (this._rows) {
        this._rows.forEach(function (row) {
          Polymer.dom(row).innerHTML = '';
        });
      }

      var rows = [];
      for (var i = 0; i < columnTree.length; i++) {
        var row = this._createRow();
        row.target = target;
        row._isColumnRow = i == columnTree.length - 1;
        row.columns = columnTree[i];
        rows.push(row);
      }

      this._rows = this.localName === 'thead' ? rows : rows.reverse();
    },

    _rowsChanged: function _rowsChanged(rows) {
      Polymer.dom(this).innerHTML = '';

      rows.forEach(function (row) {
        Polymer.dom(this).appendChild(row);
      }.bind(this));
    }
  };

  Polymer({
    is: 'vaadin-grid-table-header',
    extends: 'thead',
    behaviors: [vaadinGridTableRowContainerBehavior, vaadin.elements.grid.FocusableCellContainerBehavior],

    _createRow: function _createRow() {
      return document.createElement('tr', 'vaadin-grid-table-header-row');
    }
  });

  Polymer({
    is: 'vaadin-grid-table-body',
    extends: 'tbody',
    behaviors: [vaadin.elements.grid.FocusableCellContainerBehavior],

    observers: ['_announceFocusedRow(_focusedRow)'],

    _announceFocusedRow: function _announceFocusedRow(row) {
      this.fire('iron-announce', {
        text: 'Row ' + (row.index + 1) + ' of ' + this.domHost.size
      });
    },

    _moveFocusToDetailsCell: function _moveFocusToDetailsCell() {
      this._focusedCell.focused = false;
      this._focusedRow._rowDetailsCell.focused = true;
      this._focusedCell = this._focusedRow._rowDetailsCell;
    },

    _focusedRowHasDetailsCell: function _focusedRowHasDetailsCell() {
      return this._focusedRow && this._focusedRow._rowDetailsCell && this._focusedCell !== this._focusedRow._rowDetailsCell;
    },

    focusDown: function focusDown() {
      if (this._focusedRowHasDetailsCell()) {
        this._moveFocusToDetailsCell();
      } else {
        this._focusedRowIndex = Math.min(this._focusedRowIndex + 1, this.domHost.size - 1);
      }
    },

    focusUp: function focusUp() {
      if (this._focusedRow && this._focusedCell === this._focusedRow._rowDetailsCell) {
        this._focusedCellChanged(this._focusedRowIndex, this._focusedCellIndex);
      } else {
        this._focusedRowIndex = Math.max(0, this._focusedRowIndex - 1);

        if (this._focusedRowHasDetailsCell()) {
          this._moveFocusToDetailsCell();
        }
      }
    },

    focusLast: function focusLast() {
      this._focusedRowIndex = this.domHost.size - 1;
      this.focusEnd();
    },

    _focusedCellChanged: function _focusedCellChanged(rowIndex, cellIndex) {
      Polymer.dom(this).children.forEach(function (row) {
        row.focused = row.index === rowIndex;

        if (row.index === rowIndex) {
          this._focusedRow = row;
          this._focusedCell = row.children[cellIndex];
        }

        row.iterateCells(function (cell, idx) {
          cell.focused = idx === cellIndex;
        });
      }.bind(this));
    }
  });

  Polymer({
    is: 'vaadin-grid-table-footer',
    extends: 'tfoot',
    behaviors: [vaadinGridTableRowContainerBehavior, vaadin.elements.grid.FocusableCellContainerBehavior],

    _createRow: function _createRow() {
      return document.createElement('tr', 'vaadin-grid-table-footer-row');
    }
  });
})();</script><dom-module id="vaadin-grid-table-focus-trap" assetpath="../bower_components/vaadin-grid/"><template><style>:host{position:absolute;z-index:-3;height:0;}:host(:focus),
     .primary:focus,
     ::content .primary:focus,
     .secondary:focus,
     ::content .secondary:focus{outline:none;}</style><div class="primary" tabindex="0" role="gridcell" on-focus="_onBaitFocus" on-blur="_onBaitBlur"><div aria-hidden="true">&nbsp;</div></div><div class="secondary" tabindex="-1" role="gridcell" on-focus="_onBaitFocus" on-blur="_onBaitBlur"><div aria-hidden="true">&nbsp;</div></div><slot></slot></template><script>
Polymer({
  is: 'vaadin-grid-table-focus-trap',

  hostAttributes: {
    'tabindex': -1,
    'role': 'gridcell' // gridcell roles are for VoiceOver to announce "you're in a cell"
  },

  listeners: {
    'focus': '_onFocus',
    'focusin': '_stopPropagationForReannouncing',
    'focusout': '_stopPropagationForReannouncing'
  },

  properties: {
    activeTarget: {
      type: String,
      observer: '_activeTargetChanged'
    }
  },

  ready: function ready() {
    this._primary = Polymer.dom(this.root).querySelector('.primary');
    this._secondary = Polymer.dom(this.root).querySelector('.secondary');

    // In native shadow, focus traps need to be inside the same scope as
    // the "labelled by" elements
    if (Polymer.Settings.useNativeShadow) {
      Polymer.dom(this).appendChild(this._primary);
      Polymer.dom(this).appendChild(this._secondary);
    }
  },

  _onFocus: function _onFocus(e) {
    this._primary.focus();
  },

  _onBaitFocus: function _onBaitFocus(e) {
    // TODO: remove this custom event after FF52 with native focusin support
    // is in use.
    this.fire('focusin');

    this._focused = e.target;
  },

  _onBaitBlur: function _onBaitBlur(e) {
    // TODO: remove this custom event after FF52 with native focusout support
    // is in use.
    this.fire('focusout');
  },

  _activeTargetChanged: function _activeTargetChanged(target) {
    // moving focus seems to be the most reliable way to get different screenreaders
    // to announce the "aria-labelledby" property
    if (this._focused === this._primary) {
      this._secondary.setAttribute('aria-labelledby', target);
      this._secondary.focus();
    } else {
      this._primary.setAttribute('aria-labelledby', target);
      this._primary.focus();
    }
  },

  _reannounce: function _reannounce() {
    this._isReannouncing = true;
    if (this._focused === this._primary) {
      this._secondary.setAttribute('aria-labelledby', this.activeTarget);
      this._secondary.focus();
    } else {
      this._primary.setAttribute('aria-labelledby', this.activeTarget);
      this._primary.focus();
    }
    this._isReannouncing = false;
  },

  _stopPropagationForReannouncing: function _stopPropagationForReannouncing(e) {
    if (this._isReannouncing) {
      // When reannouncing, the event is fake and must not be processed
      e.stopImmediatePropagation();
      e.stopPropagation();
    }
  }

});</script></dom-module><dom-module id="vaadin-grid-table-row" assetpath="../bower_components/vaadin-grid/"></dom-module><dom-module id="vaadin-grid-table-header-row" assetpath="../bower_components/vaadin-grid/"></dom-module><script>
(function () {

  /**
   * @polymerBehavior vaadinGridTableRowBehavior
   */
  var vaadinGridTableRowBehavior = {

    extends: 'tr',

    properties: {
      active: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      columns: Array,
      index: Number,
      cells: {
        value: []
      },
      target: Object,

      expanded: {
        value: false
      },

      focused: {
        type: Boolean,
        reflectToAttribute: true
      },

      item: Object,

      selected: {
        reflectToAttribute: true
      },

      _rowDetailsCell: Object,

      rowDetailsTemplate: Object
    },

    observers: ['_columnsChanged(columns, target)', '_indexChanged(index, cells)', '_itemChanged(item, cells)', '_itemChangedForDetails(item, _rowDetailsCell)', '_rowDetailsChanged(expanded, rowDetailsTemplate, target)', '_rowDetailsCellIndexChanged(_rowDetailsCell, index)', '_rowDetailsCellChanged(_rowDetailsCell, target)', '_selectedChanged(selected, cells)', '_selectedChangedForDetails(selected, _rowDetailsCell)'],

    iterateCells: function iterateCells(callback) {
      this.cells.forEach(callback);
      if (this._rowDetailsCell) {
        callback(this._rowDetailsCell);
      }
    },

    _rowDetailsChanged: function _rowDetailsChanged(expanded, rowDetailsTemplate, target) {
      if (expanded) {
        // TODO: template instance for each detail cell is pushed to the template.instances
        // but never cleaned up. Maybe consider just hiding details instead of removing.
        var rowDetailsCell = document.createElement('td', 'vaadin-grid-table-cell');
        rowDetailsCell.setAttribute('detailscell', true);
        // Using a frozen cell as the details cell works as a handy way of
        // making it float in place
        rowDetailsCell.frozen = true;
        rowDetailsCell.target = target;
        rowDetailsCell.template = rowDetailsTemplate;
        rowDetailsCell.toggleAttribute('lastcolumn', true);
        Polymer.dom(this.root).appendChild(rowDetailsCell);
        Polymer.dom.flush();
        this._rowDetailsCell = rowDetailsCell;
      } else {
        if (this._rowDetailsCell) {
          Polymer.dom(this.root).removeChild(this._rowDetailsCell);
          this._rowDetailsCell = null;
        }
      }

      this.iterateCells(function (cell) {
        cell.expanded = expanded;
      });

      // Row details uses a frozen cell to need to invoke this to update cache
      this.target.$.scroller._frozenCellsChanged();
    },

    _updateRowVisibility: function _updateRowVisibility() {
      this.hidden = this.cells.every(function (cell) {
        return cell._isEmpty;
      });
    },

    _rowDetailsCellChanged: function _rowDetailsCellChanged(_rowDetailsCell, target) {
      // paddingBottom must be set before update() is called!
      // make sure observers are in the correct order!
      target.$.scroller._update();
    },

    _rowDetailsCellIndexChanged: function _rowDetailsCellIndexChanged(_rowDetailsCell, index, target) {
      if (_rowDetailsCell) {
        _rowDetailsCell.index = index;

        Polymer.dom.flush();
        this.updateRowDetailsCellMetrics();
      } else {
        this.style.paddingBottom = '';
      }
    },

    updateRowDetailsCellMetrics: function updateRowDetailsCellMetrics() {
      if (this._rowDetailsCell) {
        this._rowDetailsCell.style.height = ''; // Reset previous height
        this.style.paddingBottom = this._rowDetailsCell.style.height = this._rowDetailsCell.clientHeight + 'px';
      }
    },

    _columnsChanged: function _columnsChanged(columns, target) {
      Polymer.dom(this).innerHTML = '';

      var cells = [];

      columns.forEach(function (column, columnIndex) {
        // Get a cached cell instance if one is available
        var cacheName = '_' + this.is.replace(/-/g, '_') + '_cells';
        var cache = column[cacheName] = column[cacheName] || [];
        var cell = cache.filter(function (cell) {
          return !Polymer.dom(cell).parentNode;
        })[0];
        if (!cell) {
          cell = this._createCell();
          cache.push(cell);
        }

        cell.index = this.index;
        cell.target = this.target;
        cell._isColumnRow = this._isColumnRow;
        cell.column = column;

        Polymer.dom(this).appendChild(cell);
        cells.push(cell);
      }.bind(this));

      this.cells = cells;
    },

    _indexChanged: function _indexChanged(index, cells, _rowDetailsCell) {
      cells.forEach(function (cell) {
        cell.index = index;
      });
    },

    _itemChanged: function _itemChanged(item, cells) {
      cells.forEach(function (cell) {
        // use assignment here instead of notifyPath to avoid triggering
        // forwardInstancePath for path "item" on cells unnecessarily.
        cell.item = item;
      });
    },

    _itemChangedForDetails: function _itemChangedForDetails(item, rowDetails) {
      if (rowDetails) {
        rowDetails.item = item;
      }
    },

    _selectedChanged: function _selectedChanged(selected, cells) {
      cells.forEach(function (cell) {
        cell.selected = selected;
      });
    },

    _selectedChangedForDetails: function _selectedChangedForDetails(selected, rowDetails) {
      if (rowDetails) {
        rowDetails.selected = selected;
      }
    },

    updateLastColumn: function updateLastColumn() {
      this.cells.slice(0).sort(function (a, b) {
        return a.column._order - b.column._order;
      }).forEach(function (cell, cellIndex, children) {
        cell.toggleAttribute('lastcolumn', cellIndex === children.length - 1);
      });
    }

  };

  Polymer({
    is: 'vaadin-grid-table-row',

    behaviors: [vaadinGridTableRowBehavior],

    _createCell: function _createCell() {
      return document.createElement('td', 'vaadin-grid-table-cell');
    }
  });

  Polymer({
    is: 'vaadin-grid-table-header-row',

    behaviors: [vaadinGridTableRowBehavior],

    observers: ['_updateRowVisibility(columns)'],

    listeners: {
      'cell-empty-changed': '_updateRowVisibility'
    },

    _createCell: function _createCell() {
      return document.createElement('th', 'vaadin-grid-table-header-cell');
    }

  });

  Polymer({
    is: 'vaadin-grid-table-footer-row',

    behaviors: [vaadinGridTableRowBehavior],

    observers: ['_updateRowVisibility(columns)'],

    listeners: {
      'cell-empty-changed': '_updateRowVisibility'
    },

    _createCell: function _createCell() {
      return document.createElement('td', 'vaadin-grid-table-footer-cell');
    }

  });
})();</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

vaadin.elements.grid.Templatizer = Polymer({
  is: 'vaadin-grid-templatizer',

  factoryImpl: function factoryImpl(dataHost) {
    this.dataHost = dataHost;
  },

  behaviors: [Polymer.Templatizer],

  properties: {
    template: Object,

    _forwardedParentProps: Object,
    _templateInstances: Array
  },

  observers: ['_templateChanged(template)', '_forwardedParentPropsChanged(_forwardedParentProps.*, _templateInstances)'],

  created: function created() {
    this._instanceProps = {
      expanded: true,
      index: true,
      item: true,
      selected: true
    };
  },

  createInstance: function createInstance() {
    var instance = this.stamp(null);
    this.addInstance(instance);

    return instance;
  },

  addInstance: function addInstance(instance) {
    if (this._templateInstances.indexOf(instance) === -1) {
      this._templateInstances.push(instance);
    }
  },

  removeInstance: function removeInstance(instance) {
    var index = this._templateInstances.indexOf(instance);

    this._templateInstances.splice(index, 1);
  },

  _templateChanged: function _templateChanged(template) {
    this._forwardedParentProps = {};
    this._templateInstances = [];
    template.templatizer = this;
    this.templatize(template);

    // TODO: hack to avoid: https://github.com/Polymer/polymer/issues/3307
    this._parentProps = this._parentProps || {};
  },

  _forwardInstanceProp: function _forwardInstanceProp(inst, prop, value) {
    // fire notification event only when a prop is changed through a user-action.
    // e.g. 'expanded' is different from the originally bound '__expanded__' value.
    if (inst['__' + prop + '__'] !== undefined && inst['__' + prop + '__'] !== value) {
      this.fire('template-instance-changed', {
        prop: prop,
        value: value,
        inst: inst
      });
    }
  },

  _forwardInstancePath: function _forwardInstancePath(inst, path, value) {
    // TODO: assuming we're currently just listening to [[item.xxxx]] properties
    // which affect only cells on the current row.
    if (path.indexOf('item.') === 0 && !this._suppressItemChangeEvent) {
      this.fire('item-changed', {
        item: inst.item,
        // stripping 'item.' from path.
        path: path.substring(5),
        value: value
      });
    }
  },

  _forwardParentProp: function _forwardParentProp(prop, value) {
    // _forwardParentProp might be called during this.stamp() before
    // this.instance is set. We need to delay it until instance is set.
    this.set('_forwardedParentProps.' + prop, value);
  },

  _forwardParentPath: function _forwardParentPath(path, value) {
    this.set('_forwardedParentProps.' + path, value);
  },

  _forwardedParentPropsChanged: function _forwardedParentPropsChanged(e, templateInstances) {
    if (e.path !== '_forwardedParentProps') {
      var prop = e.path.substring(e.path.indexOf('.') + 1);
      var value = e.value;

      templateInstances.forEach(function (inst) {
        inst.notifyPath(prop, value);
      });
    }
  }
});</script><dom-module id="vaadin-grid-row-details-styles" assetpath="../bower_components/vaadin-grid/"><template><style>[detailscell]{position:absolute;bottom:0;left:0;width:100%;}</style></template></dom-module><dom-module id="vaadin-grid-row-details-themability-styles" assetpath="../bower_components/vaadin-grid/"><template><style>td[detailscell] ::content > vaadin-grid-cell-content{background:#fff;@apply (--vaadin-grid-body-row-details-cell);}</style></template></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.RowDetailsBehavior
 */
vaadin.elements.grid.RowDetailsBehavior = {

  properties: {

    /**
     * An array containing references to expanded items.
     */
    expandedItems: {
      type: Array,
      value: function value() {
        return [];
      }
    }
  },

  listeners: {
    'template-instance-changed': '_templateInstanceChangedExpanded'
  },

  observers: ['_expandedItemsChanged(expandedItems.*, dataProvider)', '_rowDetailsTemplateChanged(_rowDetailsTemplate)'],

  _expandedItemsChanged: function _expandedItemsChanged(expandedItems, dataProvider) {
    this._flushItemsDebouncer();
    if (this.$.scroller._physicalItems) {
      this.$.scroller._physicalItems.forEach(function (row) {
        row.expanded = this._isExpanded(row.item);
      }.bind(this));
    }
  },

  _rowDetailsTemplateChanged: function _rowDetailsTemplateChanged(rowDetailsTemplate) {
    var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
    templatizer._instanceProps = {
      expanded: true,
      index: true,
      item: true,
      selected: true
    };

    // row details templatizer needs to be attached so that `item-changed` and
    // `template-instance-changed` events propagate to grid.
    Polymer.dom(this.root).appendChild(templatizer);

    templatizer.template = rowDetailsTemplate;
  },

  _isExpanded: function _isExpanded(item) {
    return this.expandedItems && this.expandedItems.indexOf(item) !== -1;
  },

  /**
   * Expand the details row of a given item.
   */
  expandItem: function expandItem(item) {
    if (!this._isExpanded(item)) {
      this.push('expandedItems', item);
    }
  },

  /**
   * Collapse the details row of a given item.
   */
  collapseItem: function collapseItem(item) {
    if (this._isExpanded(item)) {
      this.splice('expandedItems', this.expandedItems.indexOf(item), 1);
    }
  },

  _templateInstanceChangedExpanded: function _templateInstanceChangedExpanded(e) {
    if (e.detail.prop === 'expanded') {
      if (e.detail.value) {
        this.expandItem(e.detail.inst.item);
      } else {
        this.collapseItem(e.detail.inst.item);
      }

      // stop this internal event from propagating outside.
      e.stopPropagation();
    }
  }
};</script><dom-module id="vaadin-grid-data-provider-themability-styles" assetpath="../bower_components/vaadin-grid/"><template><style>@keyframes vaadin-grid-spin-360{100%{transform:rotate(360deg);}}@-webkit-keyframes vaadin-grid-spin-360{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg);}}#spinner{border:2px solid var(--primary-color, #03A9F4);border-radius:50%;border-right-color:transparent;border-top-color:transparent;content:"";height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px;pointer-events:none;opacity:0;@apply (--vaadin-grid-loading-spinner);}:host([loading]) #spinner{opacity:1;-webkit-animation:vaadin-grid-spin-360 400ms linear infinite;animation:vaadin-grid-spin-360 400ms linear infinite;}:host([loading]) #items{opacity:0.5;}</style></template></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.DataProviderBehavior
 */
vaadin.elements.grid.DataProviderBehavior = {

  listeners: {
    'item-changed': '_templateItemChanged'
  },

  properties: {

    /**
     * Number of items fetched at a time from the dataprovider.
     */
    pageSize: {
      type: Number,
      value: 50,
      observer: '_pageSizeChanged'
    },

    /**
     * Function that provides items lazily. Receives arguments `params`, `callback`
     *
     * `params.page` Requested page index
     *
     * `params.pageSize` Current page size
     *
     * `params.filters` Currently applied filters
     *
     * `params.sortOrders` Currently applied sorting orders
     *
     */
    dataProvider: {
      type: Object,
      notify: true,
      observer: '_dataProviderChanged'
    },

    /**
     * `true` while data is being requested from the data provider.
     */
    _loading: Boolean,

    _cache: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    _pendingRequests: {
      type: Object,
      value: function value() {
        return {};
      }
    }
  },

  _templateItemChanged: function _templateItemChanged(e) {
    var item = e.detail.item;

    // TODO: We could avoid iterating rows by fixing _physicalIndexForKey mapping
    // in iron-list-behavior so that vidx could be used to fetch the correct row element.
    Polymer.dom(this.$.scroller.$.items).children.forEach(function (row) {
      if (row.item === item) {
        row.iterateCells(function (cell) {
          // prevent _forwardInstancePath from firing duplicate `item-changed`
          // events on all the sibling cells.
          cell._templatizer._suppressItemChangeEvent = true;
          cell.instance.notifyPath('item.' + e.detail.path, e.detail.value);
          cell._templatizer._suppressItemChangeEvent = false;
        });
      }
    });
  },

  _getCachedItem: function _getCachedItem(index) {
    var page = this._getPageForIndex(index);

    var p = this._cache && this._cache[page];

    if (p) {
      return p[index - page * this.pageSize];
    } else {
      return null;
    }
  },

  _getItem: function _getItem(index, el) {
    this._updateItem(el, this._getCachedItem(index));
    this._eagerlyLoadPages();
    //
    var uncachedPages = this._uncachedPagesForPhysicalItems();
    if (uncachedPages.length > 0) {
      this._loading = true;
      // avoid debounce during scroll to mitigate scrollbar flickering on iOS.
      // debouncing only when data is needed to be fetched. eager loading
      // should somewhat prevent from getting here when scrolling slowly.
      this.debounce('load', function () {
        uncachedPages.forEach(function (i) {
          this._loadPage(i);
        }.bind(this));
      }, 100);
    }
  },

  _cachedPagesForPhysicalItems: function _cachedPagesForPhysicalItems() {
    return this._pagesForPhysicalItems().filter(function (page) {
      return this._cache !== undefined && this._cache[page] !== undefined;
    }.bind(this));
  },

  _uncachedPagesForPhysicalItems: function _uncachedPagesForPhysicalItems() {
    return this._pagesForPhysicalItems().filter(function (page) {
      return this._cache !== undefined && this._cache[page] === undefined;
    }.bind(this));
  },

  _eagerlyLoadPages: function _eagerlyLoadPages() {
    var pages = this._cachedPagesForPhysicalItems().slice(0);

    if (pages.length > 0) {
      pages.sort(function (a, b) {
        return a > b;
      });

      var prev = Math.max(0, pages[0] - 1);
      var next = Math.min(pages[pages.length - 1] + 1, Math.max(0, Math.floor(this.size / this.pageSize) - 1));

      this._loadPage(prev);
      this._loadPage(next);
    }
  },

  _pagesForPhysicalItems: function _pagesForPhysicalItems() {
    // TODO: potentially heavy operation to run first visible index,
    // reconsider if performance issues occur on data binding / scrolling.
    var firstVisiblePage = this._getPageForIndex(this.$.scroller.firstVisibleIndex + this.$.scroller._vidxOffset);

    return [firstVisiblePage].concat(this.$.scroller._physicalItems.filter(function (row) {
      return row.index;
    }).map(function (row) {
      return this._getPageForIndex(row.index);
    }.bind(this))).reduce(function (prev, curr) {
      if (prev.indexOf(curr) === -1) {
        prev.push(curr);
      }

      return prev;
    }, []);
  },

  _updateItems: function _updateItems(page, items) {
    for (var i = 0; i < this.pageSize; i++) {
      var index = page * this.pageSize + i;
      var row = this.$.scroller._virtualIndexToItem[index];
      if (row) {
        this._updateItem(row, items[i]);

        this.debounce('update-heights', function () {
          this.$.scroller._updateMetrics();
          this.$.scroller._positionItems();
          this.$.scroller._updateScrollerSize();
        }, 1);
      }
    }
  },

  _loadPage: function _loadPage(page, cb) {
    cb = cb || this._updateItems.bind(this);
    if (!this._cache[page]) {
      // make sure same page isn't requested multiple times.
      if (!this._pendingRequests[page] && this.dataProvider) {
        this._pendingRequests[page] = true;
        var params = {
          page: page,
          pageSize: this.pageSize,
          sortOrders: this._mapSorters(),
          filters: this._mapFilters()
        };
        this.dataProvider(params, function (items) {
          this._cache[page] = items;
          delete this._pendingRequests[page];
          cb(page, items);

          this._loading = this._pendingRequests.length > 0;

          this.debounce('check-size', this._checkSize, 2000);
        }.bind(this));
      }
    }
  },

  _getPageForIndex: function _getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  },

  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache: function clearCache() {
    this._cache = {};
    this._pendingRequests = {};
    if (this.$.scroller.hasData) {
      this.$.scroller._update();
    }
    this._flushItemsDebouncer();
  },

  _flushItemsDebouncer: function _flushItemsDebouncer() {
    this.flushDebouncer('load');
  },

  _pageSizeChanged: function _pageSizeChanged(pageSize, oldPageSize) {
    if (oldPageSize !== undefined && pageSize !== oldPageSize) {
      this.clearCache();
    }
  },

  _checkSize: function _checkSize() {
    if (this.size === undefined) {
      console.warn('The <vaadin-grid> needs a value for "size" property in order to display rows.');
    }
  },

  _dataProviderChanged: function _dataProviderChanged(dataProvider, oldDataProvider) {
    if (oldDataProvider !== undefined) {
      this.clearCache();
    }

    if (!this.$.scroller.hasData) {
      // load data before adding rows to make sure they have content when
      // rendered for the first time.
      this._loading = true;
      this._loadPage(0, function () {
        this.$.scroller.hasData = true;
      }.bind(this));
    }
  }

};</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.SelectionBehavior
 */
vaadin.elements.grid.SelectionBehavior = {

  properties: {

    /**
     * An array that contains the selected items.
     */
    selectedItems: {
      type: Object,
      notify: true,
      value: function value() {
        return [];
      }
    }
  },

  observers: ['_selectedItemsChanged(selectedItems.*)'],

  listeners: {
    'template-instance-changed': '_templateInstanceChangedSelection'
  },

  _templateInstanceChangedSelection: function _templateInstanceChangedSelection(e) {
    if (e.detail.prop === 'selected') {
      var item = e.detail.inst.item;
      (this._isSelected(item) ? this.deselectItem : this.selectItem).bind(this)(item);

      this.fire('iron-announce', {
        text: (this._isSelected(item) ? 'Selected' : 'Deselected') + ' Row ' + (e.detail.inst.index + 1) + ' of ' + this.size
      });

      // stop this internal event from propagating outside.
      e.stopPropagation();
    }
  },

  _isSelected: function _isSelected(item) {
    return this.selectedItems && this.selectedItems.indexOf(item) > -1;
  },

  /**
   * Selects the given item.
   *
   * @method selectItem
   * @param {number|Object} item The item index or the item object
   */
  selectItem: function selectItem(item) {
    item = this._takeItem(item);
    if (!this._isSelected(item)) {
      this.push('selectedItems', item);
    }
  },

  /**
   * Deselects the given item if it is already selected.
   *
   * @method deselect
   * @param {number|Object} item The item index or the item object
   */
  deselectItem: function deselectItem(item) {
    item = this._takeItem(item);
    var index = this.selectedItems.indexOf(item);
    if (index > -1) {
      this.splice('selectedItems', index, 1);
    }
  },

  /**
   * Toggles the selected state of the given item.
   *
   * @method toggle
   * @param {number|Object} item The item index or the item object
   */
  _toggleItem: function _toggleItem(item) {
    item = this._takeItem(item);
    var index = this.selectedItems.indexOf(item);
    if (index === -1) {
      this.selectItem(item);
    } else {
      this.deselectItem(item);
    }
  },

  /**
   * Returns item object itself or by the item index.
   *
   * @param {number|Object} item The item index or the item object
   */
  _takeItem: function _takeItem(item) {
    if (typeof item === 'number' && item >= 0 && this.items && this.items.length > item) {
      return this.items[item];
    }
    return item;
  },

  _selectedItemsChanged: function _selectedItemsChanged(e) {
    if (this.$.scroller._physicalItems && (e.path === 'selectedItems' || e.path === 'selectedItems.splices')) {
      this.$.scroller._physicalItems.forEach(function (row) {
        row.selected = this._isSelected(row.item);
      }.bind(this));
    }
  }
};</script><dom-module id="vaadin-grid-selection-themability-styles" assetpath="../bower_components/vaadin-grid/"><template><style>table tr[selected] .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{background-color:var(--paper-grey-100, rgb(243, 243, 243));@apply (--vaadin-grid-body-row-selected-cell);}</style></template></dom-module><dom-module id="iron-a11y-announcer" assetpath="../bower_components/iron-a11y-announcer/"><template><style>:host{display:inline-block;position:fixed;clip:rect(0px,0px,0px,0px);}</style><div aria-live$="[[mode]]">[[_text]]</div></template><script>

(function () {
  'use strict';

  Polymer.IronA11yAnnouncer = Polymer({
    is: 'iron-a11y-announcer',

    properties: {

      /**
       * The value of mode is used to set the `aria-live` attribute
       * for the element that will be announced. Valid values are: `off`,
       * `polite` and `assertive`.
       */
      mode: {
        type: String,
        value: 'polite'
      },

      _text: {
        type: String,
        value: ''
      }
    },

    created: function created() {
      if (!Polymer.IronA11yAnnouncer.instance) {
        Polymer.IronA11yAnnouncer.instance = this;
      }

      document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
    },

    /**
     * Cause a text string to be announced by screen readers.
     *
     * @param {string} text The text that should be announced.
     */
    announce: function announce(text) {
      this._text = '';
      this.async(function () {
        this._text = text;
      }, 100);
    },

    _onIronAnnounce: function _onIronAnnounce(event) {
      if (event.detail && event.detail.text) {
        this.announce(event.detail.text);
      }
    }
  });

  Polymer.IronA11yAnnouncer.instance = null;

  Polymer.IronA11yAnnouncer.requestAvailability = function () {
    if (!Polymer.IronA11yAnnouncer.instance) {
      Polymer.IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
    }

    document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
  };
})();</script></dom-module><dom-module id="vaadin-grid-navigation-themability-styles" assetpath="../bower_components/vaadin-grid/"><template><style>:host(:focus){outline:none;}:host([navigating]:not([interacting])) [focused] > tr[focused] > [focused] ::content > vaadin-grid-cell-content{box-shadow:inset 0 0 0 3px rgba(0, 0, 0, 0.3);@apply (--vaadin-grid-focused-cell);}</style></template></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.KeyboardNavigationBehaviorImpl
 */
vaadin.elements.grid.KeyboardNavigationBehaviorImpl = {
  hostAttributes: {
    // keys can be listened only when vaadin-grid is focusable
    'tabindex': -1,
    'role': 'application'
  },

  keyBindings: {
    'ctrl+home': '_onCtrlHome',
    'ctrl+end': '_onCtrlEnd',
    'down': '_onArrowDown',
    'end': '_onEnd',
    'enter': '_onEnter',
    'esc': '_onEscape',
    'f2': '_onF2',
    'home': '_onHome',
    'left': '_onArrowLeft',
    'pagedown': '_onPageDown',
    'pageup': '_onPageUp',
    'right': '_onArrowRight',
    'shift+tab': '_onShiftTab',
    'space': '_onSpace',
    'tab': '_onTab',
    'up': '_onArrowUp'
  },

  attached: function attached() {
    Polymer.IronA11yAnnouncer.requestAvailability();
  },

  _onEnd: function _onEnd(e) {
    this.$.scroller._onEnd(e);
  },

  _onEnter: function _onEnter(e) {
    this.$.scroller._onEnter(e);
  },

  _onEscape: function _onEscape(e) {
    this.$.scroller._onEscape(e);
  },

  _onF2: function _onF2(e) {
    this.$.scroller._onF2(e);
  },

  _onTab: function _onTab(e) {
    this.$.scroller._onTab(e);
  },

  _onShiftTab: function _onShiftTab(e) {
    this.$.scroller._onShiftTab(e);
  },

  _onArrowDown: function _onArrowDown(e) {
    this.$.scroller._onArrowDown(e);
  },

  _onArrowUp: function _onArrowUp(e) {
    this.$.scroller._onArrowUp(e);
  },

  _onArrowRight: function _onArrowRight(e) {
    this.$.scroller._onArrowRight(e);
  },

  _onArrowLeft: function _onArrowLeft(e) {
    this.$.scroller._onArrowLeft(e);
  },

  _onHome: function _onHome(e) {
    this.$.scroller._onHome(e);
  },

  _onCtrlHome: function _onCtrlHome(e) {
    this.$.scroller._onCtrlHome(e);
  },

  _onCtrlEnd: function _onCtrlEnd(e) {
    this.$.scroller._onCtrlEnd(e);
  },

  _onPageDown: function _onPageDown(e) {
    this.$.scroller._onPageDown(e);
  },

  _onPageUp: function _onPageUp(e) {
    this.$.scroller._onPageUp(e);
  },

  _onSpace: function _onSpace(e) {
    this.$.scroller._onSpace(e);
  }
};

/**
 * @polymerBehavior vaadin.elements.grid.KeyboardNavigationBehavior
 */
vaadin.elements.grid.KeyboardNavigationBehavior = [vaadin.elements.grid.KeyboardNavigationBehaviorImpl, Polymer.IronA11yKeysBehavior];

/**
 * @polymerBehavior vaadin.elements.grid.TableKeyboardBehavior
 */
vaadin.elements.grid.TableKeyboardBehavior = {

  properties: {
    _virtualFocus: {
      type: Object,
      observer: '_virtualFocusChanged'
    },

    interacting: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    },

    navigating: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    }
  },

  listeners: {
    'cell-focus': '_onCellFocus',
    'cell-content-focus': '_onCellContentFocus'
  },

  _isFooterVisible: function _isFooterVisible() {
    return this.$.footer._rows.filter(function (row) {
      return !row.hidden;
    }).length > 0;
  },

  _onFocusout: function _onFocusout(e) {
    this.navigating = false;
    this.interacting = false;
  },

  _onHeaderFocus: function _onHeaderFocus(e) {
    this.navigating = true;
    this.interacting = false;
    this.$.header._focusedCellIndex = this.$.header._focusedCellIndex || 0;
    this.$.header._focusedRowIndex = this.$.header._focusedRowIndex || 0;
    this._virtualFocus = this.$.header;
  },

  _onBodyFocus: function _onBodyFocus(e) {
    this.navigating = true;
    this.interacting = false;
    this.$.items._focusedCellIndex = this.$.items._focusedCellIndex || 0;
    this.$.items._focusedRowIndex = this.$.items._focusedRowIndex || 0;
    this._virtualFocus = this.$.items;
  },

  _onFooterFocus: function _onFooterFocus(e) {
    if (this._isFooterVisible()) {
      this.navigating = true;
      this.interacting = false;

      this.$.footer._focusedCellIndex = this.$.footer._focusedCellIndex || 0;
      this.$.footer._focusedRowIndex = this.$.footer._focusedRowIndex || 0;
      this._virtualFocus = this.$.footer;
    } else if (!this._virtualFocus) {
      this.$.bodyFocusTrap.focus();
    }
  },

  _virtualFocusChanged: function _virtualFocusChanged(virtualFocus, oldVirtualFocus) {
    if (oldVirtualFocus) {
      oldVirtualFocus.focused = false;
    }
    if (virtualFocus) {
      virtualFocus.focused = true;

      if (virtualFocus === this.$.items) {
        this._ensureVirtualFocusInViewport();
      }
    }
  },

  _onTab: function _onTab(e) {
    if (this.interacting || !this._virtualFocus) {
      return;
    }

    if (this.navigating) {
      switch (this._virtualFocus) {
        case this.$.header:
          this.$.bodyFocusTrap.focus();
          e.preventDefault();
          break;

        case this.$.items:
          this.$.footerFocusTrap.focus();
          if (this._isFooterVisible()) {
            this._virtualFocus = this.$.footer;
            e.preventDefault();
          } else {
            // IE11 doesn't handle the footer trap `focus` event above syncronously
            // which means that virtualFocus gets set to null before the handler is run
            // causing focus being transferred back to body focus trap.
            this.async(function () {
              this._virtualFocus = null;
            }, 1);
          }
          break;

        case this.$.footer:
          this._virtualFocus = null;
          break;
      }
    } else {
      switch (this._virtualFocus) {
        case this.$.header:
          this.$.headerFocusTrap.focus();
          break;

        case this.$.items:
          this.$.bodyFocusTrap.focus();
          break;

        case this.$.footer:
          this.$.footerFocusTrap.focus();
          break;
      }
      e.preventDefault();
    }
  },

  _onShiftTab: function _onShiftTab(e) {
    if (this.interacting) {
      return;
    }

    if (this.navigating) {
      switch (this._virtualFocus) {
        case this.$.footer:
          this.$.bodyFocusTrap.focus();
          e.preventDefault();
          break;
        case this.$.items:
          this.$.headerFocusTrap.focus();
          e.preventDefault();
          break;
        case this.$.header:
          this._virtualFocus = null;
          break;
      }
    } else {
      switch (this._virtualFocus) {
        case this.$.footer:
          this.$.footerFocusTrap.focus();
          break;
        case this.$.items:
          this.$.bodyFocusTrap.focus();
          break;
        case this.$.header:
          this.$.headerFocusTrap.focus();
          break;
      }
      e.preventDefault();
    }
  },

  _isAboveViewport: function _isAboveViewport(index) {
    return this.firstVisibleIndex > index;
  },

  _onArrowDown: function _onArrowDown(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusDown();

    this._ensureVirtualFocusInViewport();
  },

  _scrollPageDown: function _scrollPageDown() {
    var headerRect = this.$.header.getBoundingClientRect();
    var footerRect = this.$.footer.getBoundingClientRect();

    this.$.table.scrollTop += footerRect.top - headerRect.bottom;
    this._scrollHandler();
  },

  _onPageDown: function _onPageDown(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    if (this._virtualFocus === this.$.items) {
      var prevLastVisible = this.lastVisibleIndex;
      this._scrollPageDown();
      this._virtualFocus._focusedRowIndex += this.lastVisibleIndex - prevLastVisible || this.lastVisibleIndex - this._virtualFocus._focusedRowIndex;
      this._ensureVirtualFocusInViewport();
    } else {
      this._virtualFocus.focusPageDown();
    }
  },

  _scrollPageUp: function _scrollPageUp() {
    var headerRect = this.$.header.getBoundingClientRect();
    var footerRect = this.$.footer.getBoundingClientRect();

    this.$.table.scrollTop -= footerRect.top - headerRect.bottom;
    this._scrollHandler();
  },

  _onPageUp: function _onPageUp(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    if (this._virtualFocus === this.$.items) {
      var prevLastVisibleIndex = this.lastVisibleIndex;
      this._scrollPageUp();
      this._virtualFocus._focusedRowIndex -= prevLastVisibleIndex - this.lastVisibleIndex || this._virtualFocus._focusedRowIndex;
      this._ensureVirtualFocusInViewport();
    } else {
      this._virtualFocus.focusPageUp();
    }
  },

  _onArrowUp: function _onArrowUp(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusUp();

    this._ensureVirtualFocusInViewport();
  },

  _onArrowRight: function _onArrowRight(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusRight();

    this._ensureVirtualFocusInViewport();
  },

  _onArrowLeft: function _onArrowLeft(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusLeft();

    this._ensureVirtualFocusInViewport();
  },

  _onHome: function _onHome(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusHome();

    this._ensureVirtualFocusInViewport();
  },

  _onEnd: function _onEnd(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusEnd();

    this._ensureVirtualFocusInViewport();
  },

  _moveFocusToFocusTarget: function _moveFocusToFocusTarget() {
    var content = this._virtualFocus._focusedCell._cellContent;

    var focusTarget = content.querySelector('[focus-target]') || content.firstElementChild;
    if (focusTarget) {
      focusTarget.focus();
    }
  },

  _onEnter: function _onEnter(e) {
    if (!this.interacting) {
      e.preventDefault();
      this._moveFocusToFocusTarget();
    } else if (e.detail.keyboardEvent.target.localName === 'input' && e.detail.keyboardEvent.target.type === 'text') {
      this.interacting = false;
      this._onTab(e); // revert to navigation
    }
  },

  _onEscape: function _onEscape(e) {
    if (this.interacting) {
      this.interacting = false;
      this._onTab(e); // revert to navigation
    } else if (this.navigating) {
      this.domHost.focus();
    }
  },

  _onF2: function _onF2(e) {
    e.preventDefault();
    if (!this.interacting) {
      this._moveFocusToFocusTarget();
    } else {
      this.interacting = false;
      this._onTab(e); // revert to navigation
    }
  },

  _onCtrlHome: function _onCtrlHome(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusFirst();

    this._ensureVirtualFocusInViewport();
  },

  _onCtrlEnd: function _onCtrlEnd(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    this.navigating = true;
    this._virtualFocus.focusLast();

    this._ensureVirtualFocusInViewport();
  },

  _onSpace: function _onSpace(e) {
    if (this.interacting) {
      return;
    }

    e.preventDefault();

    var focusedCell = this._virtualFocus._focusedCell;
    var firstElementChild = focusedCell.getContentChildren('content')[0].firstElementChild;
    if (firstElementChild) {
      firstElementChild.click();
    } else if (this.navigating) {
      this.fire('cell-activate', {
        model: focusedCell.instance
      });
    }
  },

  _onCellContentFocus: function _onCellContentFocus(e) {
    this.interacting = true;
    this._onCellFocus(e);
  },

  _onCellFocus: function _onCellFocus(e) {
    var cell = e.detail.cell;
    var row = cell.parentElement;
    var container = row.parentElement;

    var rowIndex = Polymer.dom(container).children.indexOf(row);
    if (container === this.$.items) {
      rowIndex = row.index;
    }

    container._focusedRowIndex = rowIndex;
    container._focusedCellIndex = Polymer.dom(row).children.indexOf(cell);
    this._virtualFocus = container;

    if (cell.hasAttribute('detailscell')) {
      container._focusedCellIndex = 0;
      container._moveFocusToDetailsCell();
    }
  },

  _ensureVirtualFocusInViewport: function _ensureVirtualFocusInViewport() {
    var scaledVirtualStart = this._vidxOffset + this._virtualStart;
    var focusedIndex = this._virtualFocus._focusedRowIndex;

    if (this._virtualFocus === this.$.items && (focusedIndex < scaledVirtualStart || focusedIndex > scaledVirtualStart + this._physicalCount)) {
      this.scrollToScaledIndex(focusedIndex);
      // force resetting _focusedCell in case element reordering has happened.
      this._virtualFocus._focusedCellChanged(focusedIndex, this._virtualFocus._focusedCellIndex);
    } else {
      this._ensureElementInViewport(this._virtualFocus._focusedCell);
    }
  },

  _ensureElementInViewport: function _ensureElementInViewport(element) {
    var elementRect = element.getBoundingClientRect();

    // Vertical
    if (this._virtualFocus === this.$.items) {
      var maxBottom = this.$.footer.getBoundingClientRect().top;
      var minTop = this.$.header.getBoundingClientRect().bottom;
      if (elementRect.bottom > maxBottom) {
        this.$.table.scrollTop += elementRect.bottom - maxBottom;
      } else if (elementRect.top < minTop) {
        this.$.table.scrollTop += elementRect.top - minTop;
      }
    }

    // skip horizontal scrolling when focusing on row details cell to avoid
    // unintentional scrolling.
    if (element.hasAttribute('detailscell')) {
      return;
    }

    // Horizontal
    var maxRight = this.$.table.getBoundingClientRect().right;
    var minLeft = this.$.table.getBoundingClientRect().left;
    var lastFrozen = this._virtualFocus._focusedRow.querySelector('[last-frozen]');
    if (lastFrozen) {
      minLeft = lastFrozen.getBoundingClientRect().right;
    }

    if (elementRect.right > maxRight) {
      this.$.table.scrollLeft += elementRect.right - maxRight;
    } else if (elementRect.left < minLeft) {
      this.$.table.scrollLeft += elementRect.left - minLeft;
    }
  }
};</script><dom-module id="vaadin-grid-column-reordering-themability-styles" assetpath="../bower_components/vaadin-grid/"><template><style>:host([reordering]) .vaadin-grid-cell{background:#000;}:host([reordering]) .vaadin-grid-cell[reorder-status="dragging"]{background:var(--primary-color, #000);}:host([reordering]) .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{transition:opacity 300ms;transform:translateZ(0);opacity:0.8;}:host([reordering]) .vaadin-grid-cell[reorder-status="allowed"] ::content > vaadin-grid-cell-content{opacity:1;}:host([reordering]) .vaadin-grid-cell[reorder-status="dragging"] ::content > vaadin-grid-cell-content{opacity:0.95;}</style></template></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.ColumnReorderingBehavior
 */
vaadin.elements.grid.ColumnReorderingBehavior = {

  properties: {

    /**
     * Set to true to allow column reordering.
     */
    columnReorderingAllowed: {
      type: Boolean,
      value: false
    }

  }

};

/**
 * @polymerBehavior vaadin.elements.grid.TableColumnReorderingBehavior
 */
vaadin.elements.grid.TableColumnReorderingBehavior = {

  properties: {

    _orderBaseScope: {
      type: Number,
      value: 10000000
    }

  },

  listeners: {
    'dragstart': '_onDragStart',
    'dragover': '_onDragOver',
    'dragend': '_onDragEnd'
  },

  observers: ['_updateOrders(columnTree, columnTree.*)'],

  _updateOrders: function _updateOrders(columnTree, splices) {
    // Set order numbers to top-level columns
    columnTree[0].forEach(function (column, index) {
      column._order = (index + 1) * this._orderBaseScope;
    }, this);
  },

  _onDragStart: function _onDragStart(e) {
    var cell = this._getCellByCellContent(e.target);
    if (cell) {
      this.toggleAttribute('reordering', true);
      this._draggedColumn = cell.column;
      this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');
      this._draggedColumn._reorderStatus = 'dragging';

      if (e.dataTransfer) {
        // Need to set any data to enable D&D on Firefox
        e.dataTransfer.setData('text', '');
        e.dataTransfer.effectAllowed = 'move';
      }

      this._autoScroller();
    }
  },

  _setSiblingsReorderStatus: function _setSiblingsReorderStatus(column, status) {
    Polymer.dom(Polymer.dom(column).parentNode).children.filter(function (child) {
      return (/column/.test(child.localName) && this._isSwapAllowed(child, column)
      );
    }, this).forEach(function (sibling) {
      sibling._reorderStatus = status;
    });
  },

  _onDragOver: function _onDragOver(e) {
    e.preventDefault();
    var targetCell = this._getCellByCellContent(e.target);
    var targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);

    if (targetColumn && this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e.clientX)) {
      this._swapColumnOrders(this._draggedColumn, targetColumn);
    }

    this._lastDragClientX = e.clientX;
  },

  _autoScroller: function _autoScroller() {
    if (this._lastDragClientX) {
      var rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
      var leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;

      if (rightDiff > 0) {
        this.$.table.scrollLeft += rightDiff / 10;
      } else if (leftDiff > 0) {
        this.$.table.scrollLeft -= leftDiff / 10;
      }
      this._scrollHandler();
    }

    if (this._draggedColumn) {
      this.async(this._autoScroller, 10);
    }
  },

  _onDragEnd: function _onDragEnd(e) {
    this.toggleAttribute('reordering', false);
    this._draggedColumn._reorderStatus = '';
    this._setSiblingsReorderStatus(this._draggedColumn, '');
    this._draggedColumn = null;
    this._lastDragClientX = null;
  },

  _isSwapAllowed: function _isSwapAllowed(column1, column2) {
    if (column1 && column2) {
      var differentColumns = column1 !== column2;
      var sameParent = column1.parentElement === column2.parentElement;
      var sameFrozen = column1.frozen === column2.frozen;
      return differentColumns && sameParent && sameFrozen;
    }
  },

  _isSwappableByPosition: function _isSwappableByPosition(targetColumn, clientX) {
    var targetCell = Polymer.dom(this.$.header).querySelectorAll('th').filter(function (cell) {
      return cell.column === targetColumn;
    })[0];
    var sourceCellRect = this.$.header.querySelector('[reorder-status=dragging]').getBoundingClientRect();

    if (targetCell.getBoundingClientRect().left > sourceCellRect.left) {
      return clientX > targetCell.getBoundingClientRect().right - sourceCellRect.width;
    } else {
      return clientX < targetCell.getBoundingClientRect().left + sourceCellRect.width;
    }
  },

  _getCellByCellContent: function _getCellByCellContent(cellContent) {
    if (cellContent) {
      var contentId = null;
      while (contentId === null && cellContent !== this.target && cellContent) {
        if (cellContent.localName === 'vaadin-grid-cell-content') {
          contentId = cellContent.id;
        }
        cellContent = cellContent.parentElement;
      }

      if (contentId !== null) {
        var injectionPoint = Polymer.dom(this.$.table).querySelector('content[select="#' + contentId + '"]');
        return Polymer.dom(injectionPoint).parentNode;
      }
    }
  },

  _swapColumnOrders: function _swapColumnOrders(column1, column2) {
    var _order = column1._order;
    column1._order = column2._order;
    column2._order = _order;
    this._updateLastFrozen();
    this._updateLastColumn();
  },

  _getTargetColumn: function _getTargetColumn(targetCell, draggedColumn) {
    if (targetCell && draggedColumn) {
      var candidate = targetCell.column;
      while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this.target) {
        candidate = candidate.parentElement;
      }
      if (candidate.parentElement === draggedColumn.parentElement) {
        return candidate;
      } else {
        return targetCell.column;
      }
    }
  }

};</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.IronListBehaviorImpl
 */
vaadin.elements.grid.IronListBehaviorImpl = function () {

  var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
  var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
  var DEFAULT_PHYSICAL_COUNT = 25;

  return {

    is: 'iron-list',

    properties: {
      /**
       * The max count of physical items the pool can extend to.
       */
      maxPhysicalCount: {
        type: Number,
        value: 500
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * for the row.
       */
      indexAs: {
        type: String,
        value: 'index'
      }
    },

    /**
     * The ratio of hidden tiles that should remain in the scroll direction.
     * Recommended value ~0.5, so it will distribute tiles evely in both directions.
     */
    _ratio: 0.5,

    /**
     * The padding-top value for the list.
     */
    _scrollerPaddingTop: 0,

    /**
     * This value is the same as `scrollTop`.
     */
    _scrollPosition: 0,

    /**
     * The sum of the heights of all the tiles in the DOM.
     */
    _physicalSize: 0,

    /**
     * The average `offsetHeight` of the tiles observed till now.
     */
    _physicalAverage: 0,

    /**
     * The number of tiles which `offsetHeight` > 0 observed until now.
     */
    _physicalAverageCount: 0,

    /**
     * The Y position of the item rendered in the `_physicalStart`
     * tile relative to the scrolling list.
     */
    _physicalTop: 0,

    /**
     * The number of items in the list.
     */
    _virtualCount: 0,

    /**
     * A map between an item key and its physical item index
     */
    _physicalIndexForKey: null,

    /**
     * The estimated scroll height based on `_physicalAverage`
     */
    _estScrollHeight: 0,

    /**
     * The scroll height of the dom node
     */
    _scrollHeight: 0,

    /**
     * The height of the list. This is referred as the viewport in the context of list.
     */
    _viewportHeight: 0,

    /**
     * The width of the list. This is referred as the viewport in the context of list.
     */
    _viewportWidth: 0,

    /**
     * An array of DOM nodes that are currently in the tree
     * @type {?Array<!TemplatizerNode>}
     */
    _physicalItems: null,

    /**
     * An array of heights for each item in `_physicalItems`
     * @type {?Array<number>}
     */
    _physicalSizes: null,

    /**
     * A cached value for the first visible index.
     * See `firstVisibleIndex`
     * @type {?number}
     */
    _firstVisibleIndexVal: null,

    /**
     * A cached value for the last visible index.
     * See `lastVisibleIndex`
     * @type {?number}
     */
    _lastVisibleIndexVal: null,

    /**
     * A Polymer collection for the items.
     * @type {?Polymer.Collection}
     */
    _collection: null,

    /**
     * True if the current item list was rendered for the first time
     * after attached.
     */
    _itemsRendered: false,

    /**
     * The page that is currently rendered.
     */
    _lastPage: null,

    /**
     * The max number of pages to render. One page is equivalent to the height of the list.
     */
    _maxPages: 3,

    /**
     * The maximum items per row
     */
    _itemsPerRow: 1,

    /**
     * The width of each grid item
     */
    _itemWidth: 0,

    /**
     * The height of the row in grid layout.
     */
    _rowHeight: 0,

    /**
     * The bottom of the physical content.
     */
    get _physicalBottom() {
      return this._physicalTop + this._physicalSize;
    },

    /**
     * The bottom of the scroll.
     */
    get _scrollBottom() {
      return this._scrollPosition + this._viewportHeight;
    },

    /**
     * The n-th item rendered in the last physical item.
     */
    get _virtualEnd() {
      return this._virtualStart + this._physicalCount - 1;
    },

    /**
     * The height of the physical content that isn't on the screen.
     */
    get _hiddenContentSize() {
      return this._physicalSize - this._viewportHeight;
    },

    /**
     * The maximum scroll top value.
     */
    get _maxScrollTop() {
      return this._estScrollHeight - this._viewportHeight + this._scrollerPaddingTop;
    },

    /**
     * The lowest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    _minVirtualStart: 0,

    /**
     * The largest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    get _maxVirtualStart() {
      return Math.max(0, this._virtualCount - this._physicalCount);
    },

    /**
     * The n-th item rendered in the `_physicalStart` tile.
     */
    _virtualStartVal: 0,

    set _virtualStart(val) {
      this._virtualStartVal = Math.min(this._maxVirtualStart, Math.max(this._minVirtualStart, val));
    },

    get _virtualStart() {
      return this._virtualStartVal || 0;
    },

    /**
     * The k-th tile that is at the top of the scrolling list.
     */
    _physicalStartVal: 0,

    set _physicalStart(val) {
      this._physicalStartVal = val % this._physicalCount;
      if (this._physicalStartVal < 0) {
        this._physicalStartVal = this._physicalCount + this._physicalStartVal;
      }
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalStart() {
      return this._physicalStartVal || 0;
    },

    /**
     * The number of tiles in the DOM.
     */
    _physicalCountVal: 0,

    set _physicalCount(val) {
      this._physicalCountVal = val;
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalCount() {
      return this._physicalCountVal;
    },

    /**
     * The k-th tile that is at the bottom of the scrolling list.
     */
    _physicalEnd: 0,

    /**
     * An optimal physical size such that we will have enough physical items
     * to fill up the viewport and recycle when the user scrolls.
     *
     * This default value assumes that we will at least have the equivalent
     * to a viewport of physical items above and below the user's viewport.
     */
    get _optPhysicalSize() {
      return this._viewportHeight * this._maxPages;
    },

    get _optPhysicalCount() {
      return this._estRowsInView * this._itemsPerRow * this._maxPages;
    },

    /**
     * True if the current list is visible.
     */
    get _isVisible() {
      return this.scrollTarget && Boolean(this.scrollTarget.offsetWidth || this.scrollTarget.offsetHeight);
    },

    /**
     * Gets the index of the first visible item in the viewport.
     *
     * @type {number}
     */
    get firstVisibleIndex() {
      if (this._firstVisibleIndexVal === null) {
        var physicalOffset = Math.floor(this._physicalTop + this._scrollerPaddingTop);

        this._firstVisibleIndexVal = this._iterateItems(function (pidx, vidx) {
          physicalOffset += this._getPhysicalSizeIncrement(pidx);

          if (physicalOffset > this._scrollPosition) {
            return vidx;
          }
        }) || 0;
      }
      return this._firstVisibleIndexVal;
    },

    /**
     * Gets the index of the last visible item in the viewport.
     *
     * @type {number}
     */
    get lastVisibleIndex() {
      if (this._lastVisibleIndexVal === null) {
        var physicalOffset = this._physicalTop;
        this._iterateItems(function (pidx, vidx) {
          if (physicalOffset < this._scrollBottom) {
            this._lastVisibleIndexVal = vidx;
          } else {
            // Break _iterateItems
            return true;
          }
          physicalOffset += this._getPhysicalSizeIncrement(pidx);
        });
      }
      return this._lastVisibleIndexVal;
    },

    get _defaultScrollTarget() {
      return this;
    },
    get _virtualRowCount() {
      return Math.ceil(this._virtualCount / this._itemsPerRow);
    },

    get _estRowsInView() {
      return Math.ceil(this._viewportHeight / this._rowHeight);
    },

    get _physicalRows() {
      return Math.ceil(this._physicalCount / this._itemsPerRow);
    },

    attached: function attached() {
      this.updateViewportBoundaries();
      this._render();
      // `iron-resize` is fired when the list is attached if the event is added
      // before attached causing unnecessary work.
      this.listen(this, 'iron-resize', '_resizeHandler');
    },

    detached: function detached() {
      this._itemsRendered = false;
      this.unlisten(this, 'iron-resize', '_resizeHandler');
    },

    /**
     * Invoke this method if you dynamically update the viewport's
     * size or CSS padding.
     *
     * @method updateViewportBoundaries
     */
    updateViewportBoundaries: function updateViewportBoundaries() {
      this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(window.getComputedStyle(this)['padding-top'], 10);

      this._viewportHeight = this._scrollTargetHeight;
    },

    /**
     * Update the list of items, starting from the `_virtualStart` item.
     * @param {!Array<number>=} itemSet
     * @param {!Array<number>=} movingUp
     */
    _update: function _update(itemSet, movingUp) {
      // update models
      this._assignModels(itemSet);
      // measure heights
      this._updateMetrics(itemSet);
      // adjust offset after measuring
      if (movingUp) {
        while (movingUp.length) {
          var idx = movingUp.pop();
          this._physicalTop -= this._getPhysicalSizeIncrement(idx);
        }
      }
      // update the position of the items
      this._positionItems();
      // set the scroller size
      this._updateScrollerSize();
      // increase the pool of physical items

      // dropping this will reduce spinup time by 50%
      this._increasePoolIfNeeded();
    },

    /**
     * Increases the pool of physical items only if needed.
     *
     * @return {boolean} True if the pool was increased.
     */
    _increasePoolIfNeeded: function _increasePoolIfNeeded() {
      // Base case 1: the list has no height.
      if (this._viewportHeight === 0) {
        return false;
      }
      // Base case 2: If the physical size is optimal and the list's client height is full
      // with physical items, don't increase the pool.
      var isClientHeightFull = this._physicalBottom >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
      if (this._physicalSize >= this._optPhysicalSize && isClientHeightFull) {
        return false;
      }
      // this value should range between [0 <= `currentPage` <= `_maxPages`]
      var currentPage = Math.floor(this._physicalSize / this._viewportHeight);
      if (currentPage === 0) {
        // fill the first page
        this._debounceTemplate(this._increasePool.bind(this, Math.round(this._physicalCount * 0.5)));
      } else if (this._lastPage !== currentPage && isClientHeightFull) {
        // paint the page and defer the next increase
        // wait 16ms which is rough enough to get paint cycle.
        Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', this._increasePool.bind(this, this._itemsPerRow), 16));
      } else {
        // fill the rest of the pages
        this._debounceTemplate(this._increasePool.bind(this, this._itemsPerRow));
      }
      this._lastPage = currentPage;
      return true;
    },

    /**
     * Increases the pool size.
     */
    _increasePool: function _increasePool(missingItems) {
      var nextPhysicalCount = Math.min(this._physicalCount + missingItems, this._virtualCount - this._virtualStart, Math.max(this.maxPhysicalCount, DEFAULT_PHYSICAL_COUNT));
      var prevPhysicalCount = this._physicalCount;
      var delta = nextPhysicalCount - prevPhysicalCount;

      if (delta <= 0) {
        return;
      }

      [].push.apply(this._physicalItems, this._createPool(delta));
      [].push.apply(this._physicalSizes, new Array(delta));

      this._physicalCount = prevPhysicalCount + delta;

      this._update();
    },

    /**
     * Render a new list of items. This method does exactly the same as `update`,
     * but it also ensures that only one `update` cycle is created.
     */
    _render: function _render() {
      var requiresUpdate = this._virtualCount > 0 || this._physicalCount > 0;

      if (this.isAttached && !this._itemsRendered && this._isVisible && requiresUpdate) {
        this._lastPage = 0;
        this._update();
        this._itemsRendered = true;
      }
    },

    /**
     * Executes a provided function per every physical index in `itemSet`
     * `itemSet` default value is equivalent to the entire set of physical indexes.
     *
     * @param {!function(number, number)} fn
     * @param {!Array<number>=} itemSet
     */
    _iterateItems: function _iterateItems(fn, itemSet) {
      var pidx, vidx, rtn, i;

      if (arguments.length === 2 && itemSet) {
        for (i = 0; i < itemSet.length; i++) {
          pidx = itemSet[i];
          vidx = this._computeVidx(pidx);
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      } else {
        pidx = this._physicalStart;
        vidx = this._virtualStart;

        for (; pidx < this._physicalCount; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
        for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      }
    },

    /**
     * Returns the virtual index for a given physical index
     *
     * @param {number} pidx Physical index
     * @return {number}
     */
    _computeVidx: function _computeVidx(pidx) {
      if (pidx >= this._physicalStart) {
        return this._virtualStart + (pidx - this._physicalStart);
      }
      return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
    },

    /**
     * Updates the height for a given set of items.
     *
     * @param {!Array<number>=} itemSet
     */
    _updateMetrics: function _updateMetrics(itemSet) {
      // Make sure we distributed all the physical items
      // so we can measure them
      Polymer.dom.flush();

      var newPhysicalSize = 0;
      var oldPhysicalSize = 0;
      var prevAvgCount = this._physicalAverageCount;
      var prevPhysicalAvg = this._physicalAverage;

      this._iterateItems(function (pidx, vidx) {

        oldPhysicalSize += this._physicalSizes[pidx] || 0;
        this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;
        newPhysicalSize += this._physicalSizes[pidx];
        this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;
      }, itemSet);

      this._viewportHeight = this._scrollTargetHeight;
      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;

      // update the average if we measured something
      if (this._physicalAverageCount !== prevAvgCount) {
        this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);
      }
    },

    /**
     * Updates the position of the physical items.
     */
    _positionItems: function _positionItems() {
      this._adjustScrollPosition();

      var y = this._physicalTop;

      this._iterateItems(function (pidx, vidx) {
        this._physicalItems[pidx].style.transform = this._getTranslate(0, y);
        y += this._physicalSizes[pidx];
      });
    },

    _getPhysicalSizeIncrement: function _getPhysicalSizeIncrement(pidx) {
      return this._physicalSizes[pidx];
    },

    /**
     * Returns, based on the current index,
     * whether or not the next index will need
     * to be rendered on a new row.
     *
     * @param {number} vidx Virtual index
     * @return {boolean}
     */
    _shouldRenderNextRow: function _shouldRenderNextRow(vidx) {
      return vidx % this._itemsPerRow === this._itemsPerRow - 1;
    },

    /**
     * Adjusts the scroll position when it was overestimated.
     */
    _adjustScrollPosition: function _adjustScrollPosition() {
      var deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);

      if (deltaHeight) {
        this._physicalTop = this._physicalTop - deltaHeight;
        // juking scroll position during interial scrolling on iOS is no bueno
        if (!IOS_TOUCH_SCROLLING && this._physicalTop !== 0) {
          this._resetScrollPosition(this._scrollTop - deltaHeight);
        }
      }
    },

    /**
     * Sets the position of the scroll.
     */
    _resetScrollPosition: function _resetScrollPosition(pos) {
      if (this.scrollTarget) {
        this._scrollTop = pos;
        this._scrollPosition = this._scrollTop;
      }
    },

    /**
     * Sets the scroll height, that's the height of the content,
     *
     * @param {boolean=} forceUpdate If true, updates the height no matter what.
     */
    _updateScrollerSize: function _updateScrollerSize(forceUpdate) {
      this._estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;

      forceUpdate = forceUpdate || this._scrollHeight === 0;
      forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;

      // amortize height adjustment, so it won't trigger repaints very often
      if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._optPhysicalSize) {
        this.$.items.style.height = this._estScrollHeight + 'px';
        this._scrollHeight = this._estScrollHeight;
      }
    },

    /**
     * Scroll to a specific index in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToIndex
     * @param {number} idx The index of the item
     */
    scrollToIndex: function scrollToIndex(idx) {
      Polymer.dom.flush();

      idx = Math.min(Math.max(idx, 0), this._virtualCount - 1);
      // update the virtual start only when needed
      if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
        this._virtualStart = idx - 1;
      }
      // assign new models
      this._assignModels();
      // measure the new sizes
      this._updateMetrics();

      // estimate new physical offset
      var estPhysicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;
      this._physicalTop = estPhysicalTop;

      var currentTopItem = this._physicalStart;
      var currentVirtualItem = this._virtualStart;
      var targetOffsetTop = 0;
      var hiddenContentSize = this._hiddenContentSize;

      // scroll to the item as much as we can
      while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
        targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);
        currentTopItem = (currentTopItem + 1) % this._physicalCount;
        currentVirtualItem++;
      }
      // update the scroller size
      this._updateScrollerSize(true);
      // update the position of the items
      this._positionItems();
      // set the new scroll position
      this._resetScrollPosition(this._physicalTop + this._scrollerPaddingTop + targetOffsetTop);
      // increase the pool of physical items if needed
      this._increasePoolIfNeeded();
      // clear cached visible index
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
    },

    /**
     * Reset the physical average and the average count.
     */
    _resetAverage: function _resetAverage() {
      this._physicalAverage = 0;
      this._physicalAverageCount = 0;
    },

    /**
     * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
     * when the element is resized.
     */
    _resizeHandler: function _resizeHandler() {
      // iOS fires the resize event when the address bar slides up
      if (IOS && Math.abs(this._viewportHeight - this._scrollTargetHeight) < 100) {}
      // return;

      // In Desktop Safari 9.0.3, if the scroll bars are always shown,
      // changing the scroll position from a resize handler would result in
      // the scroll position being reset. Waiting 1ms fixes the issue.
      Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', function () {
        this.updateViewportBoundaries();
        this._render();

        if (this._itemsRendered && this._physicalItems && this._isVisible) {
          this._resetAverage();
          this.scrollToIndex(this.firstVisibleIndex);
        }
      }.bind(this), 1));
    },

    /**
     * Updates the size of an item.
     *
     * @method updateSizeForItem
     * @param {|number} index
     */
    // TODO: rename to updateSizeForIndex ?
    updateSizeForItem: function updateSizeForItem(index) {
      var pidx = this._physicalIndexForKey[index];

      if (pidx != null) {
        this._updateMetrics([pidx]);
        this._positionItems();
      }
    },

    _isIndexRendered: function _isIndexRendered(idx) {
      return idx >= this._virtualStart && idx <= this._virtualEnd;
    },

    _isIndexVisible: function _isIndexVisible(idx) {
      return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;
    }
  };
}();

/**
 * @polymerBehavior vaadin.elements.grid.IronListBehavior
 */
vaadin.elements.grid.IronListBehavior = [Polymer.Templatizer, Polymer.IronScrollTargetBehavior, vaadin.elements.grid.IronListBehaviorImpl];</script><dom-module id="vaadin-grid-table-styles" assetpath="../bower_components/vaadin-grid/"><template><style>@keyframes appear{to{opacity:1;}}:host{display:block;position:relative;animation:1ms appear;}@media only screen and (-webkit-max-device-pixel-ratio: 1){:host{will-change:transform;}}#items{position:relative;}#items,
      #fixedsizer,
      #outersizer{border-top:0 solid transparent;border-bottom:0 solid transparent;}:host(:not([grid])) #items > ::content > *{width:100%;}#items > tr{box-sizing:border-box;margin:0;position:absolute;}table{height:100%;width:100%;display:block;overflow:auto;box-sizing:border-box;}[overflow-hidden]{overflow:hidden;}tbody{display:block;}thead th,
      tfoot td{top:0;}.vaadin-grid-cell{padding:0;flex-shrink:0;flex-grow:1;box-sizing:border-box;display:flex;}.vaadin-grid-cell:not([detailscell]){position:relative;}.vaadin-grid-cell ::content > vaadin-grid-cell-content{width:100%;display:inline-flex;justify-content:center;flex-direction:column;white-space:nowrap;overflow:hidden;}.vaadin-grid-column-resize-handle{position:absolute;right:0;height:100%;cursor:col-resize;z-index:1;}.vaadin-grid-column-resize-handle::before{position:absolute;content:"";height:100%;width:35px;transform:translateX(-50%);}[lastcolumn] .vaadin-grid-column-resize-handle::before,
      [last-frozen] .vaadin-grid-column-resize-handle::before{width:18px;transform:translateX(-100%);}:host([column-reordering-allowed]) #header,
      :host([column-resizing]){-ms-user-select:none;-moz-user-select:none;-webkit-user-select:none;user-select:none;}:host([column-resizing]){cursor:col-resize;}:host([ios][column-resizing]) #outerscroller{overflow:hidden;}tr:not([hidden]){display:flex;width:100%;}[frozen]{z-index:2;}[hidden]{display:none;}caption{position:absolute;display:block;padding:0;width:100%;z-index:-100;}::content > vaadin-grid-column,
      ::content > vaadin-grid-selection-column,
      ::content > vaadin-grid-column-group{display:none;}:host([no-content-pointer-events]) .vaadin-grid-cell ::content > vaadin-grid-cell-content{pointer-events:none;}#reorderghost{visibility:hidden;position:fixed;opacity:0.5;pointer-events:none;}:host([copying]) tr{opacity:0 !important;position:static !important;display:table-row !important;}:host([copying]) .vaadin-grid-cell{display:table-cell !important;}</style></template></dom-module><dom-module id="vaadin-grid-table-themability-styles" assetpath="../bower_components/vaadin-grid/"><template><style>thead tr:last-child th ::content > vaadin-grid-cell-content{border-bottom:1px solid var(--divider-color, rgba(0, 0, 0, 0.08));}tfoot tr:first-child td ::content > vaadin-grid-cell-content{border-top:1px solid var(--divider-color, rgba(0, 0, 0, 0.08));}tbody tr:not([lastrow]) td ::content > vaadin-grid-cell-content{border-bottom:1px solid var(--divider-color, rgba(0, 0, 0, 0.08));}[last-frozen] ::content > vaadin-grid-cell-content{border-right:1px solid var(--divider-color, rgba(0, 0, 0, 0.08));}.vaadin-grid-column-resize-handle{border-right:1px solid var(--divider-color, rgba(0, 0, 0, 0.08));@apply (--vaadin-grid-column-resize-handle);}table tr .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{background:#fff;text-align:left;padding:8px;box-sizing:border-box;@apply (--vaadin-grid-cell);}table thead .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{font-weight:500;@apply (--vaadin-grid-header-cell);}table tfoot .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{font-weight:500;@apply (--vaadin-grid-footer-cell);}table tbody .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{@apply (--vaadin-grid-body-cell);}tbody [odd] .vaadin-grid-cell:not([detailscell]) ::content > vaadin-grid-cell-content{@apply (--vaadin-grid-body-row-odd-cell);}table tr .vaadin-grid-cell:not([detailscell])[last-frozen] ::content > vaadin-grid-cell-content{@apply (--vaadin-grid-cell-last-frozen);}:host(:not([scrolling])) tbody tr:hover .vaadin-grid-cell ::content > vaadin-grid-cell-content{@apply (--vaadin-grid-body-row-hover-cell);}table tr .vaadin-grid-cell.vaadin-grid-cell[lastcolumn] ::content > vaadin-grid-cell-content{border-right:none;}</style></template></dom-module><dom-module id="vaadin-grid-table" assetpath="../bower_components/vaadin-grid/"><template><style include="vaadin-grid-table-scroll-styles"></style><style include="vaadin-grid-row-details-styles"></style><style include="vaadin-grid-table-styles"></style><style include="vaadin-grid-table-themability-styles"></style><style include="vaadin-grid-selection-themability-styles"></style><style include="vaadin-grid-navigation-themability-styles"></style><style include="vaadin-grid-active-item-themability-styles"></style><style include="vaadin-grid-data-provider-themability-styles"></style><style include="vaadin-grid-row-details-themability-styles"></style><style include="vaadin-grid-column-reordering-themability-styles"></style><vaadin-grid-table-focus-trap id="headerFocusTrap" on-focus="_onHeaderFocus" on-focusin="_onHeaderFocus" on-focusout="_onFocusout"></vaadin-grid-table-focus-trap><content select="#headerFocusTrap"></content><vaadin-grid-table-focus-trap id="bodyFocusTrap" on-focus="_onBodyFocus" on-focusin="_onBodyFocus" on-focusout="_onFocusout"></vaadin-grid-table-focus-trap><content select="#bodyFocusTrap"></content><content select="vaadin-grid-column, vaadin-grid-selection-column, vaadin-grid-column-group"></content><div id="spinner"></div><table id="table" overflow-hidden$="[[_hideTableOverflow(scrollbarWidth, safari)]]"><caption><div id="fixedsizer" is="vaadin-grid-sizer" top="[[_estScrollHeight]]" column-tree="[[columnTree]]"></div></caption><thead id="header" target="[[target]]" is="vaadin-grid-table-header" column-tree="[[columnTree]]"></thead><tbody id="items" is="vaadin-grid-table-body"></tbody><tfoot id="footer" target="[[target]]" is="vaadin-grid-table-footer" column-tree="[[columnTree]]"></tfoot></table><vaadin-grid-table-outer-scroller id="outerscroller" scroll-target="[[scrollTarget]]" overflow-hidden$="[[_hideOuterScroller(scrollbarWidth, safari)]]" ios$="[[ios]]" scrolling$="[[scrolling]]"><div id="outersizer" is="vaadin-grid-sizer" top="[[_estScrollHeight]]" column-tree="[[columnTree]]"></div></vaadin-grid-table-outer-scroller><div id="reorderghost"></div><content select="#footerFocusTrap"></content><vaadin-grid-table-focus-trap id="footerFocusTrap" on-focus="_onFooterFocus" on-focusin="_onFooterFocus" on-focusout="_onFocusout"></vaadin-grid-table-focus-trap></template></dom-module><script>

Polymer({

  is: 'vaadin-grid-table',

  behaviors: [vaadin.elements.grid.IronListBehavior, vaadin.elements.grid.TableScrollBehavior, vaadin.elements.grid.TableKeyboardBehavior, vaadin.elements.grid.TableColumnReorderingBehavior, Polymer.Templatizer],

  properties: {
    size: Number,

    columnTree: Array,

    bindData: Function,

    rowDetailsTemplate: Object,

    columnReorderingAllowed: {
      type: Boolean,
      reflectToAttribute: true
    },

    safari: {
      type: Boolean,
      value: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
    },

    scrollbarWidth: {
      type: Number,
      value: function value() {
        // Create the measurement node
        var scrollDiv = document.createElement('div');
        scrollDiv.style.width = '100px';
        scrollDiv.style.height = '100px';
        scrollDiv.style.overflow = 'scroll';
        scrollDiv.style.position = 'absolute';
        scrollDiv.style.top = '-9999px';
        document.body.appendChild(scrollDiv);
        // Get the scrollbar width
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

        // Delete the DIV
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      }
    },

    target: Object,

    hasData: Boolean
  },

  observers: ['_columnTreeChanged(columnTree, _physicalItems, _physicalCountVal)', '_sizeChanged(size, bindData, hasData)', '_rowDetailsTemplateChanged(rowDetailsTemplate, _physicalItems, _physicalCountVal)'],

  listeners: {
    'property-changed': '_columnPropChanged',
    'copy': '_onCopy',
    'animationend': '_onAnimationEnd',
    'header.column-resizing': '_onColumnResize'
  },

  _onColumnResize: function _onColumnResize() {
    this.toggleAttribute('column-resizing', this.$.header.querySelector('[column-resizing]'));
    this._gridResizeHandler();
  },

  _onAnimationEnd: function _onAnimationEnd(e) {
    if (/appear/.test(e.animationName)) {
      this._render();
      this._updateHeaderFooterMetrics();
      e.stopPropagation();
    }
  },

  _columnPropChanged: function _columnPropChanged(e) {
    if (e.detail.path === 'headerTemplate') {
      this.toggleAttribute('has-templates', true, this.$.header);
    }

    if (e.detail.path === 'footerTemplate') {
      this.toggleAttribute('has-templates', true, this.$.footer);
    }

    if (/frozen|hidden/.test(e.detail.path)) {
      this._frozenCellsChanged();
    }

    if (e.detail.path === 'hidden') {
      this._gridResizeHandler();
    }
  },

  _onCopy: function _onCopy() {
    if (this.safari) {
      this.toggleAttribute('copying', true);
      this.async(function () {
        this.toggleAttribute('copying', false);
      }, 1);
    }
  },

  // The following values aim at avoiding having 2 overlapping semi-invisible
  // scrollbars visible at the same time when scrollbar width is 0
  // (OSX's "show scrollbars: when scrolling").
  // 1. hide the outerscroller altogether when scrollbar width is 0
  _hideOuterScroller: function _hideOuterScroller(scrollbarWidth, safari) {
    return scrollbarWidth === 0 && !safari;
  },
  // 2. Safari (on desktop and IOS) requires outer scroller to work properly
  // so in that case we hide the table's scrollbar instead.
  _hideTableOverflow: function _hideTableOverflow(scrollbarWidth, safari) {
    return scrollbarWidth === 0 && safari;
  },

  _rowDetailsTemplateChanged: function _rowDetailsTemplateChanged(rowDetailsTemplate, physicalItems) {
    physicalItems.forEach(function (row) {
      row.rowDetailsTemplate = rowDetailsTemplate;
    });
  },

  _columnTreeChanged: function _columnTreeChanged(columnTree, physicalItems, count) {
    this._frozenCellsChanged();
    this._hasTemplatesChanged(columnTree);

    physicalItems.forEach(function (row) {
      row.columns = columnTree[columnTree.length - 1];
    });

    this._gridResizeHandler();
    this._updateLastColumn();
  },

  _updateLastColumn: function _updateLastColumn() {
    Polymer.dom(this.$.table).querySelectorAll('tr').forEach(function (row) {
      row.updateLastColumn();
    });
  },

  _updateHeaderFooterMetrics: function _updateHeaderFooterMetrics() {
    if (this._physicalSizes) {
      Polymer.dom.flush();
    }
    this._updateHeaderFooterMetricsSync();

    Polymer.RenderStatus.afterNextRender(this.$.header, function () {
      this._updateHeaderFooterMetricsSync();
      if (this._pendingScrollToScaledIndex) {
        this.scrollToScaledIndex(this._pendingScrollToScaledIndex);
      }
    }.bind(this));
  },

  _updateHeaderFooterMetricsSync: function _updateHeaderFooterMetricsSync() {
    var headerHeight = this.$.header.clientHeight + 'px';
    var footerHeight = this.$.footer.clientHeight + 'px';

    [this.$.outersizer, this.$.fixedsizer, this.$.items].forEach(function (element) {
      element.style.borderTopWidth = headerHeight;
      element.style.borderBottomWidth = footerHeight;
    });
  },

  _hasTemplatesChanged: function _hasTemplatesChanged(columnTree) {
    var hasHeaders = false;
    var hasFooters = false;
    columnTree.forEach(function (row) {
      return row.forEach(function (col) {
        hasHeaders = hasHeaders || col.headerTemplate;
        hasFooters = hasFooters || col.footerTemplate;
      });
    });

    this.toggleAttribute('has-templates', hasHeaders, this.$.header);
    this.toggleAttribute('has-templates', hasFooters, this.$.footer);
  },

  /**
   * Creates a pool of DOM elements and attaches them to the local dom.
   */
  _createPool: function _createPool(size) {
    var physicalItems = new Array(size);

    for (var i = 0; i < size; i++) {
      var row = document.createElement('tr', 'vaadin-grid-table-row');
      row.target = this.domHost;
      physicalItems[i] = row;
      row.setAttribute('hidden', ''); // hidden by default, removed when data is bound.
      Polymer.dom(this.$.items).appendChild(row);
    }

    return physicalItems;
  },

  _sizeChanged: function _sizeChanged(size, bindData, hasData) {
    var scrollTop = this._scrollTop;
    var firstVisibleIndex = this.firstVisibleIndex + this._vidxOffset;

    /* TODO: virtual count of 500k will make the sizer.top too large for Firefox */
    this._virtualCount = Math.min(size, 100000);
    this._physicalIndexForKey = {};
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;

    this._vidxOffset = 0;

    if (!this._physicalItems) {
      var DEFAULT_PHYSICAL_COUNT = 25;

      this._physicalCount = Math.max(1, Math.min(DEFAULT_PHYSICAL_COUNT, this._virtualCount));
      this._physicalItems = this._createPool(this._physicalCount);
      this._physicalSizes = new Array(this._physicalCount);
    }

    this._itemsRendered = false;

    this._debounceTemplate(function () {
      this._render();

      if (!this._viewportHeight) {
        return;
        // Don't run the following before init or pool size for non-Chrome browsers grows too large
      }

      // The size may have decreased so need to scroll to appropriate index first
      this.scrollToScaledIndex(Math.min(firstVisibleIndex, this.size));
      // Scroll to the original scroll position (if possible)
      this._scrollTop = scrollTop;
      this._scrollHandler();

      this.flushDebouncer('vaadin-grid-scrolling');
    });
  },

  /**
   * Assigns the data models to a given set of items.
   * @param {!Array<number>=} itemSet
   */
  _assignModels: function _assignModels(itemSet) {
    this._virtualIndexToItem = this._virtualIndexToItem || {};
    this._iterateItems(function (pidx, vidx) {
      var el = this._physicalItems[pidx];
      if (el.index) {
        delete this._virtualIndexToItem[el.index];
      }
      el.index = vidx + this._vidxOffset;
      this._virtualIndexToItem[el.index] = el;
      el.toggleAttribute('odd', el.index % 2);
      el.toggleAttribute('lastrow', el.index === this.size - 1);
      el.toggleAttribute('hidden', el.index >= this.size);
      this.bindData(el.index, el);
    }, itemSet);
  },

  _gridResizeHandler: function _gridResizeHandler() {
    this._updateHeaderFooterMetrics();

    if (this._physicalSizes) {
      this._physicalItems.forEach(function (row) {
        row.updateRowDetailsCellMetrics();
      });
      this.debounce('vaadin-grid-resizing', function () {
        this._update();
      }.bind(this), 1);
    }
  }

});</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.ColumnBaseBehavior
 */
vaadin.elements.grid.ColumnBaseBehavior = {
  properties: {

    /**
     * When set to true, the column is user-resizable.
     * @default false
     */
    resizable: {
      type: Boolean,
      value: function value() {
        if (this.localName === 'vaadin-grid-column-group') {
          return;
        }

        var parent = Polymer.dom(this).parentNode;
        if (parent && parent.localName === 'vaadin-grid-column-group') {
          return parent.resizable || false;
        } else {
          return false;
        }
      }
    },

    /**
     * @private
     */
    headerTemplate: {
      type: Object,
      value: function value() {
        return this._findTemplate('template.header') || null;
      }
    },

    /**
     * @private
     */
    footerTemplate: {
      type: Object,
      value: function value() {
        return this._findTemplate('template.footer') || null;
      }
    },

    /**
     * When true, the column is frozen. When a column inside of a column group is frozen,
     * all of the sibling columns inside the group will get frozen also.
     */
    frozen: {
      type: Boolean,
      notify: true,
      value: false
    },

    /**
     * When set to true, the cells for this column are hidden.
     */
    hidden: {
      type: Boolean,
      notify: true
    },

    _lastFrozen: {
      type: Boolean,
      notify: true,
      value: false
    },

    _order: Number,

    _reorderStatus: Boolean
  },

  observers: ['_footerTemplateChanged(footerTemplate)', '_headerTemplateChanged(headerTemplate)', '_lastFrozenChanged(_lastFrozen)'],

  _selectFirstTemplate: function _selectFirstTemplate(selector) {
    return Polymer.dom(this).querySelectorAll(selector).filter(function (el) {
      return el.parentElement === this;
    }.bind(this))[0];
  },

  _findTemplate: function _findTemplate(selector) {
    var template = this._selectFirstTemplate(selector);
    if (template) {
      if (this.dataHost) {
        // set dataHost to the context where template has been defined
        template._rootDataHost = this.dataHost._rootDataHost || this.dataHost;
      }
    }
    return template;
  },

  _headerTemplateChanged: function _headerTemplateChanged(headerTemplate) {
    if (headerTemplate) {
      var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
      templatizer._instanceProps = {};
      templatizer.template = headerTemplate;
    }

    this.fire('property-changed', { path: 'headerTemplate', value: headerTemplate });
  },

  _footerTemplateChanged: function _footerTemplateChanged(footerTemplate) {
    if (footerTemplate) {
      var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
      templatizer._instanceProps = {};
      templatizer.template = footerTemplate;
    }

    this.fire('property-changed', { path: 'footerTemplate', value: footerTemplate });
  },

  _flexGrowChanged: function _flexGrowChanged(flexGrow) {
    this.fire('property-changed', { path: 'flexGrow', value: flexGrow });
  },

  _widthChanged: function _widthChanged(width) {
    this.fire('property-changed', { path: 'width', value: width });
  },

  _lastFrozenChanged: function _lastFrozenChanged(lastFrozen) {
    this.fire('property-changed', { path: 'lastFrozen', value: lastFrozen });
  }
};

/**
 * @polymerBehavior vaadin.elements.grid.ColumnBehaviorImpl
 */
vaadin.elements.grid.ColumnBehaviorImpl = {
  properties: {
    /**
     * Width of the cells for this column.
     */
    width: {
      type: String,
      value: '100px'
    },

    /**
     * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
     */
    flexGrow: {
      type: Number,
      value: 1
    },

    /**
     * @private
     */
    template: {
      type: Object,
      value: function value() {
        return this._findTemplate('template:not(.header):not(.footer)');
      }
    }

  },

  observers: ['_flexGrowChanged(flexGrow)', '_widthChanged(width)', '_templateChanged(template)', '_frozenChanged(frozen, isAttached)', '_hiddenChanged(hidden)', '_orderChanged(_order)', '_reorderStatusChanged(_reorderStatus)', '_resizableChanged(resizable)'],

  _frozenChanged: function _frozenChanged(frozen, isAttached) {
    // since `frozen` is defined in ColumnBaseBehavior, this observer is triggered
    // normally before the column is actually attached to the DOM.
    // For events to bubble in Safari 9, element needs to be attached.
    if (isAttached) {
      this.fire('property-changed', { path: 'frozen', value: frozen });
    }
  },

  _templateChanged: function _templateChanged(template) {
    var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);

    // body cell templatizer needs to be attached so that `item-changed` and
    // `template-instance-changed` events propagate to grid.
    Polymer.dom(this.root).appendChild(templatizer);

    templatizer.template = template;

    // We bubble false for optimisation
    this.fire('property-changed', { path: 'template', value: template }, { bubbles: false });
  },

  _hiddenChanged: function _hiddenChanged(hidden) {
    this.fire('property-changed', { path: 'hidden', value: hidden });
  },

  _orderChanged: function _orderChanged(order) {
    this.fire('property-changed', { path: 'order', value: order });
  },

  _reorderStatusChanged: function _reorderStatusChanged(reorderStatus) {
    this.fire('property-changed', { path: 'reorderStatus', value: reorderStatus });
  },

  _resizableChanged: function _resizableChanged(resizable) {
    this.fire('property-changed', { path: 'resizable', value: resizable });
  }
};

/**
 * @polymerBehavior vaadin.elements.grid.ColumnBehavior
 */
vaadin.elements.grid.ColumnBehavior = [vaadin.elements.grid.ColumnBaseBehavior, vaadin.elements.grid.ColumnBehaviorImpl];</script><dom-module id="vaadin-grid-column" assetpath="../bower_components/vaadin-grid/"><script>
Polymer({
  is: 'vaadin-grid-column',

  behaviors: [vaadin.elements.grid.ColumnBehavior]
});</script></dom-module><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.ArrayDataProviderBehavior
 */
vaadin.elements.grid.ArrayDataProviderBehavior = {

  properties: {

    /**
     * An array containing the items which will be stamped to the column template
     * instances.
     */
    items: Array

  },

  observers: ['_itemsChanged(items, items.*)'],

  _itemsChanged: function _itemsChanged(items, splices) {
    this.size = (items || []).length;
    this.dataProvider = this.dataProvider || this._arrayDataProvider;
    this.clearCache();
  },

  _arrayDataProvider: function _arrayDataProvider(opts, cb) {
    var items = (this.items || []).slice(0);

    if (this._checkPaths(this._filters, 'filtering', items)) {
      items = this._filter(items);
    }

    this.size = items.length;

    if (opts.sortOrders.length && this._checkPaths(this._sorters, 'sorting', items)) {
      items = items.sort(this._multiSort.bind(this));
    }

    var start = opts.page * opts.pageSize;
    var end = start + opts.pageSize;
    var slice = items.slice(start, end);
    cb(slice, items.length);
  },

  /**
   * Check array of filters/sorters for paths validity, console.warn invalid items
   * @param {Array}  arrayToCheck The array of filters/sorters to check
   * @param {string} action       The name of action to include in warning (filtering, sorting)
   * @param {Array}  items
   */
  _checkPaths: function _checkPaths(arrayToCheck, action, items) {
    if (!items.length) {
      return false;
    }

    var result = true;

    for (var i in arrayToCheck) {
      var path = arrayToCheck[i].path;

      // skip simple paths
      if (!path || path.indexOf('.') === -1) {
        continue;
      }

      var parentProperty = path.replace(/\.[^\.]*/, ''); // a.b.c -> a.b
      if (Polymer.Base.get(parentProperty, items[0]) === undefined) {
        console.warn('Path "' + path + '" used for ' + action + ' does not exist in all of the items, ' + action + ' is disabled.');
        result = false;
      }
    }

    return result;
  },

  _multiSort: function _multiSort(a, b) {
    return this._sorters.map(function (sort) {
      if (sort.direction === 'asc') {
        return this._compare(Polymer.Base.get(sort.path, a), Polymer.Base.get(sort.path, b));
      } else if (sort.direction === 'desc') {
        return this._compare(Polymer.Base.get(sort.path, b), Polymer.Base.get(sort.path, a));
      }
      return 0;
    }, this).reduce(function firstNonZeroValue(p, n) {
      return p ? p : n;
    }, 0);
  },

  _normalizeEmptyValue: function _normalizeEmptyValue(value) {
    if ([undefined, null].indexOf(value) >= 0) {
      return '';
    } else if (isNaN(value)) {
      return value.toString();
    } else {
      return value;
    }
  },

  _compare: function _compare(a, b) {
    a = this._normalizeEmptyValue(a);
    b = this._normalizeEmptyValue(b);

    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  },

  _filter: function _filter(items) {
    return items.filter(function (item, index) {
      return this._filters.filter(function (filter) {
        var value = this._normalizeEmptyValue(Polymer.Base.get(filter.path, item));
        return value.toString().toLowerCase().indexOf(filter.value.toString().toLowerCase()) === -1;
      }.bind(this)).length === 0;
    }, this);
  }

};</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.DynamicColumnsBehavior
 */
vaadin.elements.grid.DynamicColumnsBehavior = {
  ready: function ready() {
    this._addNodeObserver();
  },

  _hasColumnGroups: function _hasColumnGroups(columns) {
    for (var i = 0; i < columns.length; i++) {
      if (columns[i].localName === 'vaadin-grid-column-group') {
        return true;
      }
    }

    return false;
  },

  _childrenColumns: function _childrenColumns(columns) {
    return columns.map(function (col) {
      if (col.localName === 'vaadin-grid-column-group') {
        var children = Polymer.dom(col).children.filter(function (el) {
          return (/^vaadin-grid-(column|selection)/.test(el.localName)
          );
        });
        return children;
      } else {
        return [col];
      }
    }).reduce(function (prev, curr) {
      return prev.concat(curr);
    }, []);
  },

  _getColumnTree: function _getColumnTree() {
    var rootColumns = this.queryAllEffectiveChildren('vaadin-grid-column, vaadin-grid-column-group, vaadin-grid-selection-column');

    var _columnTree = [];

    for (var c = rootColumns;;) {
      _columnTree.push(c);
      if (!this._hasColumnGroups(c)) {
        break;
      }
      c = this._childrenColumns(c);
    }

    return _columnTree;
  },

  _updateColumnTree: function _updateColumnTree() {
    var columnTree = this._getColumnTree();
    if (!this._arrayEquals(columnTree, this._columnTree)) {
      this._columnTree = columnTree;
    }
  },

  _addNodeObserver: function _addNodeObserver() {
    this._observer = Polymer.dom(this).observeNodes(function (info) {
      var rootColumns = function rootColumns(node) {
        return node.nodeType === Node.ELEMENT_NODE && /^vaadin-grid-(column|selection)/i.test(node.localName);
      };
      if (info.addedNodes.filter(rootColumns).length > 0 || info.removedNodes.filter(rootColumns).length > 0) {
        this._updateColumnTree();
      }

      // in native Shadow, tab order goes first through shadow root, then moves over
      // to light children. We need to make sure footer focus trap is always
      // the very last element that can be tabbed into.
      if (Polymer.Settings.useNativeShadow) {
        Polymer.dom(this).insertBefore(this.$.scroller.$.bodyFocusTrap, Polymer.dom(this).firstElementChild);
        Polymer.dom(this).insertBefore(this.$.scroller.$.headerFocusTrap, Polymer.dom(this).firstElementChild);
        Polymer.dom(this).appendChild(this.$.scroller.$.footerFocusTrap);
      }

      this.debounce('check-imports', this._checkImports, 2000);
    }.bind(this));
  },

  _arrayEquals: function _arrayEquals(arr1, arr2) {
    if (!arr1 || !arr2 || arr1.length != arr2.length) {
      return false;
    }

    for (var i = 0, l = arr1.length; i < l; i++) {
      // Check if we have nested arrays
      if (arr1[i] instanceof Array && arr2[i] instanceof Array) {
        // recurse into the nested arrays
        if (!this._arrayEquals(arr1[i], arr2[i])) {
          return false;
        }
      } else if (arr1[i] != arr2[i]) {
        return false;
      }
    }
    return true;
  },

  _checkImports: function _checkImports() {
    ['vaadin-grid-column-group', 'vaadin-grid-sorter', 'vaadin-grid-filter', 'vaadin-grid-selection-column'].forEach(function (elementName) {
      var element = Polymer.dom(this).querySelector(elementName);
      if (element && !Polymer.isInstance(element)) {
        console.warn('Make sure you have imported the required module for <' + elementName + '> element.');
      }
    }, this);
  }
};</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.SortBehavior
 */
vaadin.elements.grid.SortBehavior = {

  properties: {

    /*
     * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
     */
    multiSort: {
      type: Boolean,
      value: false
    },

    _sorters: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    _previousSorters: {
      type: Array,
      value: function value() {
        return [];
      }
    }

  },

  listeners: {
    'sorter-changed': '_onSorterChanged'
  },

  _onSorterChanged: function _onSorterChanged(e) {
    var sorter = e.target;

    this._removeArrayItem(this._sorters, sorter);
    sorter._order = null;

    if (this.multiSort) {
      if (sorter.direction) {
        this._sorters.unshift(sorter);
      }

      this._sorters.forEach(function (sorter, index) {
        sorter._order = this._sorters.length > 1 ? index : null;
      }, this);
    } else {
      this._sorters.forEach(function (sorter) {
        sorter._order = null;
        sorter.direction = null;
      });

      if (sorter.direction) {
        this._sorters = [sorter];
      }
    }

    e.stopPropagation();

    if (this.dataProvider &&
    // No need to clear cache if sorters didn't change
    JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
      this.clearCache();
    }

    this._previousSorters = this._mapSorters();
  },

  _mapSorters: function _mapSorters() {
    return this._sorters.map(function (sorter) {
      return {
        path: sorter.path,
        direction: sorter.direction
      };
    });
  },

  _removeArrayItem: function _removeArrayItem(array, item) {
    var index = array.indexOf(item);
    if (index > -1) {
      array.splice(index, 1);
    }
  }

};</script><script>
window.vaadin = window.vaadin || {};
vaadin.elements = vaadin.elements || {};
vaadin.elements.grid = vaadin.elements.grid || {};

/**
 * @polymerBehavior vaadin.elements.grid.FilterBehavior
 */
vaadin.elements.grid.FilterBehavior = {
  properties: {

    _filters: {
      type: Array,
      value: function value() {
        return [];
      }
    }

  },

  listeners: {
    'filter-changed': '_filterChanged'
  },

  _filterChanged: function _filterChanged(e) {
    if (this._filters.indexOf(e.target) === -1) {
      this._filters.push(e.target);
    }

    e.stopPropagation();

    if (this.dataProvider) {
      this.clearCache();
    }
  },

  _mapFilters: function _mapFilters() {
    return this._filters.map(function (filter) {
      return {
        path: filter.path,
        value: filter.value
      };
    });
  }
};</script><dom-module id="vaadin-grid" assetpath="../bower_components/vaadin-grid/"><template><style>:host{display:block;height:400px;background:var(--primary-background-color, #fff);box-sizing:border-box;border:1px solid var(--divider-color, rgba(0, 0, 0, 0.08));-webkit-tap-highlight-color:transparent;}:host(:focus){outline:none;}#scroller{height:100%;width:100%;}</style><vaadin-grid-table id="scroller" loading$="[[_loading]]" bind-data="[[_bindData]]" size="[[size]]" column-tree="[[_columnTree]]" content-target="[[_getContentTarget()]]" row-details-template="[[_rowDetailsTemplate]]" column-reordering-allowed="[[columnReorderingAllowed]]"><content></content></vaadin-grid-table></template></dom-module><script>
Polymer({
  is: 'vaadin-grid',

  properties: {

    _columnTree: {
      type: Array,
      notify: true
    },

    /**
     * Estimated size of the grid data (number of items).
     * When using function data providers, it always needs to be set manually.
     */
    size: Number,

    _rowDetailsTemplate: Object,

    _bindData: {
      type: Object,
      value: function value() {
        return this._getItem.bind(this);
      }
    }
  },

  behaviors: [Polymer.IronA11yKeysBehavior, Polymer.IronResizableBehavior, vaadin.elements.grid.ActiveItemBehavior, vaadin.elements.grid.RowDetailsBehavior, vaadin.elements.grid.DataProviderBehavior, vaadin.elements.grid.DynamicColumnsBehavior, vaadin.elements.grid.ArrayDataProviderBehavior, vaadin.elements.grid.SelectionBehavior, vaadin.elements.grid.SortBehavior, vaadin.elements.grid.FilterBehavior, vaadin.elements.grid.KeyboardNavigationBehavior, vaadin.elements.grid.ColumnReorderingBehavior],

  listeners: {
    'property-changed': '_columnPropChanged',
    'iron-resize': '_gridResizeHandler'
  },

  _updateItem: function _updateItem(row, item) {
    row.style.minHeight = item ? '' : this.$.scroller._physicalAverage + 'px';
    row.item = item;
    row.selected = this._isSelected(item);
    row.expanded = this._isExpanded(item);
    row.active = item !== null && item == this.activeItem;
    row.focused = row.index === this.$.scroller.$.items._focusedRowIndex;
  },

  _getContentTarget: function _getContentTarget() {
    return this;
  },

  ready: function ready() {
    this._updateColumnTree();
    this._rowDetailsTemplate = Polymer.dom(this).querySelector('template.row-details') || undefined;
    this.$.scroller.target = this;

    if (document.doctype === null) {
      console.warn('<vaadin-grid> requires the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.');
    }
  },

  _columnPropChanged: function _columnPropChanged(e) {
    if (e.detail.path === '_childColumns') {
      this._updateColumnTree();
    }

    e.stopPropagation();
  },

  _gridResizeHandler: function _gridResizeHandler() {
    this.$.scroller._gridResizeHandler();
  }
});</script><dom-module id="vaadin-grid-column-group" assetpath="../bower_components/vaadin-grid/"><script>
Polymer({
  is: 'vaadin-grid-column-group',

  behaviors: [vaadin.elements.grid.ColumnBaseBehavior],

  properties: {
    _childColumns: {
      value: function value() {
        return Polymer.dom(this).querySelectorAll('vaadin-grid-column, vaadin-grid-selection-column');
      }
    },

    /**
     * Flex grow ratio for the column group as the sum of the ratios of its child columns.
     */
    flexGrow: {
      type: Number,
      readOnly: true
    },

    /**
     * Width of the column group as the sum of the widths of its child columns.
     */
    width: {
      type: String,
      readOnly: true
    },

    _visibleChildColumns: Array,

    /**
     * Represents the number of child columns of this group.
     */
    colSpan: {
      type: Number,
      notify: true,
      readOnly: true
    },

    _rootColumns: Array
  },

  observers: ['_updateVisibleChildColumns(_childColumns)', '_childColumnsChanged(_childColumns)', '_flexGrowChanged(flexGrow)', '_widthChanged(width)', '_frozenChanged(_childColumns, frozen)', '_hiddenChanged(hidden)', '_visibleChildColumnsChanged(_visibleChildColumns)', '_colSpanChanged(colSpan)', '_orderChanged(_order, _rootColumns)', '_reorderStatusChanged(_reorderStatus, _rootColumns)', '_resizableChanged(resizable, _rootColumns)'],

  listeners: {
    'property-changed': '_columnPropChanged'
  },

  attached: function attached() {
    this._updateFlexAndWidth(this._visibleChildColumns);
    this._addNodeObserver();
  },

  detached: function detached() {
    Polymer.dom(this).unobserveNodes(this._observer);
  },

  _columnPropChanged: function _columnPropChanged(e) {
    if (e.detail.path === 'hidden') {
      this._preventHiddenCascade = true;
      this._updateVisibleChildColumns(this._childColumns);
      this._preventHiddenCascade = false;
    }

    if (/flexGrow|width|hidden|_childColumns/.test(e.detail.path)) {
      this._updateFlexAndWidth(this._visibleChildColumns);
    }

    if (e.detail.path === 'frozen') {
      this.frozen = e.detail.value;
    }

    if (e.detail.path === 'lastFrozen') {
      this._lastFrozen = e.detail.value;
    }
  },

  _orderChanged: function _orderChanged(order, rootColumns) {
    if (order) {
      // The parent column order number cascades downwards to it's children
      // so that the resulting order numbering constructs as follows:
      // [             1000              ]
      // [     1100    ] | [     1200    ]
      // [1110] | [1120] | [1210] | [1220]

      // Trailing zeros are counted so we know the level on which we're working on.
      var trailingZeros = /(0+)$/.exec(order).pop().length;

      // In an unlikely situation where a group has more than 9 child columns,
      // the child scope must have 1 digit less...
      var childCountDigits = ~~(Math.log(rootColumns.length) / Math.log(Math.LN10)) + 1;

      // Final scope for the child columns needs to mind both factors.
      var scope = Math.pow(10, trailingZeros - childCountDigits);

      var _rootColumns = rootColumns.slice(0);
      if (_rootColumns[0] && _rootColumns[0]._order) {
        _rootColumns.sort(function (a, b) {
          return a._order - b._order;
        });
      }

      _rootColumns.forEach(function (column, index) {
        column._order = order + (index + 1) * scope;
      });

      this.fire('property-changed', { path: 'order', value: order });
    }
  },

  _reorderStatusChanged: function _reorderStatusChanged(reorderStatus, rootColumns) {
    rootColumns.forEach(function (column) {
      column._reorderStatus = reorderStatus;
    });

    this.fire('property-changed', { path: 'reorderStatus', value: reorderStatus });
  },

  _resizableChanged: function _resizableChanged(resizable, rootColumns) {
    rootColumns.forEach(function (column) {
      column.resizable = resizable;
    });

    this.fire('property-changed', { path: 'resizable', value: resizable });
  },

  _updateVisibleChildColumns: function _updateVisibleChildColumns(childColumns) {
    this._visibleChildColumns = childColumns.filter(function (col) {
      return !col.hidden;
    });
  },

  _childColumnsChanged: function _childColumnsChanged(childColumns) {
    if (!this._autoHidden && this.hidden) {
      childColumns.forEach(function (column) {
        column.hidden = true;
      });
      this._updateVisibleChildColumns(childColumns);
    }
    this.fire('property-changed', { path: '_childColumns', value: childColumns });
  },

  _updateFlexAndWidth: function _updateFlexAndWidth(visibleChildColumns) {
    if (visibleChildColumns.length) {
      this._setWidth('calc(' + visibleChildColumns.reduce(function (prev, curr) {
        return prev += ' + ' + (curr.width || '0px').replace('calc', '');
      }, '').substring(3) + ')');
    } else {
      this._setWidth('0px');
    }

    this._setFlexGrow(visibleChildColumns.reduce(function (prev, curr) {
      return prev + curr.flexGrow;
    }, 0));
  },

  _frozenChanged: function _frozenChanged(childColumns, frozen) {
    childColumns.forEach(function (col) {
      col.frozen = frozen;
    });
    this.fire('property-changed', { path: 'frozen', value: frozen });
  },

  _hiddenChanged: function _hiddenChanged(hidden) {
    if (this._rootColumns && !this._preventHiddenCascade) {
      this._ignoreVisibleChildColumns = true;
      this._rootColumns.forEach(function (column) {
        column.hidden = hidden;
      });
      this._ignoreVisibleChildColumns = false;
    }

    this.fire('property-changed', { path: 'hidden', value: hidden });
  },

  _visibleChildColumnsChanged: function _visibleChildColumnsChanged(visibleChildColumns) {
    this._setColSpan(visibleChildColumns.length);

    if (!this._ignoreVisibleChildColumns) {
      if (visibleChildColumns.length === 0) {
        this._autoHidden = this.hidden = true;
      } else if (this.hidden && this._autoHidden) {
        this._autoHidden = this.hidden = false;
      }
    }
  },

  _colSpanChanged: function _colSpanChanged(colSpan) {
    this.fire('property-changed', { path: 'colSpan', value: colSpan });
  },

  _addNodeObserver: function _addNodeObserver() {
    this._observer = Polymer.dom(this).observeNodes(function (info) {
      this._rootColumns = Polymer.dom(this).children.filter(function (child) {
        return (/column/.test(child.localName)
        );
      });
      var columns = function columns(node) {
        return node.nodeType === Node.ELEMENT_NODE && node.localName.indexOf('vaadin-grid-column') === 0;
      };
      if (info.addedNodes.filter(columns).length > 0 || info.removedNodes.filter(columns).length > 0) {
        this._childColumns = Polymer.dom(this).querySelectorAll('vaadin-grid-column');
      }
    }.bind(this));
  }
});</script></dom-module></div></body></html>