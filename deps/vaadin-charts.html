<html><head></head><body><div hidden="" by-polymer-bundler=""><link rel="import" href="elements.html"><style>@font-face{font-family:'FontAwesome';src:url("../bower_components/font-awesome/fonts/fontawesome-webfont.eot?v=4.7.0");src:url("../bower_components/font-awesome/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0") format('embedded-opentype'),url("../bower_components/font-awesome/fonts/fontawesome-webfont.woff2?v=4.7.0") format('woff2'),url("../bower_components/font-awesome/fonts/fontawesome-webfont.woff?v=4.7.0") format('woff'),url("../bower_components/font-awesome/fonts/fontawesome-webfont.ttf?v=4.7.0") format('truetype'),url("../bower_components/font-awesome/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular") format('svg');font-weight:normal;font-style:normal;}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%;}.fa-2x{font-size:2em;}.fa-3x{font-size:3em;}.fa-4x{font-size:4em;}.fa-5x{font-size:5em;}.fa-fw{width:1.28571429em;text-align:center;}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none;}.fa-ul>li{position:relative;}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center;}.fa-li.fa-lg{left:-1.85714286em;}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em;}.fa-pull-left{float:left;}.fa-pull-right{float:right;}.fa.fa-pull-left{margin-right:.3em;}.fa.fa-pull-right{margin-left:.3em;}.pull-right{float:right;}.pull-left{float:left;}.fa.pull-left{margin-right:.3em;}.fa.pull-right{margin-left:.3em;}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear;}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8);}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg);}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg);}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg);}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg);}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg);}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";-webkit-transform:scale(-1, 1);-ms-transform:scale(-1, 1);transform:scale(-1, 1);}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";-webkit-transform:scale(1, -1);-ms-transform:scale(1, -1);transform:scale(1, -1);}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none;}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle;}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center;}.fa-stack-1x{line-height:inherit;}.fa-stack-2x{font-size:2em;}.fa-inverse{color:#fff;}.fa-glass:before{content:"\f000";}.fa-music:before{content:"\f001";}.fa-search:before{content:"\f002";}.fa-envelope-o:before{content:"\f003";}.fa-heart:before{content:"\f004";}.fa-star:before{content:"\f005";}.fa-star-o:before{content:"\f006";}.fa-user:before{content:"\f007";}.fa-film:before{content:"\f008";}.fa-th-large:before{content:"\f009";}.fa-th:before{content:"\f00a";}.fa-th-list:before{content:"\f00b";}.fa-check:before{content:"\f00c";}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\f00d";}.fa-search-plus:before{content:"\f00e";}.fa-search-minus:before{content:"\f010";}.fa-power-off:before{content:"\f011";}.fa-signal:before{content:"\f012";}.fa-gear:before,.fa-cog:before{content:"\f013";}.fa-trash-o:before{content:"\f014";}.fa-home:before{content:"\f015";}.fa-file-o:before{content:"\f016";}.fa-clock-o:before{content:"\f017";}.fa-road:before{content:"\f018";}.fa-download:before{content:"\f019";}.fa-arrow-circle-o-down:before{content:"\f01a";}.fa-arrow-circle-o-up:before{content:"\f01b";}.fa-inbox:before{content:"\f01c";}.fa-play-circle-o:before{content:"\f01d";}.fa-rotate-right:before,.fa-repeat:before{content:"\f01e";}.fa-refresh:before{content:"\f021";}.fa-list-alt:before{content:"\f022";}.fa-lock:before{content:"\f023";}.fa-flag:before{content:"\f024";}.fa-headphones:before{content:"\f025";}.fa-volume-off:before{content:"\f026";}.fa-volume-down:before{content:"\f027";}.fa-volume-up:before{content:"\f028";}.fa-qrcode:before{content:"\f029";}.fa-barcode:before{content:"\f02a";}.fa-tag:before{content:"\f02b";}.fa-tags:before{content:"\f02c";}.fa-book:before{content:"\f02d";}.fa-bookmark:before{content:"\f02e";}.fa-print:before{content:"\f02f";}.fa-camera:before{content:"\f030";}.fa-font:before{content:"\f031";}.fa-bold:before{content:"\f032";}.fa-italic:before{content:"\f033";}.fa-text-height:before{content:"\f034";}.fa-text-width:before{content:"\f035";}.fa-align-left:before{content:"\f036";}.fa-align-center:before{content:"\f037";}.fa-align-right:before{content:"\f038";}.fa-align-justify:before{content:"\f039";}.fa-list:before{content:"\f03a";}.fa-dedent:before,.fa-outdent:before{content:"\f03b";}.fa-indent:before{content:"\f03c";}.fa-video-camera:before{content:"\f03d";}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\f03e";}.fa-pencil:before{content:"\f040";}.fa-map-marker:before{content:"\f041";}.fa-adjust:before{content:"\f042";}.fa-tint:before{content:"\f043";}.fa-edit:before,.fa-pencil-square-o:before{content:"\f044";}.fa-share-square-o:before{content:"\f045";}.fa-check-square-o:before{content:"\f046";}.fa-arrows:before{content:"\f047";}.fa-step-backward:before{content:"\f048";}.fa-fast-backward:before{content:"\f049";}.fa-backward:before{content:"\f04a";}.fa-play:before{content:"\f04b";}.fa-pause:before{content:"\f04c";}.fa-stop:before{content:"\f04d";}.fa-forward:before{content:"\f04e";}.fa-fast-forward:before{content:"\f050";}.fa-step-forward:before{content:"\f051";}.fa-eject:before{content:"\f052";}.fa-chevron-left:before{content:"\f053";}.fa-chevron-right:before{content:"\f054";}.fa-plus-circle:before{content:"\f055";}.fa-minus-circle:before{content:"\f056";}.fa-times-circle:before{content:"\f057";}.fa-check-circle:before{content:"\f058";}.fa-question-circle:before{content:"\f059";}.fa-info-circle:before{content:"\f05a";}.fa-crosshairs:before{content:"\f05b";}.fa-times-circle-o:before{content:"\f05c";}.fa-check-circle-o:before{content:"\f05d";}.fa-ban:before{content:"\f05e";}.fa-arrow-left:before{content:"\f060";}.fa-arrow-right:before{content:"\f061";}.fa-arrow-up:before{content:"\f062";}.fa-arrow-down:before{content:"\f063";}.fa-mail-forward:before,.fa-share:before{content:"\f064";}.fa-expand:before{content:"\f065";}.fa-compress:before{content:"\f066";}.fa-plus:before{content:"\f067";}.fa-minus:before{content:"\f068";}.fa-asterisk:before{content:"\f069";}.fa-exclamation-circle:before{content:"\f06a";}.fa-gift:before{content:"\f06b";}.fa-leaf:before{content:"\f06c";}.fa-fire:before{content:"\f06d";}.fa-eye:before{content:"\f06e";}.fa-eye-slash:before{content:"\f070";}.fa-warning:before,.fa-exclamation-triangle:before{content:"\f071";}.fa-plane:before{content:"\f072";}.fa-calendar:before{content:"\f073";}.fa-random:before{content:"\f074";}.fa-comment:before{content:"\f075";}.fa-magnet:before{content:"\f076";}.fa-chevron-up:before{content:"\f077";}.fa-chevron-down:before{content:"\f078";}.fa-retweet:before{content:"\f079";}.fa-shopping-cart:before{content:"\f07a";}.fa-folder:before{content:"\f07b";}.fa-folder-open:before{content:"\f07c";}.fa-arrows-v:before{content:"\f07d";}.fa-arrows-h:before{content:"\f07e";}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\f080";}.fa-twitter-square:before{content:"\f081";}.fa-facebook-square:before{content:"\f082";}.fa-camera-retro:before{content:"\f083";}.fa-key:before{content:"\f084";}.fa-gears:before,.fa-cogs:before{content:"\f085";}.fa-comments:before{content:"\f086";}.fa-thumbs-o-up:before{content:"\f087";}.fa-thumbs-o-down:before{content:"\f088";}.fa-star-half:before{content:"\f089";}.fa-heart-o:before{content:"\f08a";}.fa-sign-out:before{content:"\f08b";}.fa-linkedin-square:before{content:"\f08c";}.fa-thumb-tack:before{content:"\f08d";}.fa-external-link:before{content:"\f08e";}.fa-sign-in:before{content:"\f090";}.fa-trophy:before{content:"\f091";}.fa-github-square:before{content:"\f092";}.fa-upload:before{content:"\f093";}.fa-lemon-o:before{content:"\f094";}.fa-phone:before{content:"\f095";}.fa-square-o:before{content:"\f096";}.fa-bookmark-o:before{content:"\f097";}.fa-phone-square:before{content:"\f098";}.fa-twitter:before{content:"\f099";}.fa-facebook-f:before,.fa-facebook:before{content:"\f09a";}.fa-github:before{content:"\f09b";}.fa-unlock:before{content:"\f09c";}.fa-credit-card:before{content:"\f09d";}.fa-feed:before,.fa-rss:before{content:"\f09e";}.fa-hdd-o:before{content:"\f0a0";}.fa-bullhorn:before{content:"\f0a1";}.fa-bell:before{content:"\f0f3";}.fa-certificate:before{content:"\f0a3";}.fa-hand-o-right:before{content:"\f0a4";}.fa-hand-o-left:before{content:"\f0a5";}.fa-hand-o-up:before{content:"\f0a6";}.fa-hand-o-down:before{content:"\f0a7";}.fa-arrow-circle-left:before{content:"\f0a8";}.fa-arrow-circle-right:before{content:"\f0a9";}.fa-arrow-circle-up:before{content:"\f0aa";}.fa-arrow-circle-down:before{content:"\f0ab";}.fa-globe:before{content:"\f0ac";}.fa-wrench:before{content:"\f0ad";}.fa-tasks:before{content:"\f0ae";}.fa-filter:before{content:"\f0b0";}.fa-briefcase:before{content:"\f0b1";}.fa-arrows-alt:before{content:"\f0b2";}.fa-group:before,.fa-users:before{content:"\f0c0";}.fa-chain:before,.fa-link:before{content:"\f0c1";}.fa-cloud:before{content:"\f0c2";}.fa-flask:before{content:"\f0c3";}.fa-cut:before,.fa-scissors:before{content:"\f0c4";}.fa-copy:before,.fa-files-o:before{content:"\f0c5";}.fa-paperclip:before{content:"\f0c6";}.fa-save:before,.fa-floppy-o:before{content:"\f0c7";}.fa-square:before{content:"\f0c8";}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\f0c9";}.fa-list-ul:before{content:"\f0ca";}.fa-list-ol:before{content:"\f0cb";}.fa-strikethrough:before{content:"\f0cc";}.fa-underline:before{content:"\f0cd";}.fa-table:before{content:"\f0ce";}.fa-magic:before{content:"\f0d0";}.fa-truck:before{content:"\f0d1";}.fa-pinterest:before{content:"\f0d2";}.fa-pinterest-square:before{content:"\f0d3";}.fa-google-plus-square:before{content:"\f0d4";}.fa-google-plus:before{content:"\f0d5";}.fa-money:before{content:"\f0d6";}.fa-caret-down:before{content:"\f0d7";}.fa-caret-up:before{content:"\f0d8";}.fa-caret-left:before{content:"\f0d9";}.fa-caret-right:before{content:"\f0da";}.fa-columns:before{content:"\f0db";}.fa-unsorted:before,.fa-sort:before{content:"\f0dc";}.fa-sort-down:before,.fa-sort-desc:before{content:"\f0dd";}.fa-sort-up:before,.fa-sort-asc:before{content:"\f0de";}.fa-envelope:before{content:"\f0e0";}.fa-linkedin:before{content:"\f0e1";}.fa-rotate-left:before,.fa-undo:before{content:"\f0e2";}.fa-legal:before,.fa-gavel:before{content:"\f0e3";}.fa-dashboard:before,.fa-tachometer:before{content:"\f0e4";}.fa-comment-o:before{content:"\f0e5";}.fa-comments-o:before{content:"\f0e6";}.fa-flash:before,.fa-bolt:before{content:"\f0e7";}.fa-sitemap:before{content:"\f0e8";}.fa-umbrella:before{content:"\f0e9";}.fa-paste:before,.fa-clipboard:before{content:"\f0ea";}.fa-lightbulb-o:before{content:"\f0eb";}.fa-exchange:before{content:"\f0ec";}.fa-cloud-download:before{content:"\f0ed";}.fa-cloud-upload:before{content:"\f0ee";}.fa-user-md:before{content:"\f0f0";}.fa-stethoscope:before{content:"\f0f1";}.fa-suitcase:before{content:"\f0f2";}.fa-bell-o:before{content:"\f0a2";}.fa-coffee:before{content:"\f0f4";}.fa-cutlery:before{content:"\f0f5";}.fa-file-text-o:before{content:"\f0f6";}.fa-building-o:before{content:"\f0f7";}.fa-hospital-o:before{content:"\f0f8";}.fa-ambulance:before{content:"\f0f9";}.fa-medkit:before{content:"\f0fa";}.fa-fighter-jet:before{content:"\f0fb";}.fa-beer:before{content:"\f0fc";}.fa-h-square:before{content:"\f0fd";}.fa-plus-square:before{content:"\f0fe";}.fa-angle-double-left:before{content:"\f100";}.fa-angle-double-right:before{content:"\f101";}.fa-angle-double-up:before{content:"\f102";}.fa-angle-double-down:before{content:"\f103";}.fa-angle-left:before{content:"\f104";}.fa-angle-right:before{content:"\f105";}.fa-angle-up:before{content:"\f106";}.fa-angle-down:before{content:"\f107";}.fa-desktop:before{content:"\f108";}.fa-laptop:before{content:"\f109";}.fa-tablet:before{content:"\f10a";}.fa-mobile-phone:before,.fa-mobile:before{content:"\f10b";}.fa-circle-o:before{content:"\f10c";}.fa-quote-left:before{content:"\f10d";}.fa-quote-right:before{content:"\f10e";}.fa-spinner:before{content:"\f110";}.fa-circle:before{content:"\f111";}.fa-mail-reply:before,.fa-reply:before{content:"\f112";}.fa-github-alt:before{content:"\f113";}.fa-folder-o:before{content:"\f114";}.fa-folder-open-o:before{content:"\f115";}.fa-smile-o:before{content:"\f118";}.fa-frown-o:before{content:"\f119";}.fa-meh-o:before{content:"\f11a";}.fa-gamepad:before{content:"\f11b";}.fa-keyboard-o:before{content:"\f11c";}.fa-flag-o:before{content:"\f11d";}.fa-flag-checkered:before{content:"\f11e";}.fa-terminal:before{content:"\f120";}.fa-code:before{content:"\f121";}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\f122";}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\f123";}.fa-location-arrow:before{content:"\f124";}.fa-crop:before{content:"\f125";}.fa-code-fork:before{content:"\f126";}.fa-unlink:before,.fa-chain-broken:before{content:"\f127";}.fa-question:before{content:"\f128";}.fa-info:before{content:"\f129";}.fa-exclamation:before{content:"\f12a";}.fa-superscript:before{content:"\f12b";}.fa-subscript:before{content:"\f12c";}.fa-eraser:before{content:"\f12d";}.fa-puzzle-piece:before{content:"\f12e";}.fa-microphone:before{content:"\f130";}.fa-microphone-slash:before{content:"\f131";}.fa-shield:before{content:"\f132";}.fa-calendar-o:before{content:"\f133";}.fa-fire-extinguisher:before{content:"\f134";}.fa-rocket:before{content:"\f135";}.fa-maxcdn:before{content:"\f136";}.fa-chevron-circle-left:before{content:"\f137";}.fa-chevron-circle-right:before{content:"\f138";}.fa-chevron-circle-up:before{content:"\f139";}.fa-chevron-circle-down:before{content:"\f13a";}.fa-html5:before{content:"\f13b";}.fa-css3:before{content:"\f13c";}.fa-anchor:before{content:"\f13d";}.fa-unlock-alt:before{content:"\f13e";}.fa-bullseye:before{content:"\f140";}.fa-ellipsis-h:before{content:"\f141";}.fa-ellipsis-v:before{content:"\f142";}.fa-rss-square:before{content:"\f143";}.fa-play-circle:before{content:"\f144";}.fa-ticket:before{content:"\f145";}.fa-minus-square:before{content:"\f146";}.fa-minus-square-o:before{content:"\f147";}.fa-level-up:before{content:"\f148";}.fa-level-down:before{content:"\f149";}.fa-check-square:before{content:"\f14a";}.fa-pencil-square:before{content:"\f14b";}.fa-external-link-square:before{content:"\f14c";}.fa-share-square:before{content:"\f14d";}.fa-compass:before{content:"\f14e";}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\f150";}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\f151";}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\f152";}.fa-euro:before,.fa-eur:before{content:"\f153";}.fa-gbp:before{content:"\f154";}.fa-dollar:before,.fa-usd:before{content:"\f155";}.fa-rupee:before,.fa-inr:before{content:"\f156";}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\f157";}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\f158";}.fa-won:before,.fa-krw:before{content:"\f159";}.fa-bitcoin:before,.fa-btc:before{content:"\f15a";}.fa-file:before{content:"\f15b";}.fa-file-text:before{content:"\f15c";}.fa-sort-alpha-asc:before{content:"\f15d";}.fa-sort-alpha-desc:before{content:"\f15e";}.fa-sort-amount-asc:before{content:"\f160";}.fa-sort-amount-desc:before{content:"\f161";}.fa-sort-numeric-asc:before{content:"\f162";}.fa-sort-numeric-desc:before{content:"\f163";}.fa-thumbs-up:before{content:"\f164";}.fa-thumbs-down:before{content:"\f165";}.fa-youtube-square:before{content:"\f166";}.fa-youtube:before{content:"\f167";}.fa-xing:before{content:"\f168";}.fa-xing-square:before{content:"\f169";}.fa-youtube-play:before{content:"\f16a";}.fa-dropbox:before{content:"\f16b";}.fa-stack-overflow:before{content:"\f16c";}.fa-instagram:before{content:"\f16d";}.fa-flickr:before{content:"\f16e";}.fa-adn:before{content:"\f170";}.fa-bitbucket:before{content:"\f171";}.fa-bitbucket-square:before{content:"\f172";}.fa-tumblr:before{content:"\f173";}.fa-tumblr-square:before{content:"\f174";}.fa-long-arrow-down:before{content:"\f175";}.fa-long-arrow-up:before{content:"\f176";}.fa-long-arrow-left:before{content:"\f177";}.fa-long-arrow-right:before{content:"\f178";}.fa-apple:before{content:"\f179";}.fa-windows:before{content:"\f17a";}.fa-android:before{content:"\f17b";}.fa-linux:before{content:"\f17c";}.fa-dribbble:before{content:"\f17d";}.fa-skype:before{content:"\f17e";}.fa-foursquare:before{content:"\f180";}.fa-trello:before{content:"\f181";}.fa-female:before{content:"\f182";}.fa-male:before{content:"\f183";}.fa-gittip:before,.fa-gratipay:before{content:"\f184";}.fa-sun-o:before{content:"\f185";}.fa-moon-o:before{content:"\f186";}.fa-archive:before{content:"\f187";}.fa-bug:before{content:"\f188";}.fa-vk:before{content:"\f189";}.fa-weibo:before{content:"\f18a";}.fa-renren:before{content:"\f18b";}.fa-pagelines:before{content:"\f18c";}.fa-stack-exchange:before{content:"\f18d";}.fa-arrow-circle-o-right:before{content:"\f18e";}.fa-arrow-circle-o-left:before{content:"\f190";}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\f191";}.fa-dot-circle-o:before{content:"\f192";}.fa-wheelchair:before{content:"\f193";}.fa-vimeo-square:before{content:"\f194";}.fa-turkish-lira:before,.fa-try:before{content:"\f195";}.fa-plus-square-o:before{content:"\f196";}.fa-space-shuttle:before{content:"\f197";}.fa-slack:before{content:"\f198";}.fa-envelope-square:before{content:"\f199";}.fa-wordpress:before{content:"\f19a";}.fa-openid:before{content:"\f19b";}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\f19c";}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\f19d";}.fa-yahoo:before{content:"\f19e";}.fa-google:before{content:"\f1a0";}.fa-reddit:before{content:"\f1a1";}.fa-reddit-square:before{content:"\f1a2";}.fa-stumbleupon-circle:before{content:"\f1a3";}.fa-stumbleupon:before{content:"\f1a4";}.fa-delicious:before{content:"\f1a5";}.fa-digg:before{content:"\f1a6";}.fa-pied-piper-pp:before{content:"\f1a7";}.fa-pied-piper-alt:before{content:"\f1a8";}.fa-drupal:before{content:"\f1a9";}.fa-joomla:before{content:"\f1aa";}.fa-language:before{content:"\f1ab";}.fa-fax:before{content:"\f1ac";}.fa-building:before{content:"\f1ad";}.fa-child:before{content:"\f1ae";}.fa-paw:before{content:"\f1b0";}.fa-spoon:before{content:"\f1b1";}.fa-cube:before{content:"\f1b2";}.fa-cubes:before{content:"\f1b3";}.fa-behance:before{content:"\f1b4";}.fa-behance-square:before{content:"\f1b5";}.fa-steam:before{content:"\f1b6";}.fa-steam-square:before{content:"\f1b7";}.fa-recycle:before{content:"\f1b8";}.fa-automobile:before,.fa-car:before{content:"\f1b9";}.fa-cab:before,.fa-taxi:before{content:"\f1ba";}.fa-tree:before{content:"\f1bb";}.fa-spotify:before{content:"\f1bc";}.fa-deviantart:before{content:"\f1bd";}.fa-soundcloud:before{content:"\f1be";}.fa-database:before{content:"\f1c0";}.fa-file-pdf-o:before{content:"\f1c1";}.fa-file-word-o:before{content:"\f1c2";}.fa-file-excel-o:before{content:"\f1c3";}.fa-file-powerpoint-o:before{content:"\f1c4";}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\f1c5";}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\f1c6";}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\f1c7";}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\f1c8";}.fa-file-code-o:before{content:"\f1c9";}.fa-vine:before{content:"\f1ca";}.fa-codepen:before{content:"\f1cb";}.fa-jsfiddle:before{content:"\f1cc";}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\f1cd";}.fa-circle-o-notch:before{content:"\f1ce";}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"\f1d0";}.fa-ge:before,.fa-empire:before{content:"\f1d1";}.fa-git-square:before{content:"\f1d2";}.fa-git:before{content:"\f1d3";}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"\f1d4";}.fa-tencent-weibo:before{content:"\f1d5";}.fa-qq:before{content:"\f1d6";}.fa-wechat:before,.fa-weixin:before{content:"\f1d7";}.fa-send:before,.fa-paper-plane:before{content:"\f1d8";}.fa-send-o:before,.fa-paper-plane-o:before{content:"\f1d9";}.fa-history:before{content:"\f1da";}.fa-circle-thin:before{content:"\f1db";}.fa-header:before{content:"\f1dc";}.fa-paragraph:before{content:"\f1dd";}.fa-sliders:before{content:"\f1de";}.fa-share-alt:before{content:"\f1e0";}.fa-share-alt-square:before{content:"\f1e1";}.fa-bomb:before{content:"\f1e2";}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\f1e3";}.fa-tty:before{content:"\f1e4";}.fa-binoculars:before{content:"\f1e5";}.fa-plug:before{content:"\f1e6";}.fa-slideshare:before{content:"\f1e7";}.fa-twitch:before{content:"\f1e8";}.fa-yelp:before{content:"\f1e9";}.fa-newspaper-o:before{content:"\f1ea";}.fa-wifi:before{content:"\f1eb";}.fa-calculator:before{content:"\f1ec";}.fa-paypal:before{content:"\f1ed";}.fa-google-wallet:before{content:"\f1ee";}.fa-cc-visa:before{content:"\f1f0";}.fa-cc-mastercard:before{content:"\f1f1";}.fa-cc-discover:before{content:"\f1f2";}.fa-cc-amex:before{content:"\f1f3";}.fa-cc-paypal:before{content:"\f1f4";}.fa-cc-stripe:before{content:"\f1f5";}.fa-bell-slash:before{content:"\f1f6";}.fa-bell-slash-o:before{content:"\f1f7";}.fa-trash:before{content:"\f1f8";}.fa-copyright:before{content:"\f1f9";}.fa-at:before{content:"\f1fa";}.fa-eyedropper:before{content:"\f1fb";}.fa-paint-brush:before{content:"\f1fc";}.fa-birthday-cake:before{content:"\f1fd";}.fa-area-chart:before{content:"\f1fe";}.fa-pie-chart:before{content:"\f200";}.fa-line-chart:before{content:"\f201";}.fa-lastfm:before{content:"\f202";}.fa-lastfm-square:before{content:"\f203";}.fa-toggle-off:before{content:"\f204";}.fa-toggle-on:before{content:"\f205";}.fa-bicycle:before{content:"\f206";}.fa-bus:before{content:"\f207";}.fa-ioxhost:before{content:"\f208";}.fa-angellist:before{content:"\f209";}.fa-cc:before{content:"\f20a";}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\f20b";}.fa-meanpath:before{content:"\f20c";}.fa-buysellads:before{content:"\f20d";}.fa-connectdevelop:before{content:"\f20e";}.fa-dashcube:before{content:"\f210";}.fa-forumbee:before{content:"\f211";}.fa-leanpub:before{content:"\f212";}.fa-sellsy:before{content:"\f213";}.fa-shirtsinbulk:before{content:"\f214";}.fa-simplybuilt:before{content:"\f215";}.fa-skyatlas:before{content:"\f216";}.fa-cart-plus:before{content:"\f217";}.fa-cart-arrow-down:before{content:"\f218";}.fa-diamond:before{content:"\f219";}.fa-ship:before{content:"\f21a";}.fa-user-secret:before{content:"\f21b";}.fa-motorcycle:before{content:"\f21c";}.fa-street-view:before{content:"\f21d";}.fa-heartbeat:before{content:"\f21e";}.fa-venus:before{content:"\f221";}.fa-mars:before{content:"\f222";}.fa-mercury:before{content:"\f223";}.fa-intersex:before,.fa-transgender:before{content:"\f224";}.fa-transgender-alt:before{content:"\f225";}.fa-venus-double:before{content:"\f226";}.fa-mars-double:before{content:"\f227";}.fa-venus-mars:before{content:"\f228";}.fa-mars-stroke:before{content:"\f229";}.fa-mars-stroke-v:before{content:"\f22a";}.fa-mars-stroke-h:before{content:"\f22b";}.fa-neuter:before{content:"\f22c";}.fa-genderless:before{content:"\f22d";}.fa-facebook-official:before{content:"\f230";}.fa-pinterest-p:before{content:"\f231";}.fa-whatsapp:before{content:"\f232";}.fa-server:before{content:"\f233";}.fa-user-plus:before{content:"\f234";}.fa-user-times:before{content:"\f235";}.fa-hotel:before,.fa-bed:before{content:"\f236";}.fa-viacoin:before{content:"\f237";}.fa-train:before{content:"\f238";}.fa-subway:before{content:"\f239";}.fa-medium:before{content:"\f23a";}.fa-yc:before,.fa-y-combinator:before{content:"\f23b";}.fa-optin-monster:before{content:"\f23c";}.fa-opencart:before{content:"\f23d";}.fa-expeditedssl:before{content:"\f23e";}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"\f240";}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"\f241";}.fa-battery-2:before,.fa-battery-half:before{content:"\f242";}.fa-battery-1:before,.fa-battery-quarter:before{content:"\f243";}.fa-battery-0:before,.fa-battery-empty:before{content:"\f244";}.fa-mouse-pointer:before{content:"\f245";}.fa-i-cursor:before{content:"\f246";}.fa-object-group:before{content:"\f247";}.fa-object-ungroup:before{content:"\f248";}.fa-sticky-note:before{content:"\f249";}.fa-sticky-note-o:before{content:"\f24a";}.fa-cc-jcb:before{content:"\f24b";}.fa-cc-diners-club:before{content:"\f24c";}.fa-clone:before{content:"\f24d";}.fa-balance-scale:before{content:"\f24e";}.fa-hourglass-o:before{content:"\f250";}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"\f251";}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"\f252";}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"\f253";}.fa-hourglass:before{content:"\f254";}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"\f255";}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"\f256";}.fa-hand-scissors-o:before{content:"\f257";}.fa-hand-lizard-o:before{content:"\f258";}.fa-hand-spock-o:before{content:"\f259";}.fa-hand-pointer-o:before{content:"\f25a";}.fa-hand-peace-o:before{content:"\f25b";}.fa-trademark:before{content:"\f25c";}.fa-registered:before{content:"\f25d";}.fa-creative-commons:before{content:"\f25e";}.fa-gg:before{content:"\f260";}.fa-gg-circle:before{content:"\f261";}.fa-tripadvisor:before{content:"\f262";}.fa-odnoklassniki:before{content:"\f263";}.fa-odnoklassniki-square:before{content:"\f264";}.fa-get-pocket:before{content:"\f265";}.fa-wikipedia-w:before{content:"\f266";}.fa-safari:before{content:"\f267";}.fa-chrome:before{content:"\f268";}.fa-firefox:before{content:"\f269";}.fa-opera:before{content:"\f26a";}.fa-internet-explorer:before{content:"\f26b";}.fa-tv:before,.fa-television:before{content:"\f26c";}.fa-contao:before{content:"\f26d";}.fa-500px:before{content:"\f26e";}.fa-amazon:before{content:"\f270";}.fa-calendar-plus-o:before{content:"\f271";}.fa-calendar-minus-o:before{content:"\f272";}.fa-calendar-times-o:before{content:"\f273";}.fa-calendar-check-o:before{content:"\f274";}.fa-industry:before{content:"\f275";}.fa-map-pin:before{content:"\f276";}.fa-map-signs:before{content:"\f277";}.fa-map-o:before{content:"\f278";}.fa-map:before{content:"\f279";}.fa-commenting:before{content:"\f27a";}.fa-commenting-o:before{content:"\f27b";}.fa-houzz:before{content:"\f27c";}.fa-vimeo:before{content:"\f27d";}.fa-black-tie:before{content:"\f27e";}.fa-fonticons:before{content:"\f280";}.fa-reddit-alien:before{content:"\f281";}.fa-edge:before{content:"\f282";}.fa-credit-card-alt:before{content:"\f283";}.fa-codiepie:before{content:"\f284";}.fa-modx:before{content:"\f285";}.fa-fort-awesome:before{content:"\f286";}.fa-usb:before{content:"\f287";}.fa-product-hunt:before{content:"\f288";}.fa-mixcloud:before{content:"\f289";}.fa-scribd:before{content:"\f28a";}.fa-pause-circle:before{content:"\f28b";}.fa-pause-circle-o:before{content:"\f28c";}.fa-stop-circle:before{content:"\f28d";}.fa-stop-circle-o:before{content:"\f28e";}.fa-shopping-bag:before{content:"\f290";}.fa-shopping-basket:before{content:"\f291";}.fa-hashtag:before{content:"\f292";}.fa-bluetooth:before{content:"\f293";}.fa-bluetooth-b:before{content:"\f294";}.fa-percent:before{content:"\f295";}.fa-gitlab:before{content:"\f296";}.fa-wpbeginner:before{content:"\f297";}.fa-wpforms:before{content:"\f298";}.fa-envira:before{content:"\f299";}.fa-universal-access:before{content:"\f29a";}.fa-wheelchair-alt:before{content:"\f29b";}.fa-question-circle-o:before{content:"\f29c";}.fa-blind:before{content:"\f29d";}.fa-audio-description:before{content:"\f29e";}.fa-volume-control-phone:before{content:"\f2a0";}.fa-braille:before{content:"\f2a1";}.fa-assistive-listening-systems:before{content:"\f2a2";}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"\f2a3";}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"\f2a4";}.fa-glide:before{content:"\f2a5";}.fa-glide-g:before{content:"\f2a6";}.fa-signing:before,.fa-sign-language:before{content:"\f2a7";}.fa-low-vision:before{content:"\f2a8";}.fa-viadeo:before{content:"\f2a9";}.fa-viadeo-square:before{content:"\f2aa";}.fa-snapchat:before{content:"\f2ab";}.fa-snapchat-ghost:before{content:"\f2ac";}.fa-snapchat-square:before{content:"\f2ad";}.fa-pied-piper:before{content:"\f2ae";}.fa-first-order:before{content:"\f2b0";}.fa-yoast:before{content:"\f2b1";}.fa-themeisle:before{content:"\f2b2";}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"\f2b3";}.fa-fa:before,.fa-font-awesome:before{content:"\f2b4";}.fa-handshake-o:before{content:"\f2b5";}.fa-envelope-open:before{content:"\f2b6";}.fa-envelope-open-o:before{content:"\f2b7";}.fa-linode:before{content:"\f2b8";}.fa-address-book:before{content:"\f2b9";}.fa-address-book-o:before{content:"\f2ba";}.fa-vcard:before,.fa-address-card:before{content:"\f2bb";}.fa-vcard-o:before,.fa-address-card-o:before{content:"\f2bc";}.fa-user-circle:before{content:"\f2bd";}.fa-user-circle-o:before{content:"\f2be";}.fa-user-o:before{content:"\f2c0";}.fa-id-badge:before{content:"\f2c1";}.fa-drivers-license:before,.fa-id-card:before{content:"\f2c2";}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"\f2c3";}.fa-quora:before{content:"\f2c4";}.fa-free-code-camp:before{content:"\f2c5";}.fa-telegram:before{content:"\f2c6";}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"\f2c7";}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"\f2c8";}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"\f2c9";}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"\f2ca";}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"\f2cb";}.fa-shower:before{content:"\f2cc";}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"\f2cd";}.fa-podcast:before{content:"\f2ce";}.fa-window-maximize:before{content:"\f2d0";}.fa-window-minimize:before{content:"\f2d1";}.fa-window-restore:before{content:"\f2d2";}.fa-times-rectangle:before,.fa-window-close:before{content:"\f2d3";}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"\f2d4";}.fa-bandcamp:before{content:"\f2d5";}.fa-grav:before{content:"\f2d6";}.fa-etsy:before{content:"\f2d7";}.fa-imdb:before{content:"\f2d8";}.fa-ravelry:before{content:"\f2d9";}.fa-eercast:before{content:"\f2da";}.fa-microchip:before{content:"\f2db";}.fa-snowflake-o:before{content:"\f2dc";}.fa-superpowers:before{content:"\f2dd";}.fa-wpexplorer:before{content:"\f2de";}.fa-meetup:before{content:"\f2e0";}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0;}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto;}</style><dom-module id="iron-localstorage" assetpath="../bower_components/iron-localstorage/"></dom-module><script>

Polymer({
  is: 'iron-localstorage',

  properties: {
    /**
     * localStorage item key
     */
    name: {
      type: String,
      value: ''
    },
    /**
     * The data associated with this storage.
     * If set to null item will be deleted.
     * @type {*}
     */
    value: {
      type: Object,
      notify: true
    },

    /**
     * If true: do not convert value to JSON on save/load
     */
    useRaw: {
      type: Boolean,
      value: false
    },

    /**
     * Value will not be saved automatically if true. You'll have to do it manually with `save()`
     */
    autoSaveDisabled: {
      type: Boolean,
      value: false
    },
    /**
     * Last error encountered while saving/loading items
     */
    errorMessage: {
      type: String,
      notify: true
    },

    /** True if value has been loaded */
    _loaded: {
      type: Boolean,
      value: false
    }
  },

  observers: ['_debounceReload(name,useRaw)', '_trySaveValue(autoSaveDisabled)', '_trySaveValue(value.*)'],

  ready: function ready() {
    this._boundHandleStorage = this._handleStorage.bind(this);
  },

  attached: function attached() {
    window.addEventListener('storage', this._boundHandleStorage);
  },

  detached: function detached() {
    window.removeEventListener('storage', this._boundHandleStorage);
  },

  _handleStorage: function _handleStorage(ev) {
    if (ev.key == this.name) {
      this._load(true);
    }
  },

  _trySaveValue: function _trySaveValue() {
    if (this._doNotSave) {
      return;
    }
    if (this._loaded && !this.autoSaveDisabled) {
      this.debounce('save', this.save);
    }
  },

  _debounceReload: function _debounceReload() {
    this.debounce('reload', this.reload);
  },

  /**
   * Loads the value again. Use if you modify
   * localStorage using DOM calls, and want to
   * keep this element in sync.
   */
  reload: function reload() {
    this._loaded = false;
    this._load();
  },

  /**
   * loads value from local storage
   * @param {boolean=} externalChange true if loading changes from a different window
   */
  _load: function _load(externalChange) {
    try {
      var v = window.localStorage.getItem(this.name);
    } catch (ex) {
      this.errorMessage = ex.message;

      this._error("Could not save to localStorage.  Try enabling cookies for this page.", ex);
    };

    if (v === null) {
      this._loaded = true;
      this._doNotSave = true; // guard for save watchers
      this.value = null;
      this._doNotSave = false;
      this.fire('iron-localstorage-load-empty', { externalChange: externalChange });
    } else {
      if (!this.useRaw) {
        try {
          // parse value as JSON
          v = JSON.parse(v);
        } catch (x) {
          this.errorMessage = "Could not parse local storage value";
          Polymer.Base._error("could not parse local storage value", v);
          v = null;
        }
      }
      this._loaded = true;
      this._doNotSave = true;
      this.value = v;
      this._doNotSave = false;
      this.fire('iron-localstorage-load', { externalChange: externalChange });
    }
  },

  /**
   * Saves the value to localStorage. Call to save if autoSaveDisabled is set.
   * If `value` is null or undefined, deletes localStorage.
   */
  save: function save() {
    var v = this.useRaw ? this.value : JSON.stringify(this.value);
    try {
      if (this.value === null || this.value === undefined) {
        window.localStorage.removeItem(this.name);
      } else {
        window.localStorage.setItem(this.name, /** @type {string} */v);
      }
    } catch (ex) {
      // Happens in Safari incognito mode,
      this.errorMessage = ex.message;
      Polymer.Base._error("Could not save to localStorage. Incognito mode may be blocking this action", ex);
    }
  }

  /**
   * Fired when value loads from localStorage.
   *
   * @event iron-localstorage-load
   * @param {{externalChange:boolean}} detail -
   *     externalChange: true if change occured in different window.
   */

  /**
   * Fired when loaded value does not exist.
   * Event handler can be used to initialize default value.
   *
   * @event iron-localstorage-load-empty
   * @param {{externalChange:boolean}} detail -
   *     externalChange: true if change occured in different window.
   */
});</script><script>
/**
`Polymer.IronFitBehavior` fits an element in another element using `max-height` and `max-width`, and
optionally centers it in the window or another element.

The element will only be sized and/or positioned if it has not already been sized and/or positioned
by CSS.

CSS properties               | Action
-----------------------------|-------------------------------------------
`position` set               | Element is not centered horizontally or vertically
`top` or `bottom` set        | Element is not vertically centered
`left` or `right` set        | Element is not horizontally centered
`max-height` set             | Element respects `max-height`
`max-width` set              | Element respects `max-width`

`Polymer.IronFitBehavior` can position an element into another element using
`verticalAlign` and `horizontalAlign`. This will override the element's css position.

      <div class="container">
        <iron-fit-impl vertical-align="top" horizontal-align="auto">
          Positioned into the container
        </iron-fit-impl>
      </div>

Use `noOverlap` to position the element around another element without overlapping it.

      <div class="container">
        <iron-fit-impl no-overlap vertical-align="auto" horizontal-align="auto">
          Positioned around the container
        </iron-fit-impl>
      </div>

Use `horizontalOffset, verticalOffset` to offset the element from its `positionTarget`;
`Polymer.IronFitBehavior` will collapse these in order to keep the element
within `fitInto` boundaries, while preserving the element's CSS margin values.

      <div class="container">
        <iron-fit-impl vertical-align="top" vertical-offset="20">
          With vertical offset
        </iron-fit-impl>
      </div>


@demo demo/index.html
@polymerBehavior
*/

Polymer.IronFitBehavior = {

  properties: {

    /**
     * The element that will receive a `max-height`/`width`. By default it is the same as `this`,
     * but it can be set to a child element. This is useful, for example, for implementing a
     * scrolling region inside the element.
     * @type {!Element}
     */
    sizingTarget: {
      type: Object,
      value: function value() {
        return this;
      }
    },

    /**
     * The element to fit `this` into.
     */
    fitInto: {
      type: Object,
      value: window
    },

    /**
     * Will position the element around the positionTarget without overlapping it.
     */
    noOverlap: {
      type: Boolean
    },

    /**
     * The element that should be used to position the element. If not set, it will
     * default to the parent node.
     * @type {!Element}
     */
    positionTarget: {
      type: Element
    },

    /**
     * The orientation against which to align the element horizontally
     * relative to the `positionTarget`. Possible values are "left", "right", "auto".
     */
    horizontalAlign: {
      type: String
    },

    /**
     * The orientation against which to align the element vertically
     * relative to the `positionTarget`. Possible values are "top", "bottom", "auto".
     */
    verticalAlign: {
      type: String
    },

    /**
     * If true, it will use `horizontalAlign` and `verticalAlign` values as preferred alignment
     * and if there's not enough space, it will pick the values which minimize the cropping.
     */
    dynamicAlign: {
      type: Boolean
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `horizontalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `horizontalAlign`.
     *
     * If `horizontalAlign` is "left", this offset will increase or decrease
     * the distance to the left side of the screen: a negative offset will
     * move the dropdown to the left; a positive one, to the right.
     *
     * Conversely if `horizontalAlign` is "right", this offset will increase
     * or decrease the distance to the right side of the screen: a negative
     * offset will move the dropdown to the right; a positive one, to the left.
     */
    horizontalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `verticalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `verticalAlign`.
     *
     * If `verticalAlign` is "top", this offset will increase or decrease
     * the distance to the top side of the screen: a negative offset will
     * move the dropdown upwards; a positive one, downwards.
     *
     * Conversely if `verticalAlign` is "bottom", this offset will increase
     * or decrease the distance to the bottom side of the screen: a negative
     * offset will move the dropdown downwards; a positive one, upwards.
     */
    verticalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * Set to true to auto-fit on attach.
     */
    autoFitOnAttach: {
      type: Boolean,
      value: false
    },

    /** @type {?Object} */
    _fitInfo: {
      type: Object
    }
  },

  get _fitWidth() {
    var fitWidth;
    if (this.fitInto === window) {
      fitWidth = this.fitInto.innerWidth;
    } else {
      fitWidth = this.fitInto.getBoundingClientRect().width;
    }
    return fitWidth;
  },

  get _fitHeight() {
    var fitHeight;
    if (this.fitInto === window) {
      fitHeight = this.fitInto.innerHeight;
    } else {
      fitHeight = this.fitInto.getBoundingClientRect().height;
    }
    return fitHeight;
  },

  get _fitLeft() {
    var fitLeft;
    if (this.fitInto === window) {
      fitLeft = 0;
    } else {
      fitLeft = this.fitInto.getBoundingClientRect().left;
    }
    return fitLeft;
  },

  get _fitTop() {
    var fitTop;
    if (this.fitInto === window) {
      fitTop = 0;
    } else {
      fitTop = this.fitInto.getBoundingClientRect().top;
    }
    return fitTop;
  },

  /**
   * The element that should be used to position the element,
   * if no position target is configured.
   */
  get _defaultPositionTarget() {
    var parent = Polymer.dom(this).parentNode;

    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      parent = parent.host;
    }

    return parent;
  },

  /**
   * The horizontal align value, accounting for the RTL/LTR text direction.
   */
  get _localeHorizontalAlign() {
    if (this._isRTL) {
      // In RTL, "left" becomes "right".
      if (this.horizontalAlign === 'right') {
        return 'left';
      }
      if (this.horizontalAlign === 'left') {
        return 'right';
      }
    }
    return this.horizontalAlign;
  },

  attached: function attached() {
    // Memoize this to avoid expensive calculations & relayouts.
    // Make sure we do it only once
    if (typeof this._isRTL === 'undefined') {
      this._isRTL = window.getComputedStyle(this).direction == 'rtl';
    }

    this.positionTarget = this.positionTarget || this._defaultPositionTarget;
    if (this.autoFitOnAttach) {
      if (window.getComputedStyle(this).display === 'none') {
        setTimeout(function () {
          this.fit();
        }.bind(this));
      } else {
        this.fit();
      }
    }
  },

  /**
   * Positions and fits the element into the `fitInto` element.
   */
  fit: function fit() {
    this.position();
    this.constrain();
    this.center();
  },

  /**
   * Memoize information needed to position and size the target element.
   * @suppress {deprecated}
   */
  _discoverInfo: function _discoverInfo() {
    if (this._fitInfo) {
      return;
    }
    var target = window.getComputedStyle(this);
    var sizer = window.getComputedStyle(this.sizingTarget);

    this._fitInfo = {
      inlineStyle: {
        top: this.style.top || '',
        left: this.style.left || '',
        position: this.style.position || ''
      },
      sizerInlineStyle: {
        maxWidth: this.sizingTarget.style.maxWidth || '',
        maxHeight: this.sizingTarget.style.maxHeight || '',
        boxSizing: this.sizingTarget.style.boxSizing || ''
      },
      positionedBy: {
        vertically: target.top !== 'auto' ? 'top' : target.bottom !== 'auto' ? 'bottom' : null,
        horizontally: target.left !== 'auto' ? 'left' : target.right !== 'auto' ? 'right' : null
      },
      sizedBy: {
        height: sizer.maxHeight !== 'none',
        width: sizer.maxWidth !== 'none',
        minWidth: parseInt(sizer.minWidth, 10) || 0,
        minHeight: parseInt(sizer.minHeight, 10) || 0
      },
      margin: {
        top: parseInt(target.marginTop, 10) || 0,
        right: parseInt(target.marginRight, 10) || 0,
        bottom: parseInt(target.marginBottom, 10) || 0,
        left: parseInt(target.marginLeft, 10) || 0
      }
    };
  },

  /**
   * Resets the target element's position and size constraints, and clear
   * the memoized data.
   */
  resetFit: function resetFit() {
    var info = this._fitInfo || {};
    for (var property in info.sizerInlineStyle) {
      this.sizingTarget.style[property] = info.sizerInlineStyle[property];
    }
    for (var property in info.inlineStyle) {
      this.style[property] = info.inlineStyle[property];
    }

    this._fitInfo = null;
  },

  /**
   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after
   * the element or the `fitInto` element has been resized, or if any of the
   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.
   * It preserves the scroll position of the sizingTarget.
   */
  refit: function refit() {
    var scrollLeft = this.sizingTarget.scrollLeft;
    var scrollTop = this.sizingTarget.scrollTop;
    this.resetFit();
    this.fit();
    this.sizingTarget.scrollLeft = scrollLeft;
    this.sizingTarget.scrollTop = scrollTop;
  },

  /**
   * Positions the element according to `horizontalAlign, verticalAlign`.
   */
  position: function position() {
    if (!this.horizontalAlign && !this.verticalAlign) {
      // needs to be centered, and it is done after constrain.
      return;
    }
    this._discoverInfo();

    this.style.position = 'fixed';
    // Need border-box for margin/padding.
    this.sizingTarget.style.boxSizing = 'border-box';
    // Set to 0, 0 in order to discover any offset caused by parent stacking contexts.
    this.style.left = '0px';
    this.style.top = '0px';

    var rect = this.getBoundingClientRect();
    var positionRect = this.__getNormalizedRect(this.positionTarget);
    var fitRect = this.__getNormalizedRect(this.fitInto);

    var margin = this._fitInfo.margin;

    // Consider the margin as part of the size for position calculations.
    var size = {
      width: rect.width + margin.left + margin.right,
      height: rect.height + margin.top + margin.bottom
    };

    var position = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, size, positionRect, fitRect);

    var left = position.left + margin.left;
    var top = position.top + margin.top;

    // We first limit right/bottom within fitInto respecting the margin,
    // then use those values to limit top/left.
    var right = Math.min(fitRect.right - margin.right, left + rect.width);
    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);

    // Keep left/top within fitInto respecting the margin.
    left = Math.max(fitRect.left + margin.left, Math.min(left, right - this._fitInfo.sizedBy.minWidth));
    top = Math.max(fitRect.top + margin.top, Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));

    // Use right/bottom to set maxWidth/maxHeight, and respect minWidth/minHeight.
    this.sizingTarget.style.maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';
    this.sizingTarget.style.maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';

    // Remove the offset caused by any stacking context.
    this.style.left = left - rect.left + 'px';
    this.style.top = top - rect.top + 'px';
  },

  /**
   * Constrains the size of the element to `fitInto` by setting `max-height`
   * and/or `max-width`.
   */
  constrain: function constrain() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var info = this._fitInfo;
    // position at (0px, 0px) if not already positioned, so we can measure the natural size.
    if (!info.positionedBy.vertically) {
      this.style.position = 'fixed';
      this.style.top = '0px';
    }
    if (!info.positionedBy.horizontally) {
      this.style.position = 'fixed';
      this.style.left = '0px';
    }

    // need border-box for margin/padding
    this.sizingTarget.style.boxSizing = 'border-box';
    // constrain the width and height if not already set
    var rect = this.getBoundingClientRect();
    if (!info.sizedBy.height) {
      this.__sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
    }
    if (!info.sizedBy.width) {
      this.__sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
    }
  },

  /**
   * @protected
   * @deprecated
   */
  _sizeDimension: function _sizeDimension(rect, positionedBy, start, end, extent) {
    this.__sizeDimension(rect, positionedBy, start, end, extent);
  },

  /**
   * @private
   */
  __sizeDimension: function __sizeDimension(rect, positionedBy, start, end, extent) {
    var info = this._fitInfo;
    var fitRect = this.__getNormalizedRect(this.fitInto);
    var max = extent === 'Width' ? fitRect.width : fitRect.height;
    var flip = positionedBy === end;
    var offset = flip ? max - rect[end] : rect[start];
    var margin = info.margin[flip ? start : end];
    var offsetExtent = 'offset' + extent;
    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
    this.sizingTarget.style['max' + extent] = max - margin - offset - sizingOffset + 'px';
  },

  /**
   * Centers horizontally and vertically if not already positioned. This also sets
   * `position:fixed`.
   */
  center: function center() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var positionedBy = this._fitInfo.positionedBy;
    if (positionedBy.vertically && positionedBy.horizontally) {
      // Already positioned.
      return;
    }
    // Need position:fixed to center
    this.style.position = 'fixed';
    // Take into account the offset caused by parents that create stacking
    // contexts (e.g. with transform: translate3d). Translate to 0,0 and
    // measure the bounding rect.
    if (!positionedBy.vertically) {
      this.style.top = '0px';
    }
    if (!positionedBy.horizontally) {
      this.style.left = '0px';
    }
    // It will take in consideration margins and transforms
    var rect = this.getBoundingClientRect();
    var fitRect = this.__getNormalizedRect(this.fitInto);
    if (!positionedBy.vertically) {
      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
      this.style.top = top + 'px';
    }
    if (!positionedBy.horizontally) {
      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
      this.style.left = left + 'px';
    }
  },

  __getNormalizedRect: function __getNormalizedRect(target) {
    if (target === document.documentElement || target === window) {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    }
    return target.getBoundingClientRect();
  },

  __getCroppedArea: function __getCroppedArea(position, size, fitRect) {
    var verticalCrop = Math.min(0, position.top) + Math.min(0, fitRect.bottom - (position.top + size.height));
    var horizontalCrop = Math.min(0, position.left) + Math.min(0, fitRect.right - (position.left + size.width));
    return Math.abs(verticalCrop) * size.width + Math.abs(horizontalCrop) * size.height;
  },

  __getPosition: function __getPosition(hAlign, vAlign, size, positionRect, fitRect) {
    // All the possible configurations.
    // Ordered as top-left, top-right, bottom-left, bottom-right.
    var positions = [{
      verticalAlign: 'top',
      horizontalAlign: 'left',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'top',
      horizontalAlign: 'right',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'left',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'right',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }];

    if (this.noOverlap) {
      // Duplicate.
      for (var i = 0, l = positions.length; i < l; i++) {
        var copy = {};
        for (var key in positions[i]) {
          copy[key] = positions[i][key];
        }
        positions.push(copy);
      }
      // Horizontal overlap only.
      positions[0].top = positions[1].top += positionRect.height;
      positions[2].top = positions[3].top -= positionRect.height;
      // Vertical overlap only.
      positions[4].left = positions[6].left += positionRect.width;
      positions[5].left = positions[7].left -= positionRect.width;
    }

    // Consider auto as null for coding convenience.
    vAlign = vAlign === 'auto' ? null : vAlign;
    hAlign = hAlign === 'auto' ? null : hAlign;

    var position;
    for (var i = 0; i < positions.length; i++) {
      var pos = positions[i];

      // If both vAlign and hAlign are defined, return exact match.
      // For dynamicAlign and noOverlap we'll have more than one candidate, so
      // we'll have to check the croppedArea to make the best choice.
      if (!this.dynamicAlign && !this.noOverlap && pos.verticalAlign === vAlign && pos.horizontalAlign === hAlign) {
        position = pos;
        break;
      }

      // Align is ok if alignment preferences are respected. If no preferences,
      // it is considered ok.
      var alignOk = (!vAlign || pos.verticalAlign === vAlign) && (!hAlign || pos.horizontalAlign === hAlign);

      // Filter out elements that don't match the alignment (if defined).
      // With dynamicAlign, we need to consider all the positions to find the
      // one that minimizes the cropped area.
      if (!this.dynamicAlign && !alignOk) {
        continue;
      }

      position = position || pos;
      pos.croppedArea = this.__getCroppedArea(pos, size, fitRect);
      var diff = pos.croppedArea - position.croppedArea;
      // Check which crops less. If it crops equally, check if align is ok.
      if (diff < 0 || diff === 0 && alignOk) {
        position = pos;
      }
      // If not cropped and respects the align requirements, keep it.
      // This allows to prefer positions overlapping horizontally over the
      // ones overlapping vertically.
      if (position.croppedArea === 0 && alignOk) {
        break;
      }
    }

    return position;
  }

};</script><dom-module id="iron-overlay-backdrop" assetpath="../bower_components/iron-overlay-behavior/"><template><style>:host{position:fixed;top:0;left:0;width:100%;height:100%;background-color:var(--iron-overlay-backdrop-background-color, #000);opacity:0;transition:opacity 0.2s;pointer-events:none;@apply (--iron-overlay-backdrop);}:host(.opened){opacity:var(--iron-overlay-backdrop-opacity, 0.6);pointer-events:auto;@apply (--iron-overlay-backdrop-opened);}</style><content></content></template></dom-module><script>
(function () {
  'use strict';

  Polymer({

    is: 'iron-overlay-backdrop',

    properties: {

      /**
       * Returns true if the backdrop is opened.
       */
      opened: {
        reflectToAttribute: true,
        type: Boolean,
        value: false,
        observer: '_openedChanged'
      }

    },

    listeners: {
      'transitionend': '_onTransitionend'
    },

    created: function created() {
      // Used to cancel previous requestAnimationFrame calls when opened changes.
      this.__openedRaf = null;
    },

    attached: function attached() {
      this.opened && this._openedChanged(this.opened);
    },

    /**
     * Appends the backdrop to document body if needed.
     */
    prepare: function prepare() {
      if (this.opened && !this.parentNode) {
        Polymer.dom(document.body).appendChild(this);
      }
    },

    /**
     * Shows the backdrop.
     */
    open: function open() {
      this.opened = true;
    },

    /**
     * Hides the backdrop.
     */
    close: function close() {
      this.opened = false;
    },

    /**
     * Removes the backdrop from document body if needed.
     */
    complete: function complete() {
      if (!this.opened && this.parentNode === document.body) {
        Polymer.dom(this.parentNode).removeChild(this);
      }
    },

    _onTransitionend: function _onTransitionend(event) {
      if (event && event.target === this) {
        this.complete();
      }
    },

    /**
     * @param {boolean} opened
     * @private
     */
    _openedChanged: function _openedChanged(opened) {
      if (opened) {
        // Auto-attach.
        this.prepare();
      } else {
        // Animation might be disabled via the mixin or opacity custom property.
        // If it is disabled in other ways, it's up to the user to call complete.
        var cs = window.getComputedStyle(this);
        if (cs.transitionDuration === '0s' || cs.opacity == 0) {
          this.complete();
        }
      }

      if (!this.isAttached) {
        return;
      }

      // Always cancel previous requestAnimationFrame.
      if (this.__openedRaf) {
        window.cancelAnimationFrame(this.__openedRaf);
        this.__openedRaf = null;
      }
      // Force relayout to ensure proper transitions.
      this.scrollTop = this.scrollTop;
      this.__openedRaf = window.requestAnimationFrame(function () {
        this.__openedRaf = null;
        this.toggleClass('opened', this.opened);
      }.bind(this));
    }
  });
})();</script><script>

/**
 * @struct
 * @constructor
 * @private
 */
Polymer.IronOverlayManagerClass = function () {
  /**
   * Used to keep track of the opened overlays.
   * @private {Array<Element>}
   */
  this._overlays = [];

  /**
   * iframes have a default z-index of 100,
   * so this default should be at least that.
   * @private {number}
   */
  this._minimumZ = 101;

  /**
   * Memoized backdrop element.
   * @private {Element|null}
   */
  this._backdropElement = null;

  // Enable document-wide tap recognizer.
  // NOTE: Use useCapture=true to avoid accidentally prevention of the closing
  // of an overlay via event.stopPropagation(). The only way to prevent
  // closing of an overlay should be through its APIs.
  // NOTE: enable tap on <html> to workaround Polymer/polymer#4459
  Polymer.Gestures.add(document.documentElement, 'tap', null);
  document.addEventListener('tap', this._onCaptureClick.bind(this), true);
  document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
  document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
};

Polymer.IronOverlayManagerClass.prototype = {

  constructor: Polymer.IronOverlayManagerClass,

  /**
   * The shared backdrop element.
   * @type {!Element} backdropElement
   */
  get backdropElement() {
    if (!this._backdropElement) {
      this._backdropElement = document.createElement('iron-overlay-backdrop');
    }
    return this._backdropElement;
  },

  /**
   * The deepest active element.
   * @type {!Element} activeElement the active element
   */
  get deepActiveElement() {
    // document.activeElement can be null
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
    // In case of null, default it to document.body.
    var active = document.activeElement || document.body;
    while (active.root && Polymer.dom(active.root).activeElement) {
      active = Polymer.dom(active.root).activeElement;
    }
    return active;
  },

  /**
   * Brings the overlay at the specified index to the front.
   * @param {number} i
   * @private
   */
  _bringOverlayAtIndexToFront: function _bringOverlayAtIndexToFront(i) {
    var overlay = this._overlays[i];
    if (!overlay) {
      return;
    }
    var lastI = this._overlays.length - 1;
    var currentOverlay = this._overlays[lastI];
    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      lastI--;
    }
    // If already the top element, return.
    if (i >= lastI) {
      return;
    }
    // Update z-index to be on top.
    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    if (this._getZ(overlay) <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }

    // Shift other overlays behind the new on top.
    while (i < lastI) {
      this._overlays[i] = this._overlays[i + 1];
      i++;
    }
    this._overlays[lastI] = overlay;
  },

  /**
   * Adds the overlay and updates its z-index if it's opened, or removes it if it's closed.
   * Also updates the backdrop z-index.
   * @param {!Element} overlay
   */
  addOrRemoveOverlay: function addOrRemoveOverlay(overlay) {
    if (overlay.opened) {
      this.addOverlay(overlay);
    } else {
      this.removeOverlay(overlay);
    }
  },

  /**
   * Tracks overlays for z-index and focus management.
   * Ensures the last added overlay with always-on-top remains on top.
   * @param {!Element} overlay
   */
  addOverlay: function addOverlay(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._bringOverlayAtIndexToFront(i);
      this.trackBackdrop();
      return;
    }
    var insertionIndex = this._overlays.length;
    var currentOverlay = this._overlays[insertionIndex - 1];
    var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
    var newZ = this._getZ(overlay);

    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      // This bumps the z-index of +2.
      this._applyOverlayZ(currentOverlay, minimumZ);
      insertionIndex--;
      // Update minimumZ to match previous overlay's z-index.
      var previousOverlay = this._overlays[insertionIndex - 1];
      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
    }

    // Update z-index and insert overlay.
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    this._overlays.splice(insertionIndex, 0, overlay);

    this.trackBackdrop();
  },

  /**
   * @param {!Element} overlay
   */
  removeOverlay: function removeOverlay(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i === -1) {
      return;
    }
    this._overlays.splice(i, 1);

    this.trackBackdrop();
  },

  /**
   * Returns the current overlay.
   * @return {Element|undefined}
   */
  currentOverlay: function currentOverlay() {
    var i = this._overlays.length - 1;
    return this._overlays[i];
  },

  /**
   * Returns the current overlay z-index.
   * @return {number}
   */
  currentOverlayZ: function currentOverlayZ() {
    return this._getZ(this.currentOverlay());
  },

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   * @param {number} minimumZ
   */
  ensureMinimumZ: function ensureMinimumZ(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  },

  focusOverlay: function focusOverlay() {
    var current = /** @type {?} */this.currentOverlay();
    if (current) {
      current._applyFocus();
    }
  },

  /**
   * Updates the backdrop z-index.
   */
  trackBackdrop: function trackBackdrop() {
    var overlay = this._overlayWithBackdrop();
    // Avoid creating the backdrop if there is no overlay with backdrop.
    if (!overlay && !this._backdropElement) {
      return;
    }
    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
    this.backdropElement.opened = !!overlay;
  },

  /**
   * @return {Array<Element>}
   */
  getBackdrops: function getBackdrops() {
    var backdrops = [];
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  },

  /**
   * Returns the z-index for the backdrop.
   * @return {number}
   */
  backdropZ: function backdropZ() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  },

  /**
   * Returns the first opened overlay that has a backdrop.
   * @return {Element|undefined}
   * @private
   */
  _overlayWithBackdrop: function _overlayWithBackdrop() {
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  },

  /**
   * Calculates the minimum z-index for the overlay.
   * @param {Element=} overlay
   * @private
   */
  _getZ: function _getZ(overlay) {
    var z = this._minimumZ;
    if (overlay) {
      var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  },

  /**
   * @param {!Element} element
   * @param {number|string} z
   * @private
   */
  _setZ: function _setZ(element, z) {
    element.style.zIndex = z;
  },

  /**
   * @param {!Element} overlay
   * @param {number} aboveZ
   * @private
   */
  _applyOverlayZ: function _applyOverlayZ(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  },

  /**
   * Returns the deepest overlay in the path.
   * @param {Array<Element>=} path
   * @return {Element|undefined}
   * @suppress {missingProperties}
   * @private
   */
  _overlayInPath: function _overlayInPath(path) {
    path = path || [];
    for (var i = 0; i < path.length; i++) {
      if (path[i]._manager === this) {
        return path[i];
      }
    }
  },

  /**
   * Ensures the click event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureClick: function _onCaptureClick(event) {
    var overlay = /** @type {?} */this.currentOverlay();
    // Check if clicked outside of top overlay.
    if (overlay && this._overlayInPath(Polymer.dom(event).path) !== overlay) {
      overlay._onCaptureClick(event);
    }
  },

  /**
   * Ensures the focus event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureFocus: function _onCaptureFocus(event) {
    var overlay = /** @type {?} */this.currentOverlay();
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  },

  /**
   * Ensures TAB and ESC keyboard events are delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureKeyDown: function _onCaptureKeyDown(event) {
    var overlay = /** @type {?} */this.currentOverlay();
    if (overlay) {
      if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'esc')) {
        overlay._onCaptureEsc(event);
      } else if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {
        overlay._onCaptureTab(event);
      }
    }
  },

  /**
   * Returns if the overlay1 should be behind overlay2.
   * @param {!Element} overlay1
   * @param {!Element} overlay2
   * @return {boolean}
   * @suppress {missingProperties}
   * @private
   */
  _shouldBeBehindOverlay: function _shouldBeBehindOverlay(overlay1, overlay2) {
    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
  }
};

Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass();</script><script>
(function () {
  'use strict';

  var p = Element.prototype;
  var matches = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  Polymer.IronFocusablesHelper = {

    /**
     * Returns a sorted array of tabbable nodes, including the root node.
     * It searches the tabbable nodes in the light and shadow dom of the chidren,
     * sorting the result by tabindex.
     * @param {!Node} node
     * @return {Array<HTMLElement>}
     */
    getTabbableNodes: function getTabbableNodes(node) {
      var result = [];
      // If there is at least one element with tabindex > 0, we need to sort
      // the final array by tabindex.
      var needsSortByTabIndex = this._collectTabbableNodes(node, result);
      if (needsSortByTabIndex) {
        return this._sortByTabIndex(result);
      }
      return result;
    },

    /**
     * Returns if a element is focusable.
     * @param {!HTMLElement} element
     * @return {boolean}
     */
    isFocusable: function isFocusable(element) {
      // From http://stackoverflow.com/a/1600194/4228703:
      // There isn't a definite list, it's up to the browser. The only
      // standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,
      // according to which the only elements that have a focus() method are
      // HTMLInputElement,  HTMLSelectElement, HTMLTextAreaElement and
      // HTMLAnchorElement. This notably omits HTMLButtonElement and
      // HTMLAreaElement.
      // Referring to these tests with tabbables in different browsers
      // http://allyjs.io/data-tables/focusable.html

      // Elements that cannot be focused if they have [disabled] attribute.
      if (matches.call(element, 'input, select, textarea, button, object')) {
        return matches.call(element, ':not([disabled])');
      }
      // Elements that can be focused even if they have [disabled] attribute.
      return matches.call(element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');
    },

    /**
     * Returns if a element is tabbable. To be tabbable, a element must be
     * focusable, visible, and with a tabindex !== -1.
     * @param {!HTMLElement} element
     * @return {boolean}
     */
    isTabbable: function isTabbable(element) {
      return this.isFocusable(element) && matches.call(element, ':not([tabindex="-1"])') && this._isVisible(element);
    },

    /**
     * Returns the normalized element tabindex. If not focusable, returns -1.
     * It checks for the attribute "tabindex" instead of the element property
     * `tabIndex` since browsers assign different values to it.
     * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
     * @param {!HTMLElement} element
     * @return {!number}
     * @private
     */
    _normalizedTabIndex: function _normalizedTabIndex(element) {
      if (this.isFocusable(element)) {
        var tabIndex = element.getAttribute('tabindex') || 0;
        return Number(tabIndex);
      }
      return -1;
    },

    /**
     * Searches for nodes that are tabbable and adds them to the `result` array.
     * Returns if the `result` array needs to be sorted by tabindex.
     * @param {!Node} node The starting point for the search; added to `result`
     * if tabbable.
     * @param {!Array<HTMLElement>} result
     * @return {boolean}
     * @private
     */
    _collectTabbableNodes: function _collectTabbableNodes(node, result) {
      // If not an element or not visible, no need to explore children.
      if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {
        return false;
      }
      var element = /** @type {HTMLElement} */node;
      var tabIndex = this._normalizedTabIndex(element);
      var needsSortByTabIndex = tabIndex > 0;
      if (tabIndex >= 0) {
        result.push(element);
      }

      // In ShadowDOM v1, tab order is affected by the order of distrubution.
      // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];
      // in ShadowDOM v0 tab order is not affected by the distrubution order,
      // in fact getTabbableNodes(#root) returns [#B, #A].
      //  <div id="root">
      //   <!-- shadow -->
      //     <slot name="a">
      //     <slot name="b">
      //   <!-- /shadow -->
      //   <input id="A" slot="a">
      //   <input id="B" slot="b" tabindex="1">
      //  </div>
      // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.
      var children;
      if (element.localName === 'content') {
        children = Polymer.dom(element).getDistributedNodes();
      } else {
        // Use shadow root if possible, will check for distributed nodes.
        children = Polymer.dom(element.root || element).children;
      }
      for (var i = 0; i < children.length; i++) {
        // Ensure method is always invoked to collect tabbable children.
        var needsSort = this._collectTabbableNodes(children[i], result);
        needsSortByTabIndex = needsSortByTabIndex || needsSort;
      }
      return needsSortByTabIndex;
    },

    /**
     * Returns false if the element has `visibility: hidden` or `display: none`
     * @param {!HTMLElement} element
     * @return {boolean}
     * @private
     */
    _isVisible: function _isVisible(element) {
      // Check inline style first to save a re-flow. If looks good, check also
      // computed style.
      var style = element.style;
      if (style.visibility !== 'hidden' && style.display !== 'none') {
        style = window.getComputedStyle(element);
        return style.visibility !== 'hidden' && style.display !== 'none';
      }
      return false;
    },

    /**
     * Sorts an array of tabbable elements by tabindex. Returns a new array.
     * @param {!Array<HTMLElement>} tabbables
     * @return {Array<HTMLElement>}
     * @private
     */
    _sortByTabIndex: function _sortByTabIndex(tabbables) {
      // Implement a merge sort as Array.prototype.sort does a non-stable sort
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
      var len = tabbables.length;
      if (len < 2) {
        return tabbables;
      }
      var pivot = Math.ceil(len / 2);
      var left = this._sortByTabIndex(tabbables.slice(0, pivot));
      var right = this._sortByTabIndex(tabbables.slice(pivot));
      return this._mergeSortByTabIndex(left, right);
    },

    /**
     * Merge sort iterator, merges the two arrays into one, sorted by tab index.
     * @param {!Array<HTMLElement>} left
     * @param {!Array<HTMLElement>} right
     * @return {Array<HTMLElement>}
     * @private
     */
    _mergeSortByTabIndex: function _mergeSortByTabIndex(left, right) {
      var result = [];
      while (left.length > 0 && right.length > 0) {
        if (this._hasLowerTabOrder(left[0], right[0])) {
          result.push(right.shift());
        } else {
          result.push(left.shift());
        }
      }

      return result.concat(left, right);
    },

    /**
     * Returns if element `a` has lower tab order compared to element `b`
     * (both elements are assumed to be focusable and tabbable).
     * Elements with tabindex = 0 have lower tab order compared to elements
     * with tabindex > 0.
     * If both have same tabindex, it returns false.
     * @param {!HTMLElement} a
     * @param {!HTMLElement} b
     * @return {boolean}
     * @private
     */
    _hasLowerTabOrder: function _hasLowerTabOrder(a, b) {
      // Normalize tabIndexes
      // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
      var ati = Math.max(a.tabIndex, 0);
      var bti = Math.max(b.tabIndex, 0);
      return ati === 0 || bti === 0 ? bti > ati : ati > bti;
    }
  };
})();</script><script>
(function () {
  'use strict';

  /** @polymerBehavior */

  Polymer.IronOverlayBehaviorImpl = {

    properties: {

      /**
       * True if the overlay is currently displayed.
       */
      opened: {
        observer: '_openedChanged',
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * True if the overlay was canceled when it was last closed.
       */
      canceled: {
        observer: '_canceledChanged',
        readOnly: true,
        type: Boolean,
        value: false
      },

      /**
       * Set to true to display a backdrop behind the overlay. It traps the focus
       * within the light DOM of the overlay.
       */
      withBackdrop: {
        observer: '_withBackdropChanged',
        type: Boolean
      },

      /**
       * Set to true to disable auto-focusing the overlay or child nodes with
       * the `autofocus` attribute` when the overlay is opened.
       */
      noAutoFocus: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable canceling the overlay with the ESC key.
       */
      noCancelOnEscKey: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable canceling the overlay by clicking outside it.
       */
      noCancelOnOutsideClick: {
        type: Boolean,
        value: false
      },

      /**
       * Contains the reason(s) this overlay was last closed (see `iron-overlay-closed`).
       * `IronOverlayBehavior` provides the `canceled` reason; implementers of the
       * behavior can provide other reasons in addition to `canceled`.
       */
      closingReason: {
        // was a getter before, but needs to be a property so other
        // behaviors can override this.
        type: Object
      },

      /**
       * Set to true to enable restoring of focus when overlay is closed.
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to keep overlay always on top.
       */
      alwaysOnTop: {
        type: Boolean
      },

      /**
       * Shortcut to access to the overlay manager.
       * @private
       * @type {Polymer.IronOverlayManagerClass}
       */
      _manager: {
        type: Object,
        value: Polymer.IronOverlayManager
      },

      /**
       * The node being focused.
       * @type {?Node}
       */
      _focusedChild: {
        type: Object
      }

    },

    listeners: {
      'iron-resize': '_onIronResize'
    },

    /**
     * The backdrop element.
     * @type {Element}
     */
    get backdropElement() {
      return this._manager.backdropElement;
    },

    /**
     * Returns the node to give focus to.
     * @type {Node}
     */
    get _focusNode() {
      return this._focusedChild || Polymer.dom(this).querySelector('[autofocus]') || this;
    },

    /**
     * Array of nodes that can receive focus (overlay included), ordered by `tabindex`.
     * This is used to retrieve which is the first and last focusable nodes in order
     * to wrap the focus for overlays `with-backdrop`.
     *
     * If you know what is your content (specifically the first and last focusable children),
     * you can override this method to return only `[firstFocusable, lastFocusable];`
     * @type {Array<Node>}
     * @protected
     */
    get _focusableNodes() {
      return Polymer.IronFocusablesHelper.getTabbableNodes(this);
    },

    ready: function ready() {
      // Used to skip calls to notifyResize and refit while the overlay is animating.
      this.__isAnimating = false;
      // with-backdrop needs tabindex to be set in order to trap the focus.
      // If it is not set, IronOverlayBehavior will set it, and remove it if with-backdrop = false.
      this.__shouldRemoveTabIndex = false;
      // Used for wrapping the focus on TAB / Shift+TAB.
      this.__firstFocusableNode = this.__lastFocusableNode = null;
      // Used by __onNextAnimationFrame to cancel any previous callback.
      this.__raf = null;
      // Focused node before overlay gets opened. Can be restored on close.
      this.__restoreFocusNode = null;
      this._ensureSetup();
    },

    attached: function attached() {
      // Call _openedChanged here so that position can be computed correctly.
      if (this.opened) {
        this._openedChanged(this.opened);
      }
      this._observer = Polymer.dom(this).observeNodes(this._onNodesChange);
    },

    detached: function detached() {
      Polymer.dom(this).unobserveNodes(this._observer);
      this._observer = null;
      if (this.__raf) {
        window.cancelAnimationFrame(this.__raf);
        this.__raf = null;
      }
      this._manager.removeOverlay(this);
    },

    /**
     * Toggle the opened state of the overlay.
     */
    toggle: function toggle() {
      this._setCanceled(false);
      this.opened = !this.opened;
    },

    /**
     * Open the overlay.
     */
    open: function open() {
      this._setCanceled(false);
      this.opened = true;
    },

    /**
     * Close the overlay.
     */
    close: function close() {
      this._setCanceled(false);
      this.opened = false;
    },

    /**
     * Cancels the overlay.
     * @param {Event=} event The original event
     */
    cancel: function cancel(event) {
      var cancelEvent = this.fire('iron-overlay-canceled', event, { cancelable: true });
      if (cancelEvent.defaultPrevented) {
        return;
      }

      this._setCanceled(true);
      this.opened = false;
    },

    /**
     * Invalidates the cached tabbable nodes. To be called when any of the focusable
     * content changes (e.g. a button is disabled).
     */
    invalidateTabbables: function invalidateTabbables() {
      this.__firstFocusableNode = this.__lastFocusableNode = null;
    },

    _ensureSetup: function _ensureSetup() {
      if (this._overlaySetup) {
        return;
      }
      this._overlaySetup = true;
      this.style.outline = 'none';
      this.style.display = 'none';
    },

    /**
     * Called when `opened` changes.
     * @param {boolean=} opened
     * @protected
     */
    _openedChanged: function _openedChanged(opened) {
      if (opened) {
        this.removeAttribute('aria-hidden');
      } else {
        this.setAttribute('aria-hidden', 'true');
      }

      // Defer any animation-related code on attached
      // (_openedChanged gets called again on attached).
      if (!this.isAttached) {
        return;
      }

      this.__isAnimating = true;

      // Use requestAnimationFrame for non-blocking rendering.
      this.__onNextAnimationFrame(this.__openedChanged);
    },

    _canceledChanged: function _canceledChanged() {
      this.closingReason = this.closingReason || {};
      this.closingReason.canceled = this.canceled;
    },

    _withBackdropChanged: function _withBackdropChanged() {
      // If tabindex is already set, no need to override it.
      if (this.withBackdrop && !this.hasAttribute('tabindex')) {
        this.setAttribute('tabindex', '-1');
        this.__shouldRemoveTabIndex = true;
      } else if (this.__shouldRemoveTabIndex) {
        this.removeAttribute('tabindex');
        this.__shouldRemoveTabIndex = false;
      }
      if (this.opened && this.isAttached) {
        this._manager.trackBackdrop();
      }
    },

    /**
     * tasks which must occur before opening; e.g. making the element visible.
     * @protected
     */
    _prepareRenderOpened: function _prepareRenderOpened() {
      // Store focused node.
      this.__restoreFocusNode = this._manager.deepActiveElement;

      // Needed to calculate the size of the overlay so that transitions on its size
      // will have the correct starting points.
      this._preparePositioning();
      this.refit();
      this._finishPositioning();

      // Safari will apply the focus to the autofocus element when displayed
      // for the first time, so we make sure to return the focus where it was.
      if (this.noAutoFocus && document.activeElement === this._focusNode) {
        this._focusNode.blur();
        this.__restoreFocusNode.focus();
      }
    },

    /**
     * Tasks which cause the overlay to actually open; typically play an animation.
     * @protected
     */
    _renderOpened: function _renderOpened() {
      this._finishRenderOpened();
    },

    /**
     * Tasks which cause the overlay to actually close; typically play an animation.
     * @protected
     */
    _renderClosed: function _renderClosed() {
      this._finishRenderClosed();
    },

    /**
     * Tasks to be performed at the end of open action. Will fire `iron-overlay-opened`.
     * @protected
     */
    _finishRenderOpened: function _finishRenderOpened() {
      this.notifyResize();
      this.__isAnimating = false;

      this.fire('iron-overlay-opened');
    },

    /**
     * Tasks to be performed at the end of close action. Will fire `iron-overlay-closed`.
     * @protected
     */
    _finishRenderClosed: function _finishRenderClosed() {
      // Hide the overlay.
      this.style.display = 'none';
      // Reset z-index only at the end of the animation.
      this.style.zIndex = '';
      this.notifyResize();
      this.__isAnimating = false;
      this.fire('iron-overlay-closed', this.closingReason);
    },

    _preparePositioning: function _preparePositioning() {
      this.style.transition = this.style.webkitTransition = 'none';
      this.style.transform = this.style.webkitTransform = 'none';
      this.style.display = '';
    },

    _finishPositioning: function _finishPositioning() {
      // First, make it invisible & reactivate animations.
      this.style.display = 'none';
      // Force reflow before re-enabling animations so that they don't start.
      // Set scrollTop to itself so that Closure Compiler doesn't remove this.
      this.scrollTop = this.scrollTop;
      this.style.transition = this.style.webkitTransition = '';
      this.style.transform = this.style.webkitTransform = '';
      // Now that animations are enabled, make it visible again
      this.style.display = '';
      // Force reflow, so that following animations are properly started.
      // Set scrollTop to itself so that Closure Compiler doesn't remove this.
      this.scrollTop = this.scrollTop;
    },

    /**
     * Applies focus according to the opened state.
     * @protected
     */
    _applyFocus: function _applyFocus() {
      if (this.opened) {
        if (!this.noAutoFocus) {
          this._focusNode.focus();
        }
      } else {
        this._focusNode.blur();
        this._focusedChild = null;
        // Restore focus.
        if (this.restoreFocusOnClose && this.__restoreFocusNode) {
          this.__restoreFocusNode.focus();
        }
        this.__restoreFocusNode = null;
        // If many overlays get closed at the same time, one of them would still
        // be the currentOverlay even if already closed, and would call _applyFocus
        // infinitely, so we check for this not to be the current overlay.
        var currentOverlay = this._manager.currentOverlay();
        if (currentOverlay && this !== currentOverlay) {
          currentOverlay._applyFocus();
        }
      }
    },

    /**
     * Cancels (closes) the overlay. Call when click happens outside the overlay.
     * @param {!Event} event
     * @protected
     */
    _onCaptureClick: function _onCaptureClick(event) {
      if (!this.noCancelOnOutsideClick) {
        this.cancel(event);
      }
    },

    /**
     * Keeps track of the focused child. If withBackdrop, traps focus within overlay.
     * @param {!Event} event
     * @protected
     */
    _onCaptureFocus: function _onCaptureFocus(event) {
      if (!this.withBackdrop) {
        return;
      }
      var path = Polymer.dom(event).path;
      if (path.indexOf(this) === -1) {
        event.stopPropagation();
        this._applyFocus();
      } else {
        this._focusedChild = path[0];
      }
    },

    /**
     * Handles the ESC key event and cancels (closes) the overlay.
     * @param {!Event} event
     * @protected
     */
    _onCaptureEsc: function _onCaptureEsc(event) {
      if (!this.noCancelOnEscKey) {
        this.cancel(event);
      }
    },

    /**
     * Handles TAB key events to track focus changes.
     * Will wrap focus for overlays withBackdrop.
     * @param {!Event} event
     * @protected
     */
    _onCaptureTab: function _onCaptureTab(event) {
      if (!this.withBackdrop) {
        return;
      }
      this.__ensureFirstLastFocusables();
      // TAB wraps from last to first focusable.
      // Shift + TAB wraps from first to last focusable.
      var shift = event.shiftKey;
      var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;
      var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;
      var shouldWrap = false;
      if (nodeToCheck === nodeToSet) {
        // If nodeToCheck is the same as nodeToSet, it means we have an overlay
        // with 0 or 1 focusables; in either case we still need to trap the
        // focus within the overlay.
        shouldWrap = true;
      } else {
        // In dom=shadow, the manager will receive focus changes on the main
        // root but not the ones within other shadow roots, so we can't rely on
        // _focusedChild, but we should check the deepest active element.
        var focusedNode = this._manager.deepActiveElement;
        // If the active element is not the nodeToCheck but the overlay itself,
        // it means the focus is about to go outside the overlay, hence we
        // should prevent that (e.g. user opens the overlay and hit Shift+TAB).
        shouldWrap = focusedNode === nodeToCheck || focusedNode === this;
      }

      if (shouldWrap) {
        // When the overlay contains the last focusable element of the document
        // and it's already focused, pressing TAB would move the focus outside
        // the document (e.g. to the browser search bar). Similarly, when the
        // overlay contains the first focusable element of the document and it's
        // already focused, pressing Shift+TAB would move the focus outside the
        // document (e.g. to the browser search bar).
        // In both cases, we would not receive a focus event, but only a blur.
        // In order to achieve focus wrapping, we prevent this TAB event and
        // force the focus. This will also prevent the focus to temporarily move
        // outside the overlay, which might cause scrolling.
        event.preventDefault();
        this._focusedChild = nodeToSet;
        this._applyFocus();
      }
    },

    /**
     * Refits if the overlay is opened and not animating.
     * @protected
     */
    _onIronResize: function _onIronResize() {
      if (this.opened && !this.__isAnimating) {
        this.__onNextAnimationFrame(this.refit);
      }
    },

    /**
     * Will call notifyResize if overlay is opened.
     * Can be overridden in order to avoid multiple observers on the same node.
     * @protected
     */
    _onNodesChange: function _onNodesChange() {
      if (this.opened && !this.__isAnimating) {
        // It might have added focusable nodes, so invalidate cached values.
        this.invalidateTabbables();
        this.notifyResize();
      }
    },

    /**
     * Will set first and last focusable nodes if any of them is not set.
     * @private
     */
    __ensureFirstLastFocusables: function __ensureFirstLastFocusables() {
      if (!this.__firstFocusableNode || !this.__lastFocusableNode) {
        var focusableNodes = this._focusableNodes;
        this.__firstFocusableNode = focusableNodes[0];
        this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
      }
    },

    /**
     * Tasks executed when opened changes: prepare for the opening, move the
     * focus, update the manager, render opened/closed.
     * @private
     */
    __openedChanged: function __openedChanged() {
      if (this.opened) {
        // Make overlay visible, then add it to the manager.
        this._prepareRenderOpened();
        this._manager.addOverlay(this);
        // Move the focus to the child node with [autofocus].
        this._applyFocus();

        this._renderOpened();
      } else {
        // Remove overlay, then restore the focus before actually closing.
        this._manager.removeOverlay(this);
        this._applyFocus();

        this._renderClosed();
      }
    },

    /**
     * Executes a callback on the next animation frame, overriding any previous
     * callback awaiting for the next animation frame. e.g.
     * `__onNextAnimationFrame(callback1) && __onNextAnimationFrame(callback2)`;
     * `callback1` will never be invoked.
     * @param {!Function} callback Its `this` parameter is the overlay itself.
     * @private
     */
    __onNextAnimationFrame: function __onNextAnimationFrame(callback) {
      if (this.__raf) {
        window.cancelAnimationFrame(this.__raf);
      }
      var self = this;
      this.__raf = window.requestAnimationFrame(function nextAnimationFrame() {
        self.__raf = null;
        callback.call(self);
      });
    }

  };

  /**
  Use `Polymer.IronOverlayBehavior` to implement an element that can be hidden or shown, and displays
  on top of other content. It includes an optional backdrop, and can be used to implement a variety
  of UI controls including dialogs and drop downs. Multiple overlays may be displayed at once.
   See the [demo source code](https://github.com/PolymerElements/iron-overlay-behavior/blob/master/demo/simple-overlay.html)
  for an example.
   ### Closing and canceling
   An overlay may be hidden by closing or canceling. The difference between close and cancel is user
  intent. Closing generally implies that the user acknowledged the content on the overlay. By default,
  it will cancel whenever the user taps outside it or presses the escape key. This behavior is
  configurable with the `no-cancel-on-esc-key` and the `no-cancel-on-outside-click` properties.
  `close()` should be called explicitly by the implementer when the user interacts with a control
  in the overlay element. When the dialog is canceled, the overlay fires an 'iron-overlay-canceled'
  event. Call `preventDefault` on this event to prevent the overlay from closing.
   ### Positioning
   By default the element is sized and positioned to fit and centered inside the window. You can
  position and size it manually using CSS. See `Polymer.IronFitBehavior`.
   ### Backdrop
   Set the `with-backdrop` attribute to display a backdrop behind the overlay. The backdrop is
  appended to `<body>` and is of type `<iron-overlay-backdrop>`. See its doc page for styling
  options.
   In addition, `with-backdrop` will wrap the focus within the content in the light DOM.
  Override the [`_focusableNodes` getter](#Polymer.IronOverlayBehavior:property-_focusableNodes)
  to achieve a different behavior.
   ### Limitations
   The element is styled to appear on top of other content by setting its `z-index` property. You
  must ensure no element has a stacking context with a higher `z-index` than its parent stacking
  context. You should place this element as a child of `<body>` whenever possible.
   @demo demo/index.html
  @polymerBehavior
  */
  Polymer.IronOverlayBehavior = [Polymer.IronFitBehavior, Polymer.IronResizableBehavior, Polymer.IronOverlayBehaviorImpl];

  /**
   * Fired after the overlay opens.
   * @event iron-overlay-opened
   */

  /**
   * Fired when the overlay is canceled, but before it is closed.
   * @event iron-overlay-canceled
   * @param {Event} event The closing of the overlay can be prevented
   * by calling `event.preventDefault()`. The `event.detail` is the original event that
   * originated the canceling (e.g. ESC keyboard event or click event outside the overlay).
   */

  /**
   * Fired after the overlay closes.
   * @event iron-overlay-closed
   * @param {Event} event The `event.detail` is the `closingReason` property
   * (contains `canceled`, whether the overlay was canceled).
   */
})();</script><dom-module id="vaadin-license-box" assetpath="../bower_components/vaadin-license-checker/"><style>:host{font:300 16px/1.55 "Open Sans", sans-serif;position:fixed;top:0;right:0;cursor:pointer;backface-visibility:hidden;background:white;}#licenseBoxContent{padding:11px 13px;margin:0;display:inline-block;text-align:left;font-weight:inherit;white-space:nowrap;letter-spacing:0;line-height:1;font-size:16px;border-bottom-left-radius:4px;box-shadow:0 5px 15px 0 rgba(0, 0, 0, 0.15);}#licenseBoxContent.trial{color:#197de1;}#licenseBoxContent.unlicensed{background:#ed473b;font-weight:400;color:white;}#licenseBoxContent.expired{background:#FFF3D2;color:#AC7C00;}</style><template><div id="licenseBoxContent" class$="[[type]]" on-click="_close">[[content]]</div></template><script>
LicenseBox = Polymer({
    is: "vaadin-license-box",

    behaviors: [Polymer.IronOverlayBehavior],

    contents: {
        unlicensed: 'Unlicensed copy of {0}',
        trial: '{0} trial license',
        expired: '{0} license expired'
    },

    properties: {
        content: {
            type: String,
            computed: '_computeContent(type, productCaption)'
        },
        type: String,
        productCaption: String,
        expiryEpoch: Number,

        //override
        noCancelOnEscKey: {
            type: Boolean,
            value: true
        },
        noCancelOnOutsideClick: {
            type: Boolean,
            value: true
        }
    },

    _close: function _close() {
        this.fire('vaadin-license-box-close', {
            type: this.type,
            expiryEpoch: this.expiryEpoch
        });
        this.close();
    },

    _computeContent: function _computeContent(type, productCaption) {
        return this.contents[type].replace('{0}', productCaption);
    }
});</script></dom-module><dom-module id="vaadin-license-dialog" assetpath="../bower_components/vaadin-license-checker/"><style>:host{font:300 16px/1.55 "Open Sans", sans-serif;cursor:default;box-sizing:border-box;display:inline-block;vertical-align:top;text-align:left;border-radius:4px;background-color:white;color:#474747;box-shadow:0 2px 10px rgba(0, 0, 0, 0.1), 0 16px 80px -6px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.09098);padding:0;min-width:148px !important;min-height:37px !important;overflow:hidden !important;transition:width 200ms, height 200ms;margin-left:0;margin-top:0;z-index:10000;visibility:visible;}#header{line-height:36px;padding-left:12px;margin-right:37px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#7e7e7e;}#licenseDialogClose{position:absolute;z-index:3;top:0;right:0;box-sizing:border-box;height:36px;background-color:white;line-height:34px;text-align:center;cursor:pointer;font-size:21px;color:#999999;width:37px;padding-right:0;border-radius:0 4px 0 4px;transition:color 140ms;}#licenseDialogExplanation{max-width:26em;padding:0 12px;border:1px solid transparent;}p{margin:12px 0;}p:first-child{font-weight:400;}#vaadin-license-dialog-input{margin:0 12px 12px 12px;}#licenseDialogInput{box-sizing:border-box;display:inline-block;vertical-align:top;text-align:left;white-space:normal;margin:0;font:inherit;font-weight:400;line-height:normal;height:37px;border-radius:4px;border:1px solid #c5c5c5;background:white;color:#474747;box-shadow:inset 0 1px 0 #f7f7f7, 0 1px 0 rgba(255, 255, 255, 0.1);transition:box-shadow 180ms, border 180ms;width:100%;padding:4px 6em 4px 9px;}#vaadin-license-dialog-input > button{box-sizing:border-box;display:inline-block;font:inherit;line-height:1.55;text-align:center;white-space:nowrap;outline:none;-webkit-tap-highlight-color:transparent;cursor:pointer;height:37px;padding:0 16px;color:#191919;font-weight:400;border:1px solid #c5c5c5;border-bottom-color:#bcbcbc;background-color:#fafafa;box-shadow:inset 0 1px 0 white, inset 0 -1px 0 #e7e7e7, 0 2px 3px rgba(0, 0, 0, 0.05);text-shadow:0 1px 0 rgba(255, 255, 255, 0.05);vertical-align:middle;margin-left:-1px;border-radius:0 4px 4px 0;position:absolute;right:12px;}#vaadin-license-dialog-input > button:hover{background-color:rgba(186, 186, 186, 0.1);}#vaadin-license-dialog-input > button:active{background-color:rgba(125, 125, 125, 0.2);}</style><template><div id="licenseDialogHeader"><span id="header">[[header]]</span> <span id="licenseDialogClose" on-click="_close">×</span></div><div id="licenseDialogExplanation"></div><div id="vaadin-license-dialog-input"><input id="licenseDialogInput" type="text" size="38" on-keydown="_inputKeyDown"><button on-click="_submit">Submit</button></div></template><script>
LicenseDialog = Polymer({
    is: "vaadin-license-dialog",

    behaviors: [Polymer.IronOverlayBehavior],

    headers: {
        unlicensed: "Unlicensed copy of {0}",
        trial: "{0} trial license",
        expired: "{0} license expired"
    },

    contents: {
        unlicensed: '<p class="vaadin-license-dialog">To use {0} in development, each developer needs to have a valid license.<p class="vaadin-license-dialog">Please <a href="https://vaadin.com/pro/licenses" target="_blank"> get a license from vaadin.com</a>, then enter your license key here:',
        trial: '<p class="vaadin-license-dialog">You are currently using {0} with a trial license, which will expire {1}.<p class="vaadin-license-dialog">You can <a href="https://vaadin.com/pro/licenses" target="_blank"> visit vaadin.com to get a paid license</a>, then enter your license key here:',
        expired: '<p class="vaadin-license-dialog">Your {0} license has expired.<p class="vaadin-license-dialog">Please <a href="https://vaadin.com/pro/licenses" target="_blank">renew your license at vaadin.com</a>, then refresh the page. Alternatively, if you have a new license key, you can enter it here:'
    },

    properties: {
        type: String,
        productCaption: String,
        expiryEpoch: {
            type: Number,
            value: 0
        },

        header: {
            type: String,
            computed: '_computeHeader(type, productCaption)'
        },
        content: {
            type: String,
            observer: '_contentChanged',
            computed: '_computeContent(type, productCaption, expiryEpoch)'
        },

        //override
        withBackdrop: {
            type: Boolean,
            value: true
        },
        noCancelOnEscKey: {
            type: Boolean,
            value: true
        },
        noCancelOnOutsideClick: {
            type: Boolean,
            value: true
        }
    },

    _contentChanged: function _contentChanged(value) {
        this.$.licenseDialogExplanation.innerHTML = value;
    },

    _submit: function _submit() {
        this.fire('vaadin-license-dialog-submit', {
            licenseKey: this.$.licenseDialogInput.value
        });
        this.close();
    },

    _close: function _close() {
        this.fire('vaadin-license-dialog-close', {
            type: this.type,
            expiryEpoch: this.expiryEpoch
        });
        this.close();
    },

    _computeHeader: function _computeHeader(type, productCaption) {
        return this.headers[type].replace('{0}', productCaption);
    },

    _computeContent: function _computeContent(type, productCaption, expiryEpoch) {
        if (type === 'trial') {
            var timeToExpiry = expiryEpoch - Date.now();
            var hoursToExpiry = Math.round(timeToExpiry / 1000 / 60 / 60);
            var daysToExpiry = Math.round(timeToExpiry / 1000 / 60 / 60 / 24);
            var expiryDate = new Date(expiryEpoch);
            var expiryDateISOFormat = expiryDate.getFullYear() + '-' + this._padDate(expiryDate.getMonth()) + '-' + this._padDate(expiryDate.getDate());

            if (hoursToExpiry < 24) {
                return this._replaceArguments(this.contents[type], productCaption, 'in ' + hoursToExpiry + ' hours');
            } else if (daysToExpiry < 30) {
                return this._replaceArguments(this.contents[type], productCaption, 'in ' + daysToExpiry + ' days');
            } else {
                return this._replaceArguments(this.contents[type], productCaption, 'on ' + expiryDateISOFormat);
            }
        } else {
            return this._replaceArguments(this.contents[type], productCaption);
        }
    },

    _replaceArguments: function _replaceArguments(string) {
        var newString = string;
        for (var i = 1; i < arguments.length; i++) {
            newString = newString.replace('{' + (i - 1) + '}', arguments[i]);
        }

        return newString;
    },

    _padDate: function _padDate(date) {
        if (date.toString().length === 1) {
            return '0' + date;
        } else {
            return date;
        }
    },

    _inputKeyDown: function _inputKeyDown(e) {
        if (e.keyCode === 13) {
            this._submit();
        }
    }

});</script></dom-module><dom-module id="vaadin-license-notification" assetpath="../bower_components/vaadin-license-checker/"><style>:host{font:300 16px/1.55 "Open Sans", sans-serif;backface-visibility:hidden;padding:19px 22px;display:inline-block;text-align:left;white-space:nowrap;letter-spacing:0;border-radius:4px;box-shadow:0 5px 15px 0 rgba(0, 0, 0, 0.15);font-weight:400;background:#fff;color:#555;border:2px solid #2c9720;}:host > div{font-size:19px;line-height:1;vertical-align:middle;color:#2c9720;font-weight:400;}:host > div:before{font-family:FontAwesome;content:"\f00c";margin-right:0.5em;}</style><template><div>License key accepted</div></template><script>
LicenseNotification = Polymer({
    is: "vaadin-license-notification",

    behaviors: [Polymer.IronOverlayBehavior]
});</script></dom-module><dom-module id="vaadin-framework-identifier" assetpath="../bower_components/vaadin-license-checker/"><template></template><script>
FrameworkIdentifier = Polymer({
    is: 'vaadin-framework-identifier',

    properties: {
        framework: {
            type: String,
            value: ''
        },
        version: {
            type: String,
            value: ''
        },
        _frameworks: {
            type: Object,
            value: {
                'Angular2': function Angular2() {
                    try {
                        return window.ng;
                    } catch (e) {
                        return false;
                    }
                },
                'AngularJs': function AngularJs() {
                    try {
                        return window.angular;
                    } catch (e) {
                        return false;
                    }
                },
                'Backbone.js': function BackboneJs() {
                    try {
                        return window.Backbone && typeof window.Backbone.sync === 'function';
                    } catch (e) {
                        return false;
                    }
                },
                'React': function React() {
                    try {
                        var reactSelector = '[data-reactroot], [data-reactid]';
                        return !!document.querySelector(reactSelector);
                    } catch (e) {
                        return false;
                    }
                },
                'Ember': function Ember() {
                    try {
                        if (window.Ember) {
                            return window.Ember;
                        } else {
                            return window.Em;
                        }
                    } catch (e) {
                        return false;
                    }
                },
                'jQuery': function jQuery() {
                    try {
                        return window.jQuery;
                    } catch (e) {
                        return false;
                    }
                },
                'Polymer': function Polymer() {
                    // When using Vaadin Charts, Polymer is required.
                    // Keep this at the bottom
                    return true;
                }
            }
        },
        _frameworkVersions: {
            type: Object,
            value: {
                'AngularJs': function AngularJs() {
                    try {
                        if (window.angular && window.angular.version && 'full' in window.angular.version) {
                            return window.angular.version.full;
                        }
                    } catch (e) {
                        return '';
                    }
                },
                'Backbone.js': function BackboneJs() {
                    try {
                        if (window.Backbone && window.Backbone.VERSION) {
                            return window.Backbone.VERSION;
                        }
                    } catch (e) {
                        return '';
                    }
                },
                'jQuery': function (_jQuery) {
                    function jQuery() {
                        return _jQuery.apply(this, arguments);
                    }

                    jQuery.toString = function () {
                        return _jQuery.toString();
                    };

                    return jQuery;
                }(function () {
                    try {
                        if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
                            return jQuery.prototype.jquery;
                        }
                    } catch (e) {
                        return '';
                    }
                }),
                'Ember': function Ember() {
                    try {
                        if (window.Em && window.Em.VERSION) {
                            return window.Em.VERSION;
                        } else if (window.Ember && window.Ember.VERSION) {
                            return window.Ember.VERSION;
                        }
                    } catch (e) {
                        return '';
                    }
                },
                'Polymer': function Polymer() {
                    try {
                        if (window.Polymer && window.Polymer.version) {
                            return window.Polymer.version;
                        }
                    } catch (e) {
                        return '';
                    }
                }
            }
        }
    },

    setFrameWorkAndVersion: function setFrameWorkAndVersion() {
        this._setFramework();
        this._setVersion();
    },

    _setFramework: function _setFramework() {
        for (var framework in this._frameworks) {
            if (this._frameworks[framework]()) {
                this.framework = framework;
                break;
            }
        }
    },

    _setVersion: function _setVersion() {
        if (this.framework && this._frameworkVersions[this.framework]) {
            this.version = this._frameworkVersions[this.framework]();
        }
    }
});</script></dom-module><dom-module id="vaadin-license-checker" assetpath="../bower_components/vaadin-license-checker/"><template><iron-localstorage id="storageLicense" name="[[storageKey]]" value="{{licenseKey}}" use-raw="true"></iron-localstorage><iron-localstorage id="storageLicenseCheckTime" name="[[storageKeyCheckTime]]" value="{{licenseCheckTime}}" use-raw="true"></iron-localstorage><iron-localstorage id="storageLicenseType" name="[[storageKeyType]]" value="{{licenseKeyType}}" use-raw="true"></iron-localstorage><iron-ajax id="licenseRequest" url="[[licenseUrl]]" headers="[[licenseRequestHeaders]]" handle-as="json" on-response="_handleResultFromServer" on-error="_handleErrorFromServer" debounce-duration="300"></iron-ajax></template><script>
LicenseChecker = Polymer({
    is: "vaadin-license-checker",

    // simple global state to detect multiple instances
    instances: {},

    licenseDialog: undefined,

    licenseBox: undefined,

    notification: undefined,

    frameworkIdentifier: undefined,

    licenseTypes: {
        VALID: "valid",
        UNLICENSED: "unlicensed",
        TRIAL: "trial",
        EXPIRED: "expired"
    },

    properties: {
        licenseKey: {
            type: String,
            notify: true
        },
        licenseCheckTime: {
            type: Number
        },
        licenseKeyType: {
            type: String
        },
        licenseUrlBase: {
            type: String,
            value: "https://tools.vaadin.com/vaadin-license-server/licenses/"
        },
        licenseUrl: {
            type: String,
            computed: '_computeUrl(licenseUrlBase, licenseKey)'
        },
        productName: String,
        productVersion: Number,
        productCaption: String,
        storageKey: {
            type: String,
            computed: '_computeStorageKey(productName)'
        },
        storageKeyCheckTime: {
            type: String,
            computed: '_computeStorageKeyCheckTime(productName)'
        },
        storageKeyType: {
            type: String,
            computed: '_computeStorageKeyType(productName)'
        },
        _yesterday: {
            type: Number,
            value: function value() {
                var yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                return yesterday.getTime();
            },
            readOnly: true
        },
        _manualSubmit: {
            type: Boolean,
            value: false
        },
        licenseRequestHeaders: String
    },

    attached: function attached() {
        if (!this._exists(this.instances[this.storageKey])) {
            this.instances[this.storageKey] = this;

            if (this._isLocalhost()) {
                this.$.storageLicense.reload();
                if (this._exists(this.licenseKey)) {
                    this._checkLicenseKey();
                } else {
                    if (this.licenseCheckTime === undefined) {
                        this.licenseCheckTime = window.localStorage.getItem(this._computeStorageKeyCheckTime(this.productName));
                    }

                    if (this.licenseCheckTime === null || this.licenseCheckTime <= this._yesterday) {
                        this._showLicenseDialog(this.licenseTypes.UNLICENSED);
                    } else {
                        this._showLicenseBox(this.licenseTypes.UNLICENSED);
                    }
                }
            }
        }
    },

    detached: function detached() {
        if (this._existsAndAttached(this.licenseBox)) {
            this._removeFromParent(this.licenseBox);
            this.licenseBox = undefined;
        }
        if (this._existsAndAttached(this.licenseDialog)) {
            this._removeFromParent(this.licenseDialog);
            this.licenseDialog = undefined;
        }
        if (this._existsAndAttached(this.notification)) {
            this._removeFromParent(this.notification);
            this.notification = undefined;
        }

        if (this._existsAndAttached(this.frameworkIdentifier)) {
            this._removeFromParent(this.frameworkIdentifier);
            this.frameworkIdentifier = undefined;
        }

        if (this.instances[this.storageKey] === this) {
            this.instances[this.storageKey] = undefined;
        }
    },

    _removeFromParent: function _removeFromParent(node) {
        node.parentNode.removeChild(node);
    },

    _existsAndAttached: function _existsAndAttached(node) {
        return node && node.parentNode != undefined;
    },

    _checkLicenseKey: function _checkLicenseKey(key, manualSubmit) {
        if (arguments.length === 0) {
            //no-args call
            key = this.licenseKey;
        }

        var licenseUrl = this._computeUrl(this.licenseUrlBase, key);

        this._identifyFramework();
        this._setLicenseRequestHeaders();

        this.$.licenseRequest.url = licenseUrl;

        this._manualSubmit = !!manualSubmit;

        this.$.licenseRequest.generateRequest();
    },

    _computeUrl: function _computeUrl(licenseUrlBase, licenseKey) {
        return licenseUrlBase + licenseKey;
    },

    _handleErrorFromServer: function _handleErrorFromServer(event) {
        if (this._manualSubmit || this.licenseCheckTime == null || this.licenseCheckTime <= this._yesterday) {
            this._showLicenseDialog(this.licenseTypes.UNLICENSED);
            this.licenseKeyType = this.licenseTypes.UNLICENSED;
            this.licenseCheckTime = new Date().getTime();
        } else if (this.licenseKeyType !== this.licenseTypes.VALID) {
            // Show some licensebox
            this._showLicenseBox(this.licenseKeyType || this.licenseTypes.UNLICENSED);
        }

        this._fireLoadReadyEvent();
    },

    _handleResultFromServer: function _handleResultFromServer(event) {
        var response = event.detail;

        var result = response.response;

        //result is either invalid somehow, expired, evaluation or successful
        if (response.status != 200 || !this._isValidLicense(result.product.name, result.product.version)) {
            this._showLicenseDialog(this.licenseTypes.UNLICENSED);
            this.licenseKeyType = this.licenseTypes.UNLICENSED;
        } else {
            if (true === result.expired) {
                this.licenseKey = result.licenseKey;
                this._showLicenseBox(this.licenseTypes.EXPIRED);
                this.licenseKeyType = this.licenseTypes.EXPIRED;
            } else if ("evaluation" === result.type) {
                this.licenseKey = result.licenseKey;
                this._showLicenseBox(this.licenseTypes.TRIAL, result.expiredEpoch);
                this.licenseKeyType = this.licenseTypes.TRIAL;
            } else {
                //success
                if (this.licenseKey !== result.licenseKey) {
                    //user entered key to dialog
                    //show success notification and save value
                    this._showSuccessNotification();
                    this.licenseKey = result.licenseKey;
                }
                this.licenseKeyType = this.licenseTypes.VALID;
            }
        }

        this.licenseCheckTime = new Date().getTime();

        this._fireLoadReadyEvent();
    },

    _isLocalhost: function _isLocalhost() {
        var hostname = window.location.hostname;
        return hostname === "localhost" || hostname === "127.0.0.1";
    },

    _isValidLicense: function _isValidLicense(productName, productVersion) {
        return productName === this.productName && (productVersion == this.productVersion || !this._exists(productVersion));
    },

    _fireLoadReadyEvent: function _fireLoadReadyEvent() {
        this.fire("license-check-done");
    },

    _exists: function _exists(value) {
        return value !== null && value !== undefined && value !== "";
    },

    _computeStorageKey: function _computeStorageKey(productName) {
        return "vaadin." + productName + ".developer.license.key";
    },

    _computeStorageKeyCheckTime: function _computeStorageKeyCheckTime(productName) {
        return "vaadin." + productName + ".license.check.time";
    },

    _computeStorageKeyType: function _computeStorageKeyType(productName) {
        return "vaadin." + productName + ".license.key.type";
    },

    _licenseDialogClosed: function _licenseDialogClosed(event) {
        this._showLicenseBox(event.detail.type, event.detail.expiryEpoch);
        this.licenseCheckTime = new Date().getTime();
    },

    _licenseBoxClosed: function _licenseBoxClosed(event) {
        this._showLicenseDialog(event.detail.type, event.detail.expiryEpoch);
    },

    _licenseBoxSubmit: function _licenseBoxSubmit(event) {
        //check the key without saving it first
        this._checkLicenseKey(event.detail.licenseKey, true);
        this.licenseCheckTime = new Date().getTime();
    },

    _showLicenseDialog: function _showLicenseDialog(type, expiryEpoch) {
        if (!this.licenseDialog) {
            this.licenseDialog = new LicenseDialog();
            Polymer.dom(document.body).appendChild(this.licenseDialog);
            this.licenseDialog.addEventListener('vaadin-license-dialog-close', this._licenseDialogClosed.bind(this));
            this.licenseDialog.addEventListener('vaadin-license-dialog-submit', this._licenseBoxSubmit.bind(this));
        }

        this.licenseDialog.type = type;
        this.licenseDialog.productCaption = this.productCaption;

        if (type === this.licenseTypes.TRIAL) {
            this.licenseDialog.expiryEpoch = expiryEpoch;
        }

        this.licenseDialog.open();
    },

    _showLicenseBox: function _showLicenseBox(type, expiryEpoch) {
        if (!this.licenseBox) {
            this.licenseBox = new LicenseBox();
            Polymer.dom(document.body).appendChild(this.licenseBox);
            this.licenseBox.addEventListener('vaadin-license-box-close', this._licenseBoxClosed.bind(this));
        }

        this.licenseBox.type = type;
        this.licenseBox.productCaption = this.productCaption;

        if (type === this.licenseTypes.TRIAL) {
            this.licenseBox.expiryEpoch = expiryEpoch;
        }

        this.licenseBox.open();
    },

    _showSuccessNotification: function _showSuccessNotification() {
        if (!this.notification) {
            this.notification = new LicenseNotification();
            Polymer.dom(this.root).appendChild(this.notification);

            // Close success notification on click
            this.notification.addEventListener('click', this.notification.close);
        }

        this.notification.open();
    },

    _identifyFramework: function _identifyFramework() {
        if (!this.frameworkIdentifier) {
            this.frameworkIdentifier = new FrameworkIdentifier();
            Polymer.dom(this).appendChild(this.frameworkIdentifier);
        }
        this.frameworkIdentifier.setFrameWorkAndVersion();
    },

    _setLicenseRequestHeaders: function _setLicenseRequestHeaders() {
        this.licenseRequestHeaders = {
            "check-source": "webcomponent",
            "framework": this.frameworkIdentifier.framework,
            "version": this.frameworkIdentifier.version
        };
    }
});</script></dom-module><script>
var VaadinCharts = VaadinCharts || {};

/**
 * Behavior that provides functions to load JSON config from the node hierarchical structure.
 *
 * @polymerBehavior
 */
VaadinCharts.ConfigurationReaderBehavior = {

    /**
     * Elements that should be ignored when mapping
     **/
    _ignoredNodes: ["#text", "#comment", "data-series"],

    /**
     * List of words that will always be uppercased, instead of camel-cased
     **/
    _uppercaseWords: ["html"],

    /**
     * Elements that should be mapped in to an array, e.g. two x-axis elements would be mapped to the same
     * array
     **/
    _multivaluedNodes: ["xAxis", "yAxis", "plotBands", "plotLines", "background", "crosshairs", "stops", "levels", "pane", "items", "units"],

    /**
     * Elements that contain an array of values, either as a comma-separated list or multiple elements
     **/
    _arrayNodes: ["categories", "margin", "center", "units"],

    /**
     * Elements that contain two dimensional arrays. The values in value array can be specified using attributes and parser knows the correct order.
     **/
    _twoDimArrayNodes: { "stops": ["position", "color"] },

    /**
     * Elements whose text content should be set as text property value
     **/
    _textContentNodes: ["subtitle", "title"],

    /**
     * Elements where the whole node is going to be used as value, their name is always valid
     **/
    _nodeValueAttributes: ["table"],

    /**
     *  Name of the elements of the light DOM that need to be mapped when creating the JSON configuration
     **/
    _mappedKeywords: {
        "chart-area": "area",
        "stroke-width": "stroke-width",
        "chart-frame": "frame",
        "chart-style": "style",
        "chart-title": "title",
        "draw-on-series": "onSeries",
        "draw-on-key": "onKey"
    },

    /**
     * Transform the given string to camel-case
     *
     * @param {string} str
     **/
    _toCamelCase: function _toCamelCase(str) {
        var out = "";
        if (this._mappedKeywords.hasOwnProperty(str)) {
            out = this._mappedKeywords[str];
        } else if (this._nodeValueAttributes.indexOf(str) !== -1) {
            out = str;
        } else {
            str.split("-").forEach(function (word, idx) {
                var add = word.toLowerCase();
                //first word always goes in lower case, the rest go with camelCase, except for _uppercaseWords
                if (idx === 0 || this._uppercaseWords.indexOf(add) === -1) {
                    out += idx === 0 ? add : add[0].toUpperCase() + add.slice(1);
                } else {
                    out += word.toUpperCase();
                }
            }, this);
        }
        return out;
    },

    /**
     * Read configuration from one element and its attributes
     *
     * @param {object} dest the chart configuration object
     * @param {node} parent the node that is parsed for configuration
     **/
    _loadFromNode: function _loadFromNode(dest, node) {
        for (var i in node.attributes) {
            if (node.attributes.hasOwnProperty(i)) {
                var attr = node.attributes[i].name;
                if (attr !== undefined) {
                    var val = node.getAttribute(attr);
                    var res = this._parseAttribute(val);
                    dest[this._toCamelCase(attr)] = res;
                }
            }
        }
        if (this._hasOnlyTextContent(node)) {
            dest.text = node.textContent;
        }
    },

    /**
     * Removes all empty text and comment nodes.
     **/
    _cleanNode: function _cleanNode(node) {
        for (var n = 0; n < node.childNodes.length; n++) {
            var child = node.childNodes[n];
            if (child.nodeType === 3 && !/\S/.test(child.nodeValue)) {
                node.removeChild(child);
                n--;
            } else if (child.nodeType === 1) {
                this._cleanNode(child);
            }
        }
    },

    /**
     * Parse String attribute to most specific type possible.
     * Try JSON.parse, then eval if it's function, or return original value
     * @param {object} value to be set
     **/
    _parseAttribute: function _parseAttribute(val) {
        var res;
        try {
            res = JSON.parse(val);
        } catch (e) {
            if (this._evalJavascript(val)) {
                try {
                    res = eval('(' + val + ')');
                } catch (e) {
                    res = val;
                }
            } else {
                res = val;
            }
        }
        return res;
    },

    _evalJavascript: function _evalJavascript(val) {
        //if it's a function eval
        return val.indexOf('function') === 0;
    },

    /**
     * Return true if node has a single child with nodeType TEXT_NODE (3) and non-empty value.
     *
     * @param {node} the node to check
     **/
    _hasOnlyTextContent: function _hasOnlyTextContent(node) {
        return node.hasChildNodes() && node.childNodes.length == 1 && node.childNodes[0].nodeType == 3 && node.textContent.trim() != "";
    },

    /**
     * Returns a boolean value if text content is 'true' or 'false'. Otherwise, the return value is the text content itself.
     *
     * @param {node} the node to parse the text content
     **/
    _parseTextContent: function _parseTextContent(node) {
        try {
            return JSON.parse(node.textContent);
        } catch (e) {
            return node.textContent;
        }
    },

    /**
     * Recursively load the configuration from the light-DOM elements.
     *
     * @param {object} dest the chart configuration object
     * @param {node} parent the node that contains the configuration elements
     **/
    _loadConfiguration: function _loadConfiguration(dest, parent) {
        for (var n = 0; n < parent.childNodes.length; n++) {
            var node = parent.childNodes[n];
            var name = node.nodeName.toLowerCase();
            var camelName = this._toCamelCase(name);
            if (this._ignoredNodes.indexOf(name) === -1) {
                var result;

                //read configuration into result
                if (this._arrayNodes.indexOf(camelName) !== -1) {
                    result = [];
                    if (this._hasOnlyTextContent(node)) {
                        node.textContent.split(/\s*,\s*/).forEach(function (word) {
                            result.push(this._parseAttribute(word));
                        }, this);
                    } else {
                        for (var i = 0; i < node.childNodes.length; i++) {
                            var child = node.childNodes[i];
                            result.push(this._parseAttribute(child.textContent));
                        }
                    }
                    result = result.length > 1 ? result : result[0];
                } else if (this._twoDimArrayNodes.hasOwnProperty(name)) {
                    result = [];
                    if (this._hasOnlyTextContent(node)) {
                        node.textContent.split(/\s*,\s*/).forEach(function (word) {
                            result.push(this._parseAttribute(word));
                        }, this);
                    } else {
                        var values = this._twoDimArrayNodes[name];
                        for (var i = 0; i < values.length; ++i) {
                            var name = values[i];
                            var attr = this._parseAttribute(node.getAttribute(name));
                            if (attr != null) {
                                result.push(attr);
                            } else {
                                for (var j = 0; j < node.childNodes.length; j++) {
                                    var child = node.childNodes[j];
                                    if (name === child.nodeName.toLowerCase()) {
                                        result.push(this._parseAttribute(child.textContent));
                                    }
                                }
                            }
                        }
                    }
                } else if (this._nodeValueAttributes.indexOf(name) !== -1) {
                    result = node;
                } else if (this._multivaluedNodes.indexOf(camelName) !== -1 || dest[camelName] === undefined) {
                    if (this._textContentNodes.indexOf(camelName) === -1 && this._hasOnlyTextContent(node)) {
                        result = this._parseTextContent(node);
                    } else {
                        result = {};
                        this._loadFromNode(result, node);
                        this._loadConfiguration(result, node);
                    }
                }

                //put result in to the correct place
                if (this._multivaluedNodes.indexOf(camelName) !== -1) {
                    if (dest[camelName] === undefined) {
                        dest[camelName] = [result];
                    } else {
                        dest[camelName].push(result);
                    }
                } else if (dest[camelName] === undefined) {
                    dest[camelName] = result;
                }
            }
        }
    },

    /**
     * Creates the missing objects to ensure the path exists
     **/
    _ensureObjectStructure: function _ensureObjectStructure(obj, path) {
        var parts = path.split(".");
        for (var i = 0; i < parts.length; i++) {
            if (!obj[parts[i]]) obj[parts[i]] = {};
            obj = obj[parts[i]];
        }
    }
};</script><script>
/**
 * A series element for a chart element. Accepts data in various formats and can be updated
 * after creation. The updates are reflected on the parent chart.
 *
 * Cannot be used without a parent chart element.
 **/
DataSeries = Polymer({
    is: "data-series",
    behaviors: [VaadinCharts.ConfigurationReaderBehavior],

    properties: {

        /**
         * If this series is a  drilldown series
         */
        drilldown: {
            type: Boolean,
            value: false
        },

        /**
         * The data contents of this series as an array. Examples:
         * - [1,2,3]
         * - [[1,2],[1,3],[2,4]]
         * - [[Date.UTC(2013,5,2), 0.7695], [Date.UTC(2013,5,3), 0.7648]]
         **/
        data: {
            type: Array
        },

        /**
         * Initial chart configuration before initial rendering.
         **/
        _seriesConf: {
            type: Object,
            value: function value() {
                return {};
            }
        },

        /**
         * Index the series was given in the chart series array
         */
        _seriesIndex: Number,

        /**
         * MutatorObserver used to observe changes in data element
         */
        _observer: Object

    },

    observers: [
    //Observer called when data array is changed
    '_dataChanged(data.splices)'],

    /**
     * Reloads the series with the original configuration defined in elements and its attributes.
     */
    _reloadConfiguration: function _reloadConfiguration() {
        this._seriesConf = {};
        this._initConfiguration();
        if (!this._seriesConf.hasOwnProperty('data') && this.data) {
            this._seriesConf.data = this.data;
        }
        if (this.drilldown) {
            this._seriesIndex = this._parentChart()._addDrilldownSeries(this._seriesConf);
        } else {
            this._seriesIndex = this._parentChart()._addSeries(this._seriesConf);
        }
    },

    /**
     * Updates chart data when series data changes
     */
    _dataChanged: function _dataChanged() {
        if (this._seriesIndex != undefined && this._parentChart().isInitialized()) {
            this._updateChartData(this.data);
        } else {
            this._seriesConf['data'] = this.data;
        }
    },

    _updateChartData: function _updateChartData(newData) {
        if (this.drilldown) {
            this._parentChart().chart.drilldown.series[this._seriesIndex].setData(newData);
        } else {
            this._parentChart().chart.series[this._seriesIndex].setData(newData);
        }
    },

    _ignoredNodes: ["#text", "#comment", "data"],

    /**
     * Overrides behavior, for data-series all values should be evaluated as javascript
     **/
    _evalJavascript: function _evalJavascript(val) {
        // only eval when needed
        // functions, dates and arrays
        return val.indexOf('function') === 0 || val.indexOf('Date.UTC') === 0 || val.indexOf('[') === 0;
    },

    _parentChart: function _parentChart() {
        var parent = Polymer.dom(this.root).parentNode;
        while (parent._addSeries === undefined) {
            parent = parent.parentNode;
        }
        return parent;
    },

    /**
     * Load the configuration from the element attributes and the light-DOM elements.
     **/
    _loadData: function _loadData() {
        var element = Polymer.dom(this);

        for (var n = 0; n < element.childNodes.length; n++) {
            var node = element.childNodes[n];
            var name = node.nodeName.toLowerCase();
            var camelName = this._toCamelCase(name);
            if (camelName === 'data') {
                var value;
                if (this._hasPointNodes(node)) {
                    value = [];
                    for (var o = 0; o < node.childNodes.length; o++) {
                        if (this._isPointNode(node.childNodes[o])) {
                            value.push(this._parsePoint(node.childNodes[o]));
                        }
                    }
                } else {
                    // Replace line breaks as empty space.
                    var textContent = node.textContent.replace(/(\n)/gm, " ");
                    value = '[' + textContent + ']';
                }
                this._setProperty(camelName, value);
            }
        }
    },

    /**
     * Creates a point object from a point node.
     **/
    _parsePoint: function _parsePoint(pointNode) {
        var result = {};

        for (var n = 0; n < pointNode.childNodes.length; n++) {
            var node = pointNode.childNodes[n];
            if (this._hasOnlyTextContent(node)) {
                var camelName = this._toCamelCase(node.nodeName.toLowerCase());
                if ('date' === camelName) {
                    if (result['x'] === undefined) {
                        var parsedDate = this._parseDate(node.textContent);
                        if (parsedDate !== undefined) {
                            result['x'] = parsedDate;
                        } else {
                            console.log('Unable to parse date: ' + node.textContent);
                        }
                    } else {
                        console.log('x value is already defined for this point, \'' + node.textContent + '\' couldn\'t be set');
                    }
                } else if (result[camelName] === undefined) {
                    result[camelName] = this._parseAttribute(node.textContent);
                } else {
                    console.log(camelName + ' value is already defined for this point, \'' + node.textContent + '\' couldn\'t be set');
                }
            }
        }
        this._loadConfiguration(result, pointNode);

        return result;
    },

    _parseDate: function _parseDate(dateString) {
        if (this._isValidDate(dateString)) {
            return Date.parse(dateString);
        }
    },

    _isValidDate: function _isValidDate(dateString) {
        try {
            var dateValue = new Date(dateString);
            //If dateValue is invalid getTime is NaN
            return dateValue.toISOString().indexOf(dateString) === 0 && Object.prototype.toString.call(dateValue) === "[object Date]" && !isNaN(dateValue.getTime());
        } catch (e) {}

        return false;
    },

    /**
     * Checks if nodes has child nodes that correspond to points.
     **/
    _hasPointNodes: function _hasPointNodes(node) {
        var nodeChildrenArray = Array.prototype.slice.call(node.children, 0);
        return nodeChildrenArray.length > 0 && nodeChildrenArray.filter(this._isPointNode).length > 0;
    },

    /**
     * Checks if node is a point node.
     **/
    _isPointNode: function _isPointNode(node) {
        return node.nodeType === 1 && 'point' === node.nodeName.toLowerCase();
    },

    /**
     * Set single property in series configuration.
     * @param {string} name
     * @param {object} value to be set
     **/
    _setProperty: function _setProperty(name, value) {
        var parsedValue = this._parseAttribute(value);
        //if value is undefined it shouldn't be set to keep _seriesConf minimal
        if (undefined !== parsedValue) {
            if (undefined === this._seriesConf[name]) {
                this._seriesConf[name] = parsedValue;
            } else if (name === 'data') {
                Array.prototype.push.apply(this._seriesConf[name], parsedValue);
            }
        }
    },

    created: function created() {
        // Make sure that seriesConf is initialized
        this._seriesConf = this.properties._seriesConf.value();
    },

    // Kind of attached but attached is not called then the element is only in the light DOM
    _initialize: function _initialize() {
        this._initConfiguration();
        if (this.drilldown) {
            this._seriesIndex = this._parentChart()._addDrilldownSeries(this._seriesConf);
        } else {
            this._seriesIndex = this._parentChart()._addSeries(this._seriesConf);
        }
    },

    /**
     * Initializes the series json configuration.
     */
    _initConfiguration: function _initConfiguration() {
        var element = Polymer.dom(this);
        this._cleanNode(element);
        this._loadFromNode(this._seriesConf, element.node);
        this._loadConfiguration(this._seriesConf, element);
        this._loadData();
        this._addDataPointsObserver();
    },

    _addDataPointsObserver: function _addDataPointsObserver() {
        if (MutationObserver && !this._observer) {
            var dataElements = Polymer.dom(this).querySelectorAll('data');
            if (dataElements && dataElements.length > 0) {
                this._observer = new MutationObserver(this._reloadData.bind(this));
                for (var n = 0; n < dataElements.length; n++) {
                    this._observer.observe(dataElements[n], {
                        attributes: false,
                        childList: true,
                        characterData: true,
                        characterDataOldValue: false,
                        subtree: true
                    });
                }
            }
        }
    },

    _reloadData: function _reloadData() {
        this._seriesConf.data = [];
        this._loadData();
        this._updateChartData(this._seriesConf.data);
    }
});</script><script>
var VaadinCharts = VaadinCharts || {};

/**
 * Behavior that provides a function for loading the Valo theme for all charts.
 *
 * @polymerBehavior
 */
VaadinCharts.ValoThemeBehavior = {
    _loadTheme: function _loadTheme() {
        Highcharts.setOptions({
            "colors": ["#3090F0", "#EC6464", "#98DF58", "#F9DD51", "#24DCD4", "#EC64A5", "#685CB0", "#FF7D42", "#336190", "#AA514D", "#7FB053", "#BBA85B", "#247981", "#963970", "#4B56A8", "#9A593D"],
            "chart": {
                "backgroundColor": "#FFFFFF",
                "plotBackgroundColor": "rgba(255,255,255,0.00)",
                "plotBackgroundImage": "",
                "plotShadow": false,
                "plotBorderWidth": 0,
                "plotBorderColor": "rgba(255,255,255,0.00)",
                "className": "vaadin-chart",
                "borderRadius": 0,
                "style": {
                    "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                    "fontSize": "14px"
                }
            },
            "title": {
                "style": {
                    "color": "#197DE1",
                    "fontWeight": "normal",
                    "fontSize": "26px"
                }
            },
            "subtitle": {
                "style": {
                    "color": "#808080",
                    "fontWeight": "normal",
                    "fontSize": "14px"
                }
            },
            "xAxis": {
                "lineColor": "#FAFAFA",
                "lineWidth": 0,
                "tickWidth": 0,
                "tickColor": "#C0D0E0",
                "gridLineColor": "#DFDFDF",
                "gridLineWidth": 0,
                "alternateGridColor": "rgba(255,255,255,0.00)",
                "title": {
                    "style": {
                        "color": "#808080",
                        "fontWeight": "normal"
                    }
                },
                "subtitle": {
                    "style": {
                        "color": "#808080",
                        "fontWeight": "normal",
                        "fontSize": "14px"
                    }
                },
                "labels": {
                    "style": {
                        "color": "#808080",
                        "fontWeight": "normal",
                        "fontSize": "14px"
                    }
                }
            },
            "yAxis": {
                "minorTickInterval": "",
                "lineColor": "#FAFAFA",
                "lineWidth": 0,
                "tickWidth": 0,
                "tickColor": "#C0D0E0",
                "gridLineColor": "#DFDFDF",
                "gridLineWidth": 1,
                "alternateGridColor": "rgba(255,255,255,0.00)",
                "title": {
                    "style": {
                        "color": "#808080",
                        "fontWeight": "normal"
                    }
                },
                "subtitle": {
                    "style": {
                        "color": "#808080",
                        "fontWeight": "normal",
                        "fontSize": "14px"
                    }
                },
                "labels": {
                    "style": {
                        "color": "#808080",
                        "fontWeight": "normal",
                        "fontSize": "14px"
                    }
                }
            },
            "labels": {
                "style": {
                    "color": "#808080"
                }
            },
            "legend": {
                "borderColor": "#DFDFDF",
                "borderRadius": 5,
                "backgroundColor": "rgba(255,255,255,0.90)",
                "itemStyle": {
                    "color": "#808080",
                    "fontWeight": "normal",
                    "fontSize": "14px"
                },
                "itemHoverStyle": {
                    "color": "#808080"
                },
                "itemHiddenStyle": {
                    "color": "#808080"
                }
            },
            "tooltip": {
                "backgroundColor": "#FFFFFF",
                "borderWidth": 0,
                "borderRadius": 5,
                "followPointer": false,
                "style": {
                    "color": "#333333"
                }
            },
            "plotOptions": {
                "bar": {
                    "pointPadding": 0,
                    "borderWidth": 0,
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                },
                "area": {
                    "shadow": false
                },
                "arearange": {
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                },
                "areaspline": {},
                "areasplinerange": {
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                },
                "pie": {
                    "borderWidth": 0,
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    },
                    "states": {
                        "hover": {
                            "enabled": false
                        }
                    }
                },
                "line": {
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                },
                "column": {
                    "pointPadding": 0,
                    "borderWidth": 0,
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                },
                "spline": {
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                },
                "series": {},
                "pyramid": {
                    "borderWidth": 0,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                },
                "waterfall": {
                    "borderWidth": 0,
                    "shadow": false,
                    "dataLabels": {
                        "style": {
                            "fontFamily": "Open Sans, Helvetica Neue, Arial, sans-serif",
                            "fontSize": "12px"
                        },
                        "color": "#808080"
                    }
                }
            },
            "credits": {
                "text": "",
                "href": "",
                "style": {
                    "color": "#808080",
                    "fontSize": "14px"
                }
            }
        });
    }
};</script><script></script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highstock JS v4.2.6 (2016-08-02)

 (c) 2009-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (M, ja) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = M.document ? ja(M) : ja : M.Highcharts = ja(M);
})(typeof window !== "undefined" ? window : this, function (M) {
  function ja(a, b) {
    var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a;if (b) throw Error(c);M.console && console.log(c);
  }function Ab(a, b, c) {
    this.options = b;this.elem = a;this.prop = c;
  }function D() {
    var a,
        b = arguments,
        c,
        d = {},
        e = function e(a, b) {
      var c, d;(typeof a === "undefined" ? "undefined" : _typeof(a)) !== "object" && (a = {});for (d in b) {
        b.hasOwnProperty(d) && (c = b[d], a[d] = c && (typeof c === "undefined" ? "undefined" : _typeof(c)) === "object" && Object.prototype.toString.call(c) !== "[object Array]" && d !== "renderTo" && typeof c.nodeType !== "number" ? e(a[d] || {}, c) : b[d]);
      }return a;
    };b[0] === !0 && (d = b[1], b = Array.prototype.slice.call(b, 2));c = b.length;for (a = 0; a < c; a++) {
      d = e(d, b[a]);
    }return d;
  }function H(a, b) {
    return parseInt(a, b || 10);
  }function Ea(a) {
    return typeof a === "string";
  }function Ra(a) {
    return Object.prototype.toString.call(a) === "[object Array]";
  }function Ba(a, b) {
    for (var c = a.length; c--;) {
      if (a[c] === b) {
        a.splice(c, 1);break;
      }
    }
  }function t(a) {
    return a !== x && a !== null;
  }
  function $(a, b, c) {
    var d, e;if (Ea(b)) t(c) ? a.setAttribute(b, c) : a && a.getAttribute && (e = a.getAttribute(b));else if (t(b) && ha(b)) for (d in b) {
      a.setAttribute(d, b[d]);
    }return e;
  }function sa(a) {
    return Ra(a) ? a : [a];
  }function bb(a, b, c) {
    if (b) return setTimeout(a, b, c);a.call(0, c);
  }function O(a, b) {
    if (La && !ma && b && b.opacity !== x) b.filter = "alpha(opacity=" + b.opacity * 100 + ")";v(a.style, b);
  }function ia(a, b, c, d, e) {
    a = C.createElement(a);b && v(a, b);e && O(a, { padding: 0, border: "none", margin: 0 });c && O(a, c);d && d.appendChild(a);return a;
  }function oa(a, b) {
    var c = function c() {};c.prototype = new a();v(c.prototype, b);return c;
  }function Sa(a, b, c) {
    return Array((b || 2) + 1 - String(a).length).join(c || 0) + a;
  }function gb(a) {
    return (hb && hb(a) || Bb || 0) * 6E4;
  }function Ma(a, b) {
    for (var c = "{", d = !1, e, f, g, h, i, j = []; (c = a.indexOf(c)) !== -1;) {
      e = a.slice(0, c);if (d) {
        f = e.split(":");g = f.shift().split(".");i = g.length;e = b;for (h = 0; h < i; h++) {
          e = e[g[h]];
        }if (f.length) f = f.join(":"), g = /\.([0-9])/, h = Q.lang, i = void 0, /f$/.test(f) ? (i = (i = f.match(g)) ? i[1] : -1, e !== null && (e = B.numberFormat(e, i, h.decimalPoint, f.indexOf(",") > -1 ? h.thousandsSep : ""))) : e = pa(f, e);
      }j.push(e);a = a.slice(c + 1);c = (d = !d) ? "}" : "{";
    }j.push(a);return j.join("");
  }function Cb(a) {
    return aa.pow(10, Y(aa.log(a) / aa.LN10));
  }function Db(a, b, c, d, e) {
    var f,
        g = a,
        c = q(c, 1);f = a / c;b || (b = [1, 2, 2.5, 5, 10], d === !1 && (c === 1 ? b = [1, 2, 5, 10] : c <= 0.1 && (b = [1 / c])));for (d = 0; d < b.length; d++) {
      if (g = b[d], e && g * c >= a || !e && f <= (b[d] + (b[d + 1] || b[d])) / 2) break;
    }g *= c;return g;
  }function pb(a, b) {
    var c = a.length,
        d,
        e;for (e = 0; e < c; e++) {
      a[e].safeI = e;
    }a.sort(function (a, c) {
      d = b(a, c);return d === 0 ? a.safeI - c.safeI : d;
    });for (e = 0; e < c; e++) {
      delete a[e].safeI;
    }
  }function Na(a) {
    for (var b = a.length, c = a[0]; b--;) {
      a[b] < c && (c = a[b]);
    }return c;
  }function Fa(a) {
    for (var b = a.length, c = a[0]; b--;) {
      a[b] > c && (c = a[b]);
    }return c;
  }function Oa(a, b) {
    for (var c in a) {
      a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c];
    }
  }function Wa(a) {
    qb || (qb = ia(Xa));a && qb.appendChild(a);qb.innerHTML = "";
  }function V(a, b) {
    return parseFloat(a.toPrecision(b || 14));
  }function cb(a, b) {
    b.renderer.globalAnimation = q(a, b.animation);
  }function ib(a) {
    return ha(a) ? D(a) : { duration: a ? 500 : 0 };
  }function Qb() {
    var a = Q.global,
        b = a.useUTC,
        c = b ? "getUTC" : "get",
        d = b ? "setUTC" : "set";ea = a.Date || M.Date;Bb = b && a.timezoneOffset;hb = b && a.getTimezoneOffset;rb = function rb(a, c, d, h, i, j) {
      var k;b ? (k = ea.UTC.apply(0, arguments), k += gb(k)) : k = new ea(a, c, q(d, 1), q(h, 0), q(i, 0), q(j, 0)).getTime();return k;
    };Eb = c + "Minutes";Fb = c + "Hours";Gb = c + "Day";db = c + "Date";jb = c + "Month";kb = c + "FullYear";Rb = d + "Milliseconds";Sb = d + "Seconds";Tb = d + "Minutes";Ub = d + "Hours";sb = d + "Date";Hb = d + "Month";Ib = d + "FullYear";
  }function xa(a) {
    if (!(this instanceof xa)) return new xa(a);this.init(a);
  }function ba() {}function eb(a, b, c, d) {
    this.axis = a;this.pos = b;this.type = c || "";this.isNew = !0;!c && !d && this.addLabel();
  }function Vb(a, b, c, d, e) {
    var f = a.chart.inverted;this.axis = a;this.isNegative = c;this.options = b;this.x = d;this.total = null;this.points = {};this.stack = e;this.rightCliff = this.leftCliff = 0;this.alignOptions = { align: b.align || (f ? c ? "left" : "right" : "center"), verticalAlign: b.verticalAlign || (f ? "middle" : c ? "bottom" : "top"), y: q(b.y, f ? 4 : c ? 14 : -6), x: q(b.x, f ? c ? -6 : 6 : 0) };this.textAlign = b.textAlign || (f ? c ? "right" : "left" : "center");
  }function tb(a, b, c) {
    this.scrollbarButtons = [];this.renderer = a;this.userOptions = b;this.options = D(Wb, b);this.chart = c;this.size = q(this.options.size, this.options.height);this.render();this.initEvents();this.addEvents();
  }function Jb(a) {
    var b = a.options,
        c = b.navigator,
        d = c.enabled,
        e = b.scrollbar,
        b = e.enabled,
        f = d ? c.height : 0,
        e = b ? e.height : 0;this.handles = [];this.elementsToDestroy = [];this.chart = a;this.setBaseSeries();this.height = f;this.scrollbarHeight = e;this.scrollbarEnabled = b;this.navigatorEnabled = d;this.navigatorOptions = c;this.outlineHeight = f + e;this.init();
  }function Kb(a) {
    this.init(a);
  }var x,
      C = M.document,
      aa = Math,
      A = aa.round,
      Y = aa.floor,
      Ga = aa.ceil,
      y = aa.max,
      E = aa.min,
      T = aa.abs,
      fa = aa.cos,
      na = aa.sin,
      Ca = aa.PI,
      ta = Ca * 2 / 360,
      Pa = M.navigator && M.navigator.userAgent || "",
      Xb = M.opera,
      La = /(msie|trident|edge)/i.test(Pa) && !Xb,
      ub = C && C.documentMode === 8,
      vb = !La && /AppleWebKit/.test(Pa),
      Ya = /Firefox/.test(Pa),
      lb = /(Mobile|Android|Windows Phone)/.test(Pa),
      Ta = "http://www.w3.org/2000/svg",
      ma = C && C.createElementNS && !!C.createElementNS(Ta, "svg").createSVGRect,
      bc = Ya && parseInt(Pa.split("Firefox/")[1], 10) < 4,
      ua = C && !ma && !La && !!C.createElement("canvas").getContext,
      Za,
      $a,
      Yb = {},
      Lb = 0,
      qb,
      Q,
      pa,
      N,
      va = function va() {},
      ca = [],
      mb = 0,
      Xa = "div",
      W = "M",
      R = "L",
      cc = /^[0-9]+$/,
      wb = ["plotTop", "marginRight", "marginBottom", "plotLeft"],
      ea,
      rb,
      Bb,
      hb,
      Eb,
      Fb,
      Gb,
      db,
      jb,
      kb,
      Rb,
      Sb,
      Tb,
      Ub,
      sb,
      Hb,
      Ib,
      I = {},
      B;B = M.Highcharts ? ja(16, !0) : { win: M };B.seriesTypes = I;var Ua = [],
      _ya2,
      qa,
      o,
      Ha,
      Mb,
      wa,
      G,
      U,
      K,
      fb,
      Qa;Ab.prototype = { dSetter: function dSetter() {
      var a = this.paths[0],
          b = this.paths[1],
          c = [],
          d = this.now,
          e = a.length,
          f;if (d === 1) c = this.toD;else if (e === b.length && d < 1) for (; e--;) {
        f = parseFloat(a[e]), c[e] = isNaN(f) ? a[e] : d * parseFloat(b[e] - f) + f;
      } else c = b;this.elem.attr("d", c);
    }, update: function update() {
      var a = this.elem,
          b = this.prop,
          c = this.now,
          d = this.options.step;if (this[b + "Setter"]) this[b + "Setter"]();else a.attr ? a.element && a.attr(b, c) : a.style[b] = c + this.unit;d && d.call(a, c, this);
    }, run: function run(a, b, c) {
      var d = this,
          e = function e(a) {
        return e.stopped ? !1 : d.step(a);
      },
          f;this.startTime = +new ea();this.start = a;this.end = b;this.unit = c;this.now = this.start;this.pos = 0;e.elem = this.elem;if (e() && Ua.push(e) === 1) e.timerId = setInterval(function () {
        for (f = 0; f < Ua.length; f++) {
          Ua[f]() || Ua.splice(f--, 1);
        }Ua.length || clearInterval(e.timerId);
      }, 13);
    }, step: function step(a) {
      var b = +new ea(),
          c,
          d = this.options;c = this.elem;var e = d.complete,
          f = d.duration,
          g = d.curAnim,
          h;if (c.attr && !c.element) c = !1;else if (a || b >= f + this.startTime) {
        this.now = this.end;this.pos = 1;this.update();a = g[this.prop] = !0;for (h in g) {
          g[h] !== !0 && (a = !1);
        }a && e && e.call(c);c = !1;
      } else this.pos = d.easing((b - this.startTime) / f), this.now = this.start + (this.end - this.start) * this.pos, this.update(), c = !0;return c;
    }, initPath: function initPath(a, b, c) {
      function d(a) {
        for (n = a.length; n--;) {
          (a[n] === W || a[n] === R) && a.splice(n + 1, 0, a[n + 1], a[n + 2], a[n + 1], a[n + 2]);
        }
      }function e(a, b) {
        for (; a.length < l;) {
          a[0] = b[l - a.length];var c = a.slice(0, k);[].splice.apply(a, [0, 0].concat(c));p && (c = a.slice(a.length - k), [].splice.apply(a, [a.length, 0].concat(c)), n--);
        }a[0] = "M";
      }function f(a, b) {
        for (var c = (l - a.length) / k; c > 0 && c--;) {
          m = a.slice().splice(a.length / r - k, k * r), m[0] = b[l - k - c * k], j && (m[k - 6] = m[k - 2], m[k - 5] = m[k - 1]), [].splice.apply(a, [a.length / r, 0].concat(m)), p && c--;
        }
      }var b = b || "",
          g,
          h = a.startX,
          i = a.endX,
          j = b.indexOf("C") > -1,
          k = j ? 7 : 3,
          l,
          m,
          n,
          b = b.split(" "),
          c = c.slice(),
          p = a.isArea,
          r = p ? 2 : 1,
          s;j && (d(b), d(c));if (h && i) {
        for (n = 0; n < h.length; n++) {
          if (h[n] === i[0]) {
            g = n;break;
          } else if (h[0] === i[i.length - h.length + n]) {
            g = n;s = !0;break;
          }
        }g === void 0 && (b = []);
      }b.length && B.isNumber(g) && (l = c.length + g * r * k, s ? (e(b, c), f(c, b)) : (e(c, b), f(b, c)));return [b, c];
    } };var v = B.extend = function (a, b) {
    var c;a || (a = {});for (c in b) {
      a[c] = b[c];
    }return a;
  },
      ha = B.isObject = function (a, b) {
    return a && (typeof a === "undefined" ? "undefined" : _typeof(a)) === "object" && (!b || !Ra(a));
  },
      z = B.isNumber = function (a) {
    return typeof a === "number" && !isNaN(a);
  },
      q = B.pick = function () {
    var a = arguments,
        b,
        c,
        d = a.length;for (b = 0; b < d; b++) {
      if (c = a[b], c !== x && c !== null) return c;
    }
  },
      S = B.wrap = function (a, b, c) {
    var d = a[b];a[b] = function () {
      var a = Array.prototype.slice.call(arguments);a.unshift(d);return c.apply(this, a);
    };
  };pa = function pa(a, b, c) {
    if (!t(b) || isNaN(b)) return Q.lang.invalidDate || "";var a = q(a, "%Y-%m-%d %H:%M:%S"),
        d = new ea(b - gb(b)),
        e,
        f = d[Fb](),
        g = d[Gb](),
        h = d[db](),
        i = d[jb](),
        j = d[kb](),
        k = Q.lang,
        l = k.weekdays,
        m = k.shortWeekdays,
        d = v({ a: m ? m[g] : l[g].substr(0, 3), A: l[g], d: Sa(h), e: Sa(h, 2, " "), w: g, b: k.shortMonths[i], B: k.months[i], m: Sa(i + 1), y: j.toString().substr(2, 2), Y: j, H: Sa(f), k: f, I: Sa(f % 12 || 12), l: f % 12 || 12, M: Sa(d[Eb]()), p: f < 12 ? "AM" : "PM", P: f < 12 ? "am" : "pm", S: Sa(d.getSeconds()), L: Sa(A(b % 1E3), 3) }, B.dateFormats);for (e in d) {
      for (; a.indexOf("%" + e) !== -1;) {
        a = a.replace("%" + e, typeof d[e] === "function" ? d[e](b) : d[e]);
      }
    }return c ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;
  };N = { millisecond: 1, second: 1E3, minute: 6E4, hour: 36E5, day: 864E5, week: 6048E5, month: 24192E5, year: 314496E5 };B.numberFormat = function (a, b, c, d) {
    var a = +a || 0,
        b = +b,
        e = Q.lang,
        f = (a.toString().split(".")[1] || "").length,
        g,
        h,
        i = Math.abs(a);b === -1 ? b = Math.min(f, 20) : z(b) || (b = 2);g = String(H(i.toFixed(b)));h = g.length > 3 ? g.length % 3 : 0;c = q(c, e.decimalPoint);d = q(d, e.thousandsSep);a = a < 0 ? "-" : "";a += h ? g.substr(0, h) + d : "";a += g.substr(h).replace(/(\d{3})(?=\d)/g, "$1" + d);b && (d = Math.abs(i - g + Math.pow(10, -Math.max(b, f) - 1)), a += c + d.toFixed(b).slice(2));return a;
  };Math.easeInOutSine = function (a) {
    return -0.5 * (Math.cos(Math.PI * a) - 1);
  };_ya2 = function ya(a, b) {
    var c;if (b === "width") return Math.min(a.offsetWidth, a.scrollWidth) - _ya2(a, "padding-left") - _ya2(a, "padding-right");else if (b === "height") return Math.min(a.offsetHeight, a.scrollHeight) - _ya2(a, "padding-top") - _ya2(a, "padding-bottom");return (c = M.getComputedStyle(a, void 0)) && H(c.getPropertyValue(b));
  };qa = function qa(a, b) {
    return b.indexOf ? b.indexOf(a) : [].indexOf.call(b, a);
  };Ha = function Ha(a, b) {
    return [].filter.call(a, b);
  };wa = function wa(a, b) {
    for (var c = [], d = 0, e = a.length; d < e; d++) {
      c[d] = b.call(a[d], a[d], d, a);
    }return c;
  };Mb = function Mb(a) {
    var b = C.documentElement,
        a = a.getBoundingClientRect();return { top: a.top + (M.pageYOffset || b.scrollTop) - (b.clientTop || 0), left: a.left + (M.pageXOffset || b.scrollLeft) - (b.clientLeft || 0) };
  };Qa = function Qa(a) {
    for (var b = Ua.length; b--;) {
      if (Ua[b].elem === a) Ua[b].stopped = !0;
    }
  };o = function o(a, b) {
    return Array.prototype.forEach.call(a, b);
  };G = function G(a, b, c) {
    function d(b) {
      b.target = b.srcElement || M;c.call(a, b);
    }var e = a.hcEvents = a.hcEvents || {};if (a.addEventListener) a.addEventListener(b, c, !1);else if (a.attachEvent) {
      if (!a.hcEventsIE) a.hcEventsIE = {};a.hcEventsIE[c.toString()] = d;a.attachEvent("on" + b, d);
    }e[b] || (e[b] = []);e[b].push(c);
  };U = function U(a, b, c) {
    function d(b, c) {
      a.removeEventListener ? a.removeEventListener(b, c, !1) : a.attachEvent && (c = a.hcEventsIE[c.toString()], a.detachEvent("on" + b, c));
    }function e() {
      var c, e, f;if (a.nodeName) for (f in b ? (c = {}, c[b] = !0) : c = g, c) {
        if (g[f]) for (e = g[f].length; e--;) {
          d(f, g[f][e]);
        }
      }
    }var f,
        g = a.hcEvents,
        h;if (g) b ? (f = g[b] || [], c ? (h = qa(c, f), h > -1 && (f.splice(h, 1), g[b] = f), d(b, c)) : (e(), g[b] = [])) : (e(), a.hcEvents = {});
  };K = function K(a, b, c, d) {
    var e;e = a.hcEvents;var f,
        g,
        c = c || {};if (C.createEvent && (a.dispatchEvent || a.fireEvent)) e = C.createEvent("Events"), e.initEvent(b, !0, !0), e.target = a, v(e, c), a.dispatchEvent ? a.dispatchEvent(e) : a.fireEvent(b, e);else if (e) {
      e = e[b] || [];f = e.length;if (!c.preventDefault) c.preventDefault = function () {
        c.defaultPrevented = !0;
      };c.target = a;if (!c.type) c.type = b;for (b = 0; b < f; b++) {
        (g = e[b]) && g.call(a, c) === !1 && c.preventDefault();
      }
    }d && !c.defaultPrevented && d(c);
  };fb = function fb(a, b, c) {
    var d,
        e = "",
        f,
        g,
        h;ha(c) || (d = arguments, c = { duration: d[2], easing: d[3], complete: d[4] });if (!z(c.duration)) c.duration = 400;c.easing = typeof c.easing === "function" ? c.easing : Math[c.easing] || Math.easeInOutSine;c.curAnim = D(b);for (h in b) {
      g = new Ab(a, c, h), f = null, h === "d" ? (g.paths = g.initPath(a, a.d, b.d), g.toD = b.d, d = 0, f = 1) : a.attr ? d = a.attr(h) : (d = parseFloat(_ya2(a, h)) || 0, h !== "opacity" && (e = "px")), f || (f = b[h]), f.match && f.match("px") && (f = f.replace(/px/g, "")), g.run(d, f, e);
    }
  };if (M.jQuery) M.jQuery.fn.highcharts = function () {
    var a = [].slice.call(arguments);if (this[0]) return a[0] ? (new B[Ea(a[0]) ? a.shift() : "Chart"](this[0], a[0], a[1]), this) : ca[$(this[0], "data-highcharts-chart")];
  };C && !C.defaultView && (_ya2 = function _ya(a, b) {
    var c;c = { width: "clientWidth", height: "clientHeight" }[b];if (a.style[b]) return H(a.style[b]);b === "opacity" && (b = "filter");if (c) return a.style.zoom = 1, Math.max(a[c] - 2 * _ya2(a, "padding"), 0);c = a.currentStyle[b.replace(/\-(\w)/g, function (a, b) {
      return b.toUpperCase();
    })];b === "filter" && (c = c.replace(/alpha\(opacity=([0-9]+)\)/, function (a, b) {
      return b / 100;
    }));return c === "" ? 1 : H(c);
  });Array.prototype.forEach || (o = function o(a, b) {
    for (var c = 0, d = a.length; c < d; c++) {
      if (b.call(a[c], a[c], c, a) === !1) return c;
    }
  });Array.prototype.indexOf || (qa = function qa(a, b) {
    var c,
        d = 0;if (b) for (c = b.length; d < c; d++) {
      if (b[d] === a) return d;
    }return -1;
  });Array.prototype.filter || (Ha = function Ha(a, b) {
    for (var c = [], d = 0, e = a.length; d < e; d++) {
      b(a[d], d) && c.push(a[d]);
    }return c;
  });B.Fx = Ab;B.inArray = qa;B.each = o;B.grep = Ha;B.offset = Mb;B.map = wa;B.addEvent = G;B.removeEvent = U;B.fireEvent = K;B.animate = fb;B.animObject = ib;B.stop = Qa;Q = { colors: "#7cb5ec,#434348,#90ed7d,#f7a35c,#8085e9,#f15c80,#e4d354,#2b908f,#f45b5b,#91e8e1".split(","), symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","), shortMonths: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), decimalPoint: ".", numericSymbols: "k,M,G,T,P,E".split(","),
      resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: { useUTC: !0, canvasToolsURL: "http://code.highcharts.com/modules/canvas-tools.js", VMLRadialGradientURL: "http://code.highcharts.com/stock/4.2.6/gfx/vml-radial-gradient.png" }, chart: { borderColor: "#4572A7", borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], backgroundColor: "#FFFFFF", plotBorderColor: "#C0C0C0", resetZoomButton: { theme: { zIndex: 20 }, position: { align: "right", x: -10, y: 10 } }, width: null,
      height: null }, title: { text: "Chart title", align: "center", margin: 15, style: { color: "#333333", fontSize: "18px" }, widthAdjust: -44 }, subtitle: { text: "", align: "center", style: { color: "#555555" }, widthAdjust: -44 }, plotOptions: { line: { allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1E3 }, events: {}, lineWidth: 2, marker: { lineWidth: 0, radius: 4, lineColor: "#FFFFFF", states: { hover: { enabled: !0, lineWidthPlus: 1, radiusPlus: 2 }, select: { fillColor: "#FFFFFF", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { align: "center",
          formatter: function formatter() {
            return this.y === null ? "" : B.numberFormat(this.y, -1);
          }, style: { color: "contrast", fontSize: "11px", fontWeight: "bold", textShadow: "0 0 6px contrast, 0 0 3px contrast" }, verticalAlign: "bottom", x: 0, y: 0, padding: 5 }, cropThreshold: 300, pointRange: 0, softThreshold: !0, states: { hover: { lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } }, select: { marker: {} } }, stickyTracking: !0, turboThreshold: 1E3 } }, labels: { style: { position: "absolute", color: "#3E576F" } }, legend: { enabled: !0, align: "center", layout: "horizontal",
      labelFormatter: function labelFormatter() {
        return this.name;
      }, borderColor: "#909090", borderRadius: 0, navigation: { activeColor: "#274b6d", inactiveColor: "#CCC" }, shadow: !1, itemStyle: { color: "#333333", fontSize: "12px", fontWeight: "bold" }, itemHoverStyle: { color: "#000" }, itemHiddenStyle: { color: "#CCC" }, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute",
        backgroundColor: "white", opacity: 0.5, textAlign: "center" } }, tooltip: { enabled: !0, animation: ma, backgroundColor: "rgba(249, 249, 249, .85)", borderWidth: 1, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" }, footerFormat: "", headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>', pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
      shadow: !0, snap: lb ? 25 : 10, style: { color: "#333333", cursor: "default", fontSize: "12px", padding: "8px", pointerEvents: "none", whiteSpace: "nowrap" } }, credits: { enabled: !0, text: "Highcharts.com", href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#909090", fontSize: "9px" } } };var X = Q.plotOptions,
      ga = X.line;Qb();xa.prototype = { parsers: [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function parse(a) {
        return [H(a[1]), H(a[2]), H(a[3]), parseFloat(a[4], 10)];
      } }, { regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, parse: function parse(a) {
        return [H(a[1], 16), H(a[2], 16), H(a[3], 16), 1];
      } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function parse(a) {
        return [H(a[1]), H(a[2]), H(a[3]), 1];
      } }], init: function init(a) {
      var b, c, d, e;if ((this.input = a) && a.stops) this.stops = wa(a.stops, function (a) {
        return new xa(a[1]);
      });else for (d = this.parsers.length; d-- && !c;) {
        e = this.parsers[d], (b = e.regex.exec(a)) && (c = e.parse(b));
      }this.rgba = c || [];
    }, get: function get(a) {
      var b = this.input,
          c = this.rgba,
          d;this.stops ? (d = D(b), d.stops = [].concat(d.stops), o(this.stops, function (b, c) {
        d.stops[c] = [d.stops[c][0], b.get(a)];
      })) : d = c && z(c[0]) ? a === "rgb" || !a && c[3] === 1 ? "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")" : a === "a" ? c[3] : "rgba(" + c.join(",") + ")" : b;return d;
    }, brighten: function brighten(a) {
      var b,
          c = this.rgba;if (this.stops) o(this.stops, function (b) {
        b.brighten(a);
      });else if (z(a) && a !== 0) for (b = 0; b < 3; b++) {
        c[b] += H(a * 255), c[b] < 0 && (c[b] = 0), c[b] > 255 && (c[b] = 255);
      }return this;
    }, setOpacity: function setOpacity(a) {
      this.rgba[3] = a;return this;
    } };ba.prototype = { opacity: 1, textProps: "direction,fontSize,fontWeight,fontFamily,fontStyle,color,lineHeight,width,textDecoration,textOverflow,textShadow".split(","), init: function init(a, b) {
      this.element = b === "span" ? ia(b) : C.createElementNS(Ta, b);this.renderer = a;
    }, animate: function animate(a, b, c) {
      b = q(b, this.renderer.globalAnimation, !0);Qa(this);if (b) {
        if (c) b.complete = c;fb(this, a, b);
      } else this.attr(a, null, c);return this;
    }, colorGradient: function colorGradient(a, b, c) {
      var d = this.renderer,
          e,
          f,
          g,
          h,
          i,
          j,
          k,
          l,
          m,
          n,
          p,
          r = [],
          s;a.linearGradient ? f = "linearGradient" : a.radialGradient && (f = "radialGradient");if (f) {
        g = a[f];i = d.gradients;k = a.stops;n = c.radialReference;Ra(g) && (a[f] = g = { x1: g[0], y1: g[1], x2: g[2], y2: g[3], gradientUnits: "userSpaceOnUse" });f === "radialGradient" && n && !t(g.gradientUnits) && (h = g, g = D(g, d.getRadialAttr(n, h), { gradientUnits: "userSpaceOnUse" }));for (p in g) {
          p !== "id" && r.push(p, g[p]);
        }for (p in k) {
          r.push(k[p]);
        }r = r.join(",");i[r] ? n = i[r].attr("id") : (g.id = n = "highcharts-" + Lb++, i[r] = j = d.createElement(f).attr(g).add(d.defs), j.radAttr = h, j.stops = [], o(k, function (a) {
          a[1].indexOf("rgba") === 0 ? (e = xa(a[1]), l = e.get("rgb"), m = e.get("a")) : (l = a[1], m = 1);a = d.createElement("stop").attr({ offset: a[0], "stop-color": l, "stop-opacity": m }).add(j);j.stops.push(a);
        }));s = "url(" + d.url + "#" + n + ")";c.setAttribute(b, s);c.gradient = r;a.toString = function () {
          return s;
        };
      }
    }, applyTextShadow: function applyTextShadow(a) {
      var b = this.element,
          c,
          d = a.indexOf("contrast") !== -1,
          e = {},
          f = this.renderer.forExport,
          g = f || b.style.textShadow !== x && !La;if (d) e.textShadow = a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill));
      if (vb || f) e.textRendering = "geometricPrecision";g ? this.css(e) : (this.fakeTS = !0, this.ySetter = this.xSetter, c = [].slice.call(b.getElementsByTagName("tspan")), o(a.split(/\s?,\s?/g), function (a) {
        var d = b.firstChild,
            e,
            f,
            a = a.split(" ");e = a[a.length - 1];(f = a[a.length - 2]) && o(c, function (a, c) {
          var g;c === 0 && (a.setAttribute("x", b.getAttribute("x")), c = b.getAttribute("y"), a.setAttribute("y", c || 0), c === null && b.setAttribute("y", 0));g = a.cloneNode(1);$(g, { "class": "highcharts-text-shadow", fill: e, stroke: e, "stroke-opacity": 1 / y(H(f), 3), "stroke-width": f, "stroke-linejoin": "round" });b.insertBefore(g, d);
        });
      }));
    }, attr: function attr(a, b, c) {
      var d,
          e = this.element,
          f,
          g = this,
          h;typeof a === "string" && b !== x && (d = a, a = {}, a[d] = b);if (typeof a === "string") g = (this[a + "Getter"] || this._defaultGetter).call(this, a, e);else {
        for (d in a) {
          b = a[d];h = !1;this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(d) && (f || (this.symbolAttr(a), f = !0), h = !0);if (this.rotation && (d === "x" || d === "y")) this.doTransform = !0;h || (h = this[d + "Setter"] || this._defaultSetter, h.call(this, b, d, e), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d) && this.updateShadows(d, b, h));
        }if (this.doTransform) this.updateTransform(), this.doTransform = !1;
      }c && c();return g;
    }, updateShadows: function updateShadows(a, b, c) {
      for (var d = this.shadows, e = d.length; e--;) {
        c.call(d[e], a === "height" ? Math.max(b - (d[e].cutHeight || 0), 0) : a === "d" ? this.d : b, a, d[e]);
      }
    }, addClass: function addClass(a) {
      var b = this.element,
          c = $(b, "class") || "";c.indexOf(a) === -1 && $(b, "class", c + " " + a);return this;
    }, symbolAttr: function symbolAttr(a) {
      var b = this;
      o("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","), function (c) {
        b[c] = q(a[c], b[c]);
      });b.attr({ d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b) });
    }, clip: function clip(a) {
      return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
    }, crisp: function crisp(a) {
      var b,
          c = {},
          d,
          e = this.strokeWidth || 0;d = A(e) % 2 / 2;a.x = Y(a.x || this.x || 0) + d;a.y = Y(a.y || this.y || 0) + d;a.width = Y((a.width || this.width || 0) - 2 * d);a.height = Y((a.height || this.height || 0) - 2 * d);a.strokeWidth = e;for (b in a) {
        this[b] !== a[b] && (this[b] = c[b] = a[b]);
      }return c;
    }, css: function css(a) {
      var b = this.styles,
          c = {},
          d = this.element,
          e,
          f,
          g = "";e = !b;if (a && a.color) a.fill = a.color;if (b) for (f in a) {
        a[f] !== b[f] && (c[f] = a[f], e = !0);
      }if (e) {
        e = this.textWidth = a && a.width && d.nodeName.toLowerCase() === "text" && H(a.width) || this.textWidth;b && (a = v(b, c));this.styles = a;e && (ua || !ma && this.renderer.forExport) && delete a.width;if (La && !ma) O(this.element, a);else {
          b = function b(a, _b) {
            return "-" + _b.toLowerCase();
          };for (f in a) {
            g += f.replace(/([A-Z])/g, b) + ":" + a[f] + ";";
          }$(d, "style", g);
        }e && this.added && this.renderer.buildText(this);
      }return this;
    }, on: function on(a, b) {
      var c = this,
          d = c.element;$a && a === "click" ? (d.ontouchstart = function (a) {
        c.touchEventFired = ea.now();a.preventDefault();b.call(d, a);
      }, d.onclick = function (a) {
        (Pa.indexOf("Android") === -1 || ea.now() - (c.touchEventFired || 0) > 1100) && b.call(d, a);
      }) : d["on" + a] = b;return this;
    }, setRadialReference: function setRadialReference(a) {
      var b = this.renderer.gradients[this.element.gradient];this.element.radialReference = a;b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));return this;
    },
    translate: function translate(a, b) {
      return this.attr({ translateX: a, translateY: b });
    }, invert: function invert() {
      this.inverted = !0;this.updateTransform();return this;
    }, updateTransform: function updateTransform() {
      var a = this.translateX || 0,
          b = this.translateY || 0,
          c = this.scaleX,
          d = this.scaleY,
          e = this.inverted,
          f = this.rotation,
          g = this.element;e && (a += this.attr("width"), b += this.attr("height"));a = ["translate(" + a + "," + b + ")"];e ? a.push("rotate(90) scale(-1,1)") : f && a.push("rotate(" + f + " " + (g.getAttribute("x") || 0) + " " + (g.getAttribute("y") || 0) + ")");(t(c) || t(d)) && a.push("scale(" + q(c, 1) + " " + q(d, 1) + ")");a.length && g.setAttribute("transform", a.join(" "));
    }, toFront: function toFront() {
      var a = this.element;a.parentNode.appendChild(a);return this;
    }, align: function align(a, b, c) {
      var d,
          e,
          f,
          g,
          h = {};e = this.renderer;f = e.alignedObjects;if (a) {
        if (this.alignOptions = a, this.alignByTranslate = b, !c || Ea(c)) this.alignTo = d = c || "renderer", Ba(f, this), f.push(this), c = null;
      } else a = this.alignOptions, b = this.alignByTranslate, d = this.alignTo;c = q(c, e[d], e);d = a.align;e = a.verticalAlign;f = (c.x || 0) + (a.x || 0);g = (c.y || 0) + (a.y || 0);if (d === "right" || d === "center") f += (c.width - (a.width || 0)) / { right: 1, center: 2 }[d];h[b ? "translateX" : "x"] = A(f);if (e === "bottom" || e === "middle") g += (c.height - (a.height || 0)) / ({ bottom: 1, middle: 2 }[e] || 1);h[b ? "translateY" : "y"] = A(g);this[this.placed ? "animate" : "attr"](h);this.placed = !0;this.alignAttr = h;return this;
    }, getBBox: function getBBox(a, b) {
      var c,
          d = this.renderer,
          e,
          f,
          g,
          h = this.element,
          i = this.styles;e = this.textStr;var j,
          k = h.style,
          l,
          m = d.cache,
          n = d.cacheKeys,
          p;f = q(b, this.rotation);g = f * ta;e !== x && (p = ["", f || 0, i && i.fontSize, h.style.width].join(","), p = e === "" || cc.test(e) ? "num:" + e.toString().length + p : e + p);p && !a && (c = m[p]);if (!c) {
        if (h.namespaceURI === Ta || d.forExport) {
          try {
            l = this.fakeTS && function (a) {
              o(h.querySelectorAll(".highcharts-text-shadow"), function (b) {
                b.style.display = a;
              });
            }, Ya && k.textShadow ? (j = k.textShadow, k.textShadow = "") : l && l("none"), c = h.getBBox ? v({}, h.getBBox()) : { width: h.offsetWidth, height: h.offsetHeight }, j ? k.textShadow = j : l && l("");
          } catch (r) {}if (!c || c.width < 0) c = { width: 0, height: 0 };
        } else c = this.htmlGetBBox();if (d.isSVG) {
          d = c.width;e = c.height;if (La && i && i.fontSize === "11px" && e.toPrecision(3) === "16.9") c.height = e = 14;if (f) c.width = T(e * na(g)) + T(d * fa(g)), c.height = T(e * fa(g)) + T(d * na(g));
        }if (p) {
          for (; n.length > 250;) {
            delete m[n.shift()];
          }m[p] || n.push(p);m[p] = c;
        }
      }return c;
    }, show: function show(a) {
      return this.attr({ visibility: a ? "inherit" : "visible" });
    }, hide: function hide() {
      return this.attr({ visibility: "hidden" });
    }, fadeOut: function fadeOut(a) {
      var b = this;b.animate({ opacity: 0 }, { duration: a || 150, complete: function complete() {
          b.attr({ y: -9999 });
        } });
    }, add: function add(a) {
      var b = this.renderer,
          c = this.element,
          d;if (a) this.parentGroup = a;this.parentInverted = a && a.inverted;this.textStr !== void 0 && b.buildText(this);this.added = !0;if (!a || a.handleZ || this.zIndex) d = this.zIndexSetter();d || (a ? a.element : b.box).appendChild(c);if (this.onAdd) this.onAdd();return this;
    }, safeRemoveChild: function safeRemoveChild(a) {
      var b = a.parentNode;b && b.removeChild(a);
    }, destroy: function destroy() {
      var a = this,
          b = a.element || {},
          c = a.shadows,
          d = a.renderer.isSVG && b.nodeName === "SPAN" && a.parentGroup,
          e,
          f;b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;Qa(a);if (a.clipPath) a.clipPath = a.clipPath.destroy();if (a.stops) {
        for (f = 0; f < a.stops.length; f++) {
          a.stops[f] = a.stops[f].destroy();
        }a.stops = null;
      }a.safeRemoveChild(b);for (c && o(c, function (b) {
        a.safeRemoveChild(b);
      }); d && d.div && d.div.childNodes.length === 0;) {
        b = d.parentGroup, a.safeRemoveChild(d.div), delete d.div, d = b;
      }a.alignTo && Ba(a.renderer.alignedObjects, a);for (e in a) {
        delete a[e];
      }return null;
    }, shadow: function shadow(a, b, c) {
      var d = [],
          e,
          f,
          g = this.element,
          h,
          i,
          j,
          k;if (a) {
        i = q(a.width, 3);j = (a.opacity || 0.15) / i;k = this.parentInverted ? "(-1,-1)" : "(" + q(a.offsetX, 1) + ", " + q(a.offsetY, 1) + ")";for (e = 1; e <= i; e++) {
          f = g.cloneNode(0);h = i * 2 + 1 - 2 * e;$(f, { isShadow: "true", stroke: a.color || "black", "stroke-opacity": j * e, "stroke-width": h, transform: "translate" + k, fill: "none" });if (c) $(f, "height", y($(f, "height") - h, 0)), f.cutHeight = h;b ? b.element.appendChild(f) : g.parentNode.insertBefore(f, g);d.push(f);
        }this.shadows = d;
      }return this;
    }, xGetter: function xGetter(a) {
      this.element.nodeName === "circle" && (a = { x: "cx", y: "cy" }[a] || a);return this._defaultGetter(a);
    }, _defaultGetter: function _defaultGetter(a) {
      a = q(this[a], this.element ? this.element.getAttribute(a) : null, 0);/^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));return a;
    }, dSetter: function dSetter(a, b, c) {
      a && a.join && (a = a.join(" "));/(NaN| {2}|^$)/.test(a) && (a = "M 0 0");c.setAttribute(b, a);this[b] = a;
    }, dashstyleSetter: function dashstyleSetter(a) {
      var b,
          c = this["stroke-width"];c === "inherit" && (c = 1);if (a = a && a.toLowerCase()) {
        a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");for (b = a.length; b--;) {
          a[b] = H(a[b]) * c;
        }a = a.join(",").replace(/NaN/g, "none");this.element.setAttribute("stroke-dasharray", a);
      }
    }, alignSetter: function alignSetter(a) {
      this.element.setAttribute("text-anchor", { left: "start", center: "middle", right: "end" }[a]);
    }, opacitySetter: function opacitySetter(a, b, c) {
      this[b] = a;c.setAttribute(b, a);
    }, titleSetter: function titleSetter(a) {
      var b = this.element.getElementsByTagName("title")[0];b || (b = C.createElementNS(Ta, "title"), this.element.appendChild(b));b.firstChild && b.removeChild(b.firstChild);b.appendChild(C.createTextNode(String(q(a), "").replace(/<[^>]*>/g, "")));
    }, textSetter: function textSetter(a) {
      if (a !== this.textStr) delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this);
    }, fillSetter: function fillSetter(a, b, c) {
      typeof a === "string" ? c.setAttribute(b, a) : a && this.colorGradient(a, b, c);
    }, visibilitySetter: function visibilitySetter(a, b, c) {
      a === "inherit" ? c.removeAttribute(b) : c.setAttribute(b, a);
    }, zIndexSetter: function zIndexSetter(a, b) {
      var c = this.renderer,
          d = this.parentGroup,
          c = (d || c).element || c.box,
          e,
          f,
          g = this.element,
          h;e = this.added;var i;if (t(a)) g.zIndex = a, a = +a, this[b] === a && (e = !1), this[b] = a;if (e) {
        if ((a = this.zIndex) && d) d.handleZ = !0;d = c.childNodes;for (i = 0; i < d.length && !h; i++) {
          if (e = d[i], f = e.zIndex, e !== g && (H(f) > a || !t(a) && t(f))) c.insertBefore(g, e), h = !0;
        }h || c.appendChild(g);
      }return h;
    }, _defaultSetter: function _defaultSetter(a, b, c) {
      c.setAttribute(b, a);
    } };ba.prototype.yGetter = ba.prototype.xGetter;ba.prototype.translateXSetter = ba.prototype.translateYSetter = ba.prototype.rotationSetter = ba.prototype.verticalAlignSetter = ba.prototype.scaleXSetter = ba.prototype.scaleYSetter = function (a, b) {
    this[b] = a;this.doTransform = !0;
  };ba.prototype["stroke-widthSetter"] = ba.prototype.strokeSetter = function (a, b, c) {
    this[b] = a;if (this.stroke && this["stroke-width"]) this.strokeWidth = this["stroke-width"], ba.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0;else if (b === "stroke-width" && a === 0 && this.hasStroke) c.removeAttribute("stroke"), this.hasStroke = !1;
  };var za = function za() {
    this.init.apply(this, arguments);
  };
  za.prototype = { Element: ba, init: function init(a, b, c, d, e, f) {
      var g,
          d = this.createElement("svg").attr({ version: "1.1" }).css(this.getStyle(d));g = d.element;a.appendChild(g);a.innerHTML.indexOf("xmlns") === -1 && $(g, "xmlns", Ta);this.isSVG = !0;this.box = g;this.boxWrapper = d;this.alignedObjects = [];this.url = (Ya || vb) && C.getElementsByTagName("base").length ? M.location.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";this.createElement("desc").add().element.appendChild(C.createTextNode("Created with Highstock 4.2.6"));
      this.defs = this.createElement("defs").add();this.allowHTML = f;this.forExport = e;this.gradients = {};this.cache = {};this.cacheKeys = [];this.imgCount = 0;this.setSize(b, c, !1);var h;if (Ya && a.getBoundingClientRect) this.subPixelFix = b = function b() {
        O(a, { left: 0, top: 0 });h = a.getBoundingClientRect();O(a, { left: Ga(h.left) - h.left + "px", top: Ga(h.top) - h.top + "px" });
      }, b(), G(M, "resize", b);
    }, getStyle: function getStyle(a) {
      return this.style = v({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, a);
    }, isHidden: function isHidden() {
      return !this.boxWrapper.getBBox().width;
    }, destroy: function destroy() {
      var a = this.defs;this.box = null;this.boxWrapper = this.boxWrapper.destroy();Oa(this.gradients || {});this.gradients = null;if (a) this.defs = a.destroy();this.subPixelFix && U(M, "resize", this.subPixelFix);return this.alignedObjects = null;
    }, createElement: function createElement(a) {
      var b = new this.Element();b.init(this, a);return b;
    }, draw: function draw() {}, getRadialAttr: function getRadialAttr(a, b) {
      return { cx: a[0] - a[2] / 2 + b.cx * a[2], cy: a[1] - a[2] / 2 + b.cy * a[2], r: b.r * a[2] };
    }, buildText: function buildText(a) {
      for (var b = a.element, c = this, d = c.forExport, e = q(a.textStr, "").toString(), f = e.indexOf("<") !== -1, g = b.childNodes, h, i, j, k = $(b, "x"), l = a.styles, m = a.textWidth, n = l && l.lineHeight, p = l && l.textShadow, r = l && l.textOverflow === "ellipsis", s = g.length, Z = m && !a.added && this.box, u = function u(a) {
        return n ? H(n) : c.fontMetrics(/(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : l && l.fontSize || c.style.fontSize || 12, a).h;
      }, w = function w(a) {
        return a.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
      }; s--;) {
        b.removeChild(g[s]);
      }!f && !p && !r && !m && e.indexOf(" ") === -1 ? b.appendChild(C.createTextNode(w(e))) : (h = /<.*style="([^"]+)".*>/, i = /<.*href="(http[^"]+)".*>/, Z && Z.appendChild(b), e = f ? e.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [e], e = Ha(e, function (a) {
        return a !== "";
      }), o(e, function (e, f) {
        var g,
            n = 0,
            e = e.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");g = e.split("|||");o(g, function (e) {
          if (e !== "" || g.length === 1) {
            var p = {},
                s = C.createElementNS(Ta, "tspan"),
                q;h.test(e) && (q = e.match(h)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), $(s, "style", q));i.test(e) && !d && ($(s, "onclick", 'location.href="' + e.match(i)[1] + '"'), O(s, { cursor: "pointer" }));e = w(e.replace(/<(.|\n)*?>/g, "") || " ");if (e !== " ") {
              s.appendChild(C.createTextNode(e));if (n) p.dx = 0;else if (f && k !== null) p.x = k;$(s, p);b.appendChild(s);!n && f && (!ma && d && O(s, { display: "block" }), $(s, "dy", u(s)));if (m) {
                for (var p = e.replace(/([^\^])-/g, "$1- ").split(" "), Z = g.length > 1 || f || p.length > 1 && l.whiteSpace !== "nowrap", o, F, t = [], y = u(s), x = 1, A = a.rotation, v = e, B = v.length; (Z || r) && (p.length || t.length);) {
                  a.rotation = 0, o = a.getBBox(!0), F = o.width, !ma && c.forExport && (F = c.measureSpanWidth(s.firstChild.data, a.styles)), o = F > m, j === void 0 && (j = o), r && j ? (B /= 2, v === "" || !o && B < 0.5 ? p = [] : (v = e.substring(0, v.length + (o ? -1 : 1) * Ga(B)), p = [v + (m > 3 ? "\u2026" : "")], s.removeChild(s.firstChild))) : !o || p.length === 1 ? (p = t, t = [], p.length && (x++, s = C.createElementNS(Ta, "tspan"), $(s, { dy: y, x: k }), q && $(s, "style", q), b.appendChild(s)), F > m && (m = F)) : (s.removeChild(s.firstChild), t.unshift(p.pop())), p.length && s.appendChild(C.createTextNode(p.join(" ").replace(/- /g, "-")));
                }a.rotation = A;
              }n++;
            }
          }
        });
      }), j && a.attr("title", a.textStr), Z && Z.removeChild(b), p && a.applyTextShadow && a.applyTextShadow(p));
    }, getContrast: function getContrast(a) {
      a = xa(a).rgba;return a[0] + a[1] + a[2] > 384 ? "#000000" : "#FFFFFF";
    }, button: function button(a, b, c, d, e, f, g, h, i) {
      var j = this.label(a, b, c, i, null, null, null, null, "button"),
          k = 0,
          l,
          m,
          n,
          p,
          r,
          s,
          a = { x1: 0, y1: 0, x2: 0, y2: 1 },
          e = D({ "stroke-width": 1,
        stroke: "#CCCCCC", fill: { linearGradient: a, stops: [[0, "#FEFEFE"], [1, "#F6F6F6"]] }, r: 2, padding: 5, style: { color: "black" } }, e);n = e.style;delete e.style;f = D(e, { stroke: "#68A", fill: { linearGradient: a, stops: [[0, "#FFF"], [1, "#ACF"]] } }, f);p = f.style;delete f.style;g = D(e, { stroke: "#68A", fill: { linearGradient: a, stops: [[0, "#9BD"], [1, "#CDF"]] } }, g);r = g.style;delete g.style;h = D(e, { style: { color: "#CCC" } }, h);s = h.style;delete h.style;G(j.element, La ? "mouseover" : "mouseenter", function () {
        k !== 3 && j.attr(f).css(p);
      });G(j.element, La ? "mouseout" : "mouseleave", function () {
        k !== 3 && (l = [e, f, g][k], m = [n, p, r][k], j.attr(l).css(m));
      });j.setState = function (a) {
        (j.state = k = a) ? a === 2 ? j.attr(g).css(r) : a === 3 && j.attr(h).css(s) : j.attr(e).css(n);
      };return j.on("click", function (a) {
        k !== 3 && d.call(j, a);
      }).attr(e).css(v({ cursor: "default" }, n));
    }, crispLine: function crispLine(a, b) {
      a[1] === a[4] && (a[1] = a[4] = A(a[1]) - b % 2 / 2);a[2] === a[5] && (a[2] = a[5] = A(a[2]) + b % 2 / 2);return a;
    }, path: function path(a) {
      var b = { fill: "none" };Ra(a) ? b.d = a : ha(a) && v(b, a);return this.createElement("path").attr(b);
    }, circle: function circle(a, b, c) {
      a = ha(a) ? a : { x: a, y: b, r: c };b = this.createElement("circle");b.xSetter = b.ySetter = function (a, b, c) {
        c.setAttribute("c" + b, a);
      };return b.attr(a);
    }, arc: function arc(a, b, c, d, e, f) {
      if (ha(a)) b = a.y, c = a.r, d = a.innerR, e = a.start, f = a.end, a = a.x;a = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, { innerR: d || 0, start: e || 0, end: f || 0 });a.r = c;return a;
    }, rect: function rect(a, b, c, d, e, f) {
      var e = ha(a) ? a.r : e,
          g = this.createElement("rect"),
          a = ha(a) ? a : a === x ? {} : { x: a, y: b, width: y(c, 0), height: y(d, 0) };if (f !== x) g.strokeWidth = f, a = g.crisp(a);if (e) a.r = e;g.rSetter = function (a, b, c) {
        $(c, { rx: a, ry: a });
      };return g.attr(a);
    }, setSize: function setSize(a, b, c) {
      var d = this.alignedObjects,
          e = d.length;this.width = a;this.height = b;for (this.boxWrapper[q(c, !0) ? "animate" : "attr"]({ width: a, height: b }); e--;) {
        d[e].align();
      }
    }, g: function g(a) {
      var b = this.createElement("g");return t(a) ? b.attr({ "class": "highcharts-" + a }) : b;
    }, image: function image(a, b, c, d, e) {
      var f = { preserveAspectRatio: "none" };arguments.length > 1 && v(f, { x: b, y: c, width: d, height: e });f = this.createElement("image").attr(f);f.element.setAttributeNS ? f.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : f.element.setAttribute("hc-svg-href", a);return f;
    }, symbol: function symbol(a, b, c, d, e, f) {
      var g = this,
          h,
          i = this.symbols[a],
          i = i && i(A(b), A(c), d, e, f),
          j = /^url\((.*?)\)$/,
          k,
          l;if (i) h = this.path(i), v(h, { symbolName: a, x: b, y: c, width: d, height: e }), f && v(h, f);else if (j.test(a)) l = function l(a, b) {
        a.element && (a.attr({ width: b[0], height: b[1] }), a.alignByTranslate || a.translate(A((d - b[0]) / 2), A((e - b[1]) / 2)));
      }, k = a.match(j)[1], a = Yb[k] || f && f.width && f.height && [f.width, f.height], h = this.image(k).attr({ x: b, y: c }), h.isImg = !0, a ? l(h, a) : (h.attr({ width: 0, height: 0 }), ia("img", { onload: function onload() {
          this.width === 0 && (O(this, { position: "absolute", top: "-999em" }), C.body.appendChild(this));l(h, Yb[k] = [this.width, this.height]);this.parentNode && this.parentNode.removeChild(this);g.imgCount--;if (!g.imgCount && ca[g.chartIndex].onload) ca[g.chartIndex].onload();
        }, src: k }), this.imgCount++);return h;
    }, symbols: { circle: function circle(a, b, c, d) {
        var e = 0.166 * c;return [W, a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"];
      }, square: function square(a, b, c, d) {
        return [W, a, b, R, a + c, b, a + c, b + d, a, b + d, "Z"];
      }, triangle: function triangle(a, b, c, d) {
        return [W, a + c / 2, b, R, a + c, b + d, a, b + d, "Z"];
      }, "triangle-down": function triangleDown(a, b, c, d) {
        return [W, a, b, R, a + c, b, a + c / 2, b + d, "Z"];
      }, diamond: function diamond(a, b, c, d) {
        return [W, a + c / 2, b, R, a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"];
      }, arc: function arc(a, b, c, d, e) {
        var f = e.start,
            c = e.r || c || d,
            g = e.end - 0.001,
            d = e.innerR,
            h = e.open,
            i = fa(f),
            j = na(f),
            k = fa(g),
            g = na(g),
            e = e.end - f < Ca ? 0 : 1;return [W, a + c * i, b + c * j, "A", c, c, 0, e, 1, a + c * k, b + c * g, h ? W : R, a + d * k, b + d * g, "A", d, d, 0, e, 0, a + d * i, b + d * j, h ? "" : "Z"];
      }, callout: function callout(a, b, c, d, e) {
        var f = E(e && e.r || 0, c, d),
            g = f + 6,
            h = e && e.anchorX,
            e = e && e.anchorY,
            i;i = ["M", a + f, b, "L", a + c - f, b, "C", a + c, b, a + c, b, a + c, b + f, "L", a + c, b + d - f, "C", a + c, b + d, a + c, b + d, a + c - f, b + d, "L", a + f, b + d, "C", a, b + d, a, b + d, a, b + d - f, "L", a, b + f, "C", a, b, a, b, a + f, b];h && h > c && e > b + g && e < b + d - g ? i.splice(13, 3, "L", a + c, e - 6, a + c + 6, e, a + c, e + 6, a + c, b + d - f) : h && h < 0 && e > b + g && e < b + d - g ? i.splice(33, 3, "L", a, e + 6, a - 6, e, a, e - 6, a, b + f) : e && e > d && h > a + g && h < a + c - g ? i.splice(23, 3, "L", h + 6, b + d, h, b + d + 6, h - 6, b + d, a + f, b + d) : e && e < 0 && h > a + g && h < a + c - g && i.splice(3, 3, "L", h - 6, b, h, b - 6, h + 6, b, c - f, b);return i;
      } }, clipRect: function clipRect(a, b, c, d) {
      var e = "highcharts-" + Lb++,
          f = this.createElement("clipPath").attr({ id: e }).add(this.defs),
          a = this.rect(a, b, c, d, 0).add(f);a.id = e;a.clipPath = f;a.count = 0;return a;
    }, text: function text(a, b, c, d) {
      var e = ua || !ma && this.forExport,
          f = {};if (d && (this.allowHTML || !this.forExport)) return this.html(a, b, c);f.x = Math.round(b || 0);if (c) f.y = Math.round(c);if (a || a === 0) f.text = a;a = this.createElement("text").attr(f);e && a.css({ position: "absolute" });if (!d) a.xSetter = function (a, b, c) {
        var d = c.getElementsByTagName("tspan"),
            e,
            f = c.getAttribute(b),
            m;for (m = 0; m < d.length; m++) {
          e = d[m], e.getAttribute(b) === f && e.setAttribute(b, a);
        }c.setAttribute(b, a);
      };return a;
    }, fontMetrics: function fontMetrics(a, b) {
      var c,
          d,
          a = a || this.style.fontSize;!a && b && M.getComputedStyle && (b = b.element || b, a = (c = M.getComputedStyle(b, "")) && c.fontSize);a = /px/.test(a) ? H(a) : /em/.test(a) ? parseFloat(a) * 12 : 12;c = a < 24 ? a + 3 : A(a * 1.2);d = A(c * 0.8);return { h: c, b: d, f: a };
    }, rotCorr: function rotCorr(a, b, c) {
      var d = a;b && c && (d = y(d * fa(b * ta), 4));return { x: -a / 3 * na(b * ta), y: d };
    }, label: function label(a, b, c, d, e, f, g, h, i) {
      var j = this,
          k = j.g(i),
          l = j.text("", 0, 0, g).attr({ zIndex: 1 }),
          m,
          n,
          p = 0,
          r = 3,
          s = 0,
          q,
          u,
          w,
          F,
          L = 0,
          ka = {},
          y,
          B,
          C,
          E,
          z;C = function C() {
        var a, b;a = l.element.style;n = (q === void 0 || u === void 0 || k.styles.textAlign) && t(l.textStr) && l.getBBox();k.width = (q || n.width || 0) + 2 * r + s;k.height = (u || n.height || 0) + 2 * r;y = r + j.fontMetrics(a && a.fontSize, l).b;if (B) {
          if (!m) a = L, b = (h ? -y : 0) + L, k.box = m = j.symbols[d] ? j.symbol(d, a, b, k.width, k.height, ka) : j.rect(a, b, k.width, k.height, 0, ka["stroke-width"]), m.isImg || m.attr("fill", "none"), m.add(k);m.isImg || m.attr(v({ width: A(k.width),
            height: A(k.height) }, ka));ka = null;
        }
      };E = function E() {
        var a = k.styles,
            a = a && a.textAlign,
            b = s + r,
            c;c = h ? 0 : y;if (t(q) && n && (a === "center" || a === "right")) b += { center: 0.5, right: 1 }[a] * (q - n.width);if (b !== l.x || c !== l.y) l.attr("x", b), c !== x && l.attr("y", c);l.x = b;l.y = c;
      };z = function z(a, b) {
        m ? m.attr(a, b) : ka[a] = b;
      };k.onAdd = function () {
        l.add(k);k.attr({ text: a || a === 0 ? a : "", x: b, y: c });m && t(e) && k.attr({ anchorX: e, anchorY: f });
      };k.widthSetter = function (a) {
        q = a;
      };k.heightSetter = function (a) {
        u = a;
      };k.paddingSetter = function (a) {
        if (t(a) && a !== r) r = k.padding = a, E();
      };k.paddingLeftSetter = function (a) {
        t(a) && a !== s && (s = a, E());
      };k.alignSetter = function (a) {
        a = { left: 0, center: 0.5, right: 1 }[a];a !== p && (p = a, n && k.attr({ x: w }));
      };k.textSetter = function (a) {
        a !== x && l.textSetter(a);C();E();
      };k["stroke-widthSetter"] = function (a, b) {
        a && (B = !0);L = a % 2 / 2;z(b, a);
      };k.strokeSetter = k.fillSetter = k.rSetter = function (a, b) {
        b === "fill" && a && (B = !0);z(b, a);
      };k.anchorXSetter = function (a, b) {
        e = a;z(b, A(a) - L - w);
      };k.anchorYSetter = function (a, b) {
        f = a;z(b, a - F);
      };k.xSetter = function (a) {
        k.x = a;p && (a -= p * ((q || n.width) + 2 * r));w = A(a);k.attr("translateX", w);
      };k.ySetter = function (a) {
        F = k.y = A(a);k.attr("translateY", F);
      };var G = k.css;return v(k, { css: function css(a) {
          if (a) {
            var b = {},
                a = D(a);o(k.textProps, function (c) {
              a[c] !== x && (b[c] = a[c], delete a[c]);
            });l.css(b);
          }return G.call(k, a);
        }, getBBox: function getBBox() {
          return { width: n.width + 2 * r, height: n.height + 2 * r, x: n.x - r, y: n.y - r };
        }, shadow: function shadow(a) {
          m && m.shadow(a);return k;
        }, destroy: function destroy() {
          U(k.element, "mouseenter");U(k.element, "mouseleave");l && (l = l.destroy());m && (m = m.destroy());ba.prototype.destroy.call(k);
          k = j = C = E = z = null;
        } });
    } };Za = za;v(ba.prototype, { htmlCss: function htmlCss(a) {
      var b = this.element;if (b = a && b.tagName === "SPAN" && a.width) delete a.width, this.textWidth = b, this.updateTransform();if (a && a.textOverflow === "ellipsis") a.whiteSpace = "nowrap", a.overflow = "hidden";this.styles = v(this.styles, a);O(this.element, a);return this;
    }, htmlGetBBox: function htmlGetBBox() {
      var a = this.element;if (a.nodeName === "text") a.style.position = "absolute";return { x: a.offsetLeft, y: a.offsetTop, width: a.offsetWidth, height: a.offsetHeight };
    }, htmlUpdateTransform: function htmlUpdateTransform() {
      if (this.added) {
        var a = this.renderer,
            b = this.element,
            c = this.translateX || 0,
            d = this.translateY || 0,
            e = this.x || 0,
            f = this.y || 0,
            g = this.textAlign || "left",
            h = { left: 0, center: 0.5, right: 1 }[g],
            i = this.shadows,
            j = this.styles;O(b, { marginLeft: c, marginTop: d });i && o(i, function (a) {
          O(a, { marginLeft: c + 1, marginTop: d + 1 });
        });this.inverted && o(b.childNodes, function (c) {
          a.invertChild(c, b);
        });if (b.tagName === "SPAN") {
          var i = this.rotation,
              k = H(this.textWidth),
              l = j && j.whiteSpace,
              m = [i, g, b.innerHTML, this.textWidth, this.textAlign].join(",");if (m !== this.cTT) {
            j = a.fontMetrics(b.style.fontSize).b;
            t(i) && this.setSpanRotation(i, h, j);O(b, { width: "", whiteSpace: l || "nowrap" });if (b.offsetWidth > k && /[ \-]/.test(b.textContent || b.innerText)) O(b, { width: k + "px", display: "block", whiteSpace: l || "normal" });this.getSpanCorrection(b.offsetWidth, j, h, i, g);
          }O(b, { left: e + (this.xCorr || 0) + "px", top: f + (this.yCorr || 0) + "px" });if (vb) j = b.offsetHeight;this.cTT = m;
        }
      } else this.alignOnAdd = !0;
    }, setSpanRotation: function setSpanRotation(a, b, c) {
      var d = {},
          e = La ? "-ms-transform" : vb ? "-webkit-transform" : Ya ? "MozTransform" : Xb ? "-o-transform" : "";d[e] = d.transform = "rotate(" + a + "deg)";d[e + (Ya ? "Origin" : "-origin")] = d.transformOrigin = b * 100 + "% " + c + "px";O(this.element, d);
    }, getSpanCorrection: function getSpanCorrection(a, b, c) {
      this.xCorr = -a * c;this.yCorr = -b;
    } });v(za.prototype, { html: function html(a, b, c) {
      var d = this.createElement("span"),
          e = d.element,
          f = d.renderer,
          g = f.isSVG,
          h = function h(a, b) {
        o(["opacity", "visibility"], function (c) {
          S(a, c + "Setter", function (a, c, d, e) {
            a.call(this, c, d, e);b[d] = c;
          });
        });
      };d.textSetter = function (a) {
        a !== e.innerHTML && delete this.bBox;e.innerHTML = this.textStr = a;d.htmlUpdateTransform();
      };
      g && h(d, d.element.style);d.xSetter = d.ySetter = d.alignSetter = d.rotationSetter = function (a, b) {
        b === "align" && (b = "textAlign");d[b] = a;d.htmlUpdateTransform();
      };d.attr({ text: a, x: A(b), y: A(c) }).css({ position: "absolute", fontFamily: this.style.fontFamily, fontSize: this.style.fontSize });e.style.whiteSpace = "nowrap";d.css = d.htmlCss;if (g) d.add = function (a) {
        var b,
            c = f.box.parentNode,
            g = [];if (this.parentGroup = a) {
          if (b = a.div, !b) {
            for (; a;) {
              g.push(a), a = a.parentGroup;
            }o(g.reverse(), function (a) {
              var d,
                  e = $(a.element, "class");e && (e = { className: e });
              b = a.div = a.div || ia(Xa, e, { position: "absolute", left: (a.translateX || 0) + "px", top: (a.translateY || 0) + "px", opacity: a.opacity }, b || c);d = b.style;v(a, { translateXSetter: function translateXSetter(b, c) {
                  d.left = b + "px";a[c] = b;a.doTransform = !0;
                }, translateYSetter: function translateYSetter(b, c) {
                  d.top = b + "px";a[c] = b;a.doTransform = !0;
                } });h(a, d);
            });
          }
        } else b = c;b.appendChild(e);d.added = !0;d.alignOnAdd && d.htmlUpdateTransform();return d;
      };return d;
    } });var nb, da;if (!ma && !ua) da = { init: function init(a, b) {
      var c = ["<", b, ' filled="f" stroked="f"'],
          d = ["position: ", "absolute", ";"],
          e = b === Xa;(b === "shape" || e) && d.push("left:0;top:0;width:1px;height:1px;");d.push("visibility: ", e ? "hidden" : "visible");c.push(' style="', d.join(""), '"/>');if (b) c = e || b === "span" || b === "img" ? c.join("") : a.prepVML(c), this.element = ia(c);this.renderer = a;
    }, add: function add(a) {
      var b = this.renderer,
          c = this.element,
          d = b.box,
          e = a && a.inverted,
          d = a ? a.element || a : d;if (a) this.parentGroup = a;e && b.invertChild(c, d);d.appendChild(c);this.added = !0;this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform();if (this.onAdd) this.onAdd();
      return this;
    }, updateTransform: ba.prototype.htmlUpdateTransform, setSpanRotation: function setSpanRotation() {
      var a = this.rotation,
          b = fa(a * ta),
          c = na(a * ta);O(this.element, { filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", b, ", M12=", -c, ", M21=", c, ", M22=", b, ", sizingMethod='auto expand')"].join("") : "none" });
    }, getSpanCorrection: function getSpanCorrection(a, b, c, d, e) {
      var f = d ? fa(d * ta) : 1,
          g = d ? na(d * ta) : 0,
          h = q(this.elemHeight, this.element.offsetHeight),
          i;this.xCorr = f < 0 && -a;this.yCorr = g < 0 && -h;i = f * g < 0;this.xCorr += g * b * (i ? 1 - c : c);this.yCorr -= f * b * (d ? i ? c : 1 - c : 1);e && e !== "left" && (this.xCorr -= a * c * (f < 0 ? -1 : 1), d && (this.yCorr -= h * c * (g < 0 ? -1 : 1)), O(this.element, { textAlign: e }));
    }, pathToVML: function pathToVML(a) {
      for (var b = a.length, c = []; b--;) {
        if (z(a[b])) c[b] = A(a[b] * 10) - 5;else if (a[b] === "Z") c[b] = "x";else if (c[b] = a[b], a.isArc && (a[b] === "wa" || a[b] === "at")) c[b + 5] === c[b + 7] && (c[b + 7] += a[b + 7] > a[b + 5] ? 1 : -1), c[b + 6] === c[b + 8] && (c[b + 8] += a[b + 8] > a[b + 6] ? 1 : -1);
      }return c.join(" ") || "x";
    }, clip: function clip(a) {
      var b = this,
          c;a ? (c = a.members, Ba(c, b), c.push(b), b.destroyClip = function () {
        Ba(c, b);
      }, a = a.getCSS(b)) : (b.destroyClip && b.destroyClip(), a = { clip: ub ? "inherit" : "rect(auto)" });return b.css(a);
    }, css: ba.prototype.htmlCss, safeRemoveChild: function safeRemoveChild(a) {
      a.parentNode && Wa(a);
    }, destroy: function destroy() {
      this.destroyClip && this.destroyClip();return ba.prototype.destroy.apply(this);
    }, on: function on(a, b) {
      this.element["on" + a] = function () {
        var a = M.event;a.target = a.srcElement;b(a);
      };return this;
    }, cutOffPath: function cutOffPath(a, b) {
      var c,
          a = a.split(/[ ,]/);c = a.length;if (c === 9 || c === 11) a[c - 4] = a[c - 2] = H(a[c - 2]) - 10 * b;return a.join(" ");
    }, shadow: function shadow(a, b, c) {
      var d = [],
          e,
          f = this.element,
          g = this.renderer,
          h,
          i = f.style,
          j,
          k = f.path,
          l,
          m,
          n,
          p;k && typeof k.value !== "string" && (k = "x");m = k;if (a) {
        n = q(a.width, 3);p = (a.opacity || 0.15) / n;for (e = 1; e <= 3; e++) {
          l = n * 2 + 1 - 2 * e;c && (m = this.cutOffPath(k.value, l + 0.5));j = ['<shape isShadow="true" strokeweight="', l, '" filled="false" path="', m, '" coordsize="10 10" style="', f.style.cssText, '" />'];h = ia(g.prepVML(j), null, { left: H(i.left) + q(a.offsetX, 1), top: H(i.top) + q(a.offsetY, 1) });if (c) h.cutOff = l + 1;j = ['<stroke color="', a.color || "black", '" opacity="', p * e, '"/>'];ia(g.prepVML(j), null, null, h);b ? b.element.appendChild(h) : f.parentNode.insertBefore(h, f);d.push(h);
        }this.shadows = d;
      }return this;
    }, updateShadows: va, setAttr: function setAttr(a, b) {
      ub ? this.element[a] = b : this.element.setAttribute(a, b);
    }, classSetter: function classSetter(a) {
      this.element.className = a;
    }, dashstyleSetter: function dashstyleSetter(a, b, c) {
      (c.getElementsByTagName("stroke")[0] || ia(this.renderer.prepVML(["<stroke/>"]), null, null, c))[b] = a || "solid";this[b] = a;
    }, dSetter: function dSetter(a, b, c) {
      var d = this.shadows,
          a = a || [];this.d = a.join && a.join(" ");
      c.path = a = this.pathToVML(a);if (d) for (c = d.length; c--;) {
        d[c].path = d[c].cutOff ? this.cutOffPath(a, d[c].cutOff) : a;
      }this.setAttr(b, a);
    }, fillSetter: function fillSetter(a, b, c) {
      var d = c.nodeName;if (d === "SPAN") c.style.color = a;else if (d !== "IMG") c.filled = a !== "none", this.setAttr("fillcolor", this.renderer.color(a, c, b, this));
    }, "fill-opacitySetter": function fillOpacitySetter(a, b, c) {
      ia(this.renderer.prepVML(["<", b.split("-")[0], ' opacity="', a, '"/>']), null, null, c);
    }, opacitySetter: va, rotationSetter: function rotationSetter(a, b, c) {
      c = c.style;this[b] = c[b] = a;c.left = -A(na(a * ta) + 1) + "px";c.top = A(fa(a * ta)) + "px";
    }, strokeSetter: function strokeSetter(a, b, c) {
      this.setAttr("strokecolor", this.renderer.color(a, c, b, this));
    }, "stroke-widthSetter": function strokeWidthSetter(a, b, c) {
      c.stroked = !!a;this[b] = a;z(a) && (a += "px");this.setAttr("strokeweight", a);
    }, titleSetter: function titleSetter(a, b) {
      this.setAttr(b, a);
    }, visibilitySetter: function visibilitySetter(a, b, c) {
      a === "inherit" && (a = "visible");this.shadows && o(this.shadows, function (c) {
        c.style[b] = a;
      });c.nodeName === "DIV" && (a = a === "hidden" ? "-999em" : 0, ub || (c.style[b] = a ? "visible" : "hidden"), b = "top");c.style[b] = a;
    }, xSetter: function xSetter(a, b, c) {
      this[b] = a;b === "x" ? b = "left" : b === "y" && (b = "top");this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a;
    }, zIndexSetter: function zIndexSetter(a, b, c) {
      c.style[b] = a;
    } }, da["stroke-opacitySetter"] = da["fill-opacitySetter"], B.VMLElement = da = oa(ba, da), da.prototype.ySetter = da.prototype.widthSetter = da.prototype.heightSetter = da.prototype.xSetter, da = { Element: da, isIE8: Pa.indexOf("MSIE 8.0") > -1, init: function init(a, b, c, d) {
      var e;this.alignedObjects = [];d = this.createElement(Xa).css(v(this.getStyle(d), { position: "relative" }));e = d.element;a.appendChild(d.element);this.isVML = !0;this.box = e;this.boxWrapper = d;this.gradients = {};this.cache = {};this.cacheKeys = [];this.imgCount = 0;this.setSize(b, c, !1);if (!C.namespaces.hcv) {
        C.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");try {
          C.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
        } catch (f) {
          C.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
        }
      }
    },
    isHidden: function isHidden() {
      return !this.box.offsetWidth;
    }, clipRect: function clipRect(a, b, c, d) {
      var e = this.createElement(),
          f = ha(a);return v(e, { members: [], count: 0, left: (f ? a.x : a) + 1, top: (f ? a.y : b) + 1, width: (f ? a.width : c) - 1, height: (f ? a.height : d) - 1, getCSS: function getCSS(a) {
          var b = a.element,
              c = b.nodeName,
              a = a.inverted,
              d = this.top - (c === "shape" ? b.offsetTop : 0),
              e = this.left,
              b = e + this.width,
              f = d + this.height,
              d = { clip: "rect(" + A(a ? e : d) + "px," + A(a ? f : b) + "px," + A(a ? b : f) + "px," + A(a ? d : e) + "px)" };!a && ub && c === "DIV" && v(d, { width: b + "px", height: f + "px" });return d;
        },
        updateClipping: function updateClipping() {
          o(e.members, function (a) {
            a.element && a.css(e.getCSS(a));
          });
        } });
    }, color: function color(a, b, c, d) {
      var e = this,
          f,
          g = /^rgba/,
          h,
          i,
          j = "none";a && a.linearGradient ? i = "gradient" : a && a.radialGradient && (i = "pattern");if (i) {
        var k,
            l,
            m = a.linearGradient || a.radialGradient,
            n,
            p,
            r,
            s,
            q,
            u = "",
            a = a.stops,
            w,
            F = [],
            L = function L() {
          h = ['<fill colors="' + F.join(",") + '" opacity="', r, '" o:opacity2="', p, '" type="', i, '" ', u, 'focus="100%" method="any" />'];ia(e.prepVML(h), null, null, b);
        };n = a[0];w = a[a.length - 1];n[0] > 0 && a.unshift([0, n[1]]);w[0] < 1 && a.push([1, w[1]]);o(a, function (a, b) {
          g.test(a[1]) ? (f = xa(a[1]), k = f.get("rgb"), l = f.get("a")) : (k = a[1], l = 1);F.push(a[0] * 100 + "% " + k);b ? (r = l, s = k) : (p = l, q = k);
        });if (c === "fill") {
          if (i === "gradient") c = m.x1 || m[0] || 0, a = m.y1 || m[1] || 0, n = m.x2 || m[2] || 0, m = m.y2 || m[3] || 0, u = 'angle="' + (90 - aa.atan((m - a) / (n - c)) * 180 / Ca) + '"', L();else {
            var j = m.r,
                ka = j * 2,
                t = j * 2,
                y = m.cx,
                x = m.cy,
                A = b.radialReference,
                v,
                j = function j() {
              A && (v = d.getBBox(), y += (A[0] - v.x) / v.width - 0.5, x += (A[1] - v.y) / v.height - 0.5, ka *= A[2] / v.width, t *= A[2] / v.height);u = 'src="' + Q.global.VMLRadialGradientURL + '" size="' + ka + "," + t + '" origin="0.5,0.5" position="' + y + "," + x + '" color2="' + q + '" ';L();
            };d.added ? j() : d.onAdd = j;j = s;
          }
        } else j = k;
      } else if (g.test(a) && b.tagName !== "IMG") f = xa(a), d[c + "-opacitySetter"](f.get("a"), c, b), j = f.get("rgb");else {
        j = b.getElementsByTagName(c);if (j.length) j[0].opacity = 1, j[0].type = "solid";j = a;
      }return j;
    }, prepVML: function prepVML(a) {
      var b = this.isIE8,
          a = a.join("");b ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), a = a.indexOf('style="') === -1 ? a.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : a.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);')) : a = a.replace("<", "<hcv:");return a;
    }, text: za.prototype.html, path: function path(a) {
      var b = { coordsize: "10 10" };Ra(a) ? b.d = a : ha(a) && v(b, a);return this.createElement("shape").attr(b);
    }, circle: function circle(a, b, c) {
      var d = this.symbol("circle");if (ha(a)) c = a.r, b = a.y, a = a.x;d.isCircle = !0;d.r = c;return d.attr({ x: a, y: b });
    }, g: function g(a) {
      var b;a && (b = { className: "highcharts-" + a, "class": "highcharts-" + a });return this.createElement(Xa).attr(b);
    }, image: function image(a, b, c, d, e) {
      var f = this.createElement("img").attr({ src: a });arguments.length > 1 && f.attr({ x: b, y: c, width: d, height: e });return f;
    }, createElement: function createElement(a) {
      return a === "rect" ? this.symbol(a) : za.prototype.createElement.call(this, a);
    }, invertChild: function invertChild(a, b) {
      var c = this,
          d = b.style,
          e = a.tagName === "IMG" && a.style;O(a, { flip: "x", left: H(d.width) - (e ? H(e.top) : 1), top: H(d.height) - (e ? H(e.left) : 1), rotation: -90 });o(a.childNodes, function (b) {
        c.invertChild(b, a);
      });
    }, symbols: { arc: function arc(a, b, c, d, e) {
        var f = e.start,
            g = e.end,
            h = e.r || c || d,
            c = e.innerR,
            d = fa(f),
            i = na(f),
            j = fa(g),
            k = na(g);if (g - f === 0) return ["x"];f = ["wa", a - h, b - h, a + h, b + h, a + h * d, b + h * i, a + h * j, b + h * k];e.open && !c && f.push("e", W, a, b);f.push("at", a - c, b - c, a + c, b + c, a + c * j, b + c * k, a + c * d, b + c * i, "x", "e");f.isArc = !0;return f;
      }, circle: function circle(a, b, c, d, e) {
        e && (c = d = 2 * e.r);e && e.isCircle && (a -= c / 2, b -= d / 2);return ["wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e"];
      }, rect: function rect(a, b, c, d, e) {
        return za.prototype.symbols[!t(e) || !e.r ? "square" : "callout"].call(0, a, b, c, d, e);
      } } }, B.VMLRenderer = nb = function nb() {
    this.init.apply(this, arguments);
  }, nb.prototype = D(za.prototype, da), Za = nb;za.prototype.measureSpanWidth = function (a, b) {
    var c = C.createElement("span"),
        d;d = C.createTextNode(a);c.appendChild(d);O(c, b);this.box.appendChild(c);d = c.offsetWidth;Wa(c);return d;
  };var Zb;if (ua) B.CanVGRenderer = da = function da() {
    Ta = "http://www.w3.org/1999/xhtml";
  }, da.prototype.symbols = {}, Zb = function () {
    function a() {
      var a = b.length,
          d;for (d = 0; d < a; d++) {
        b[d]();
      }b = [];
    }var b = [];return { push: function push(c, d) {
        if (b.length === 0) {
          var e = C.getElementsByTagName("head")[0],
              f = C.createElement("script");
          f.type = "text/javascript";f.src = d;f.onload = a;e.appendChild(f);
        }b.push(c);
      } };
  }(), Za = da;eb.prototype = { addLabel: function addLabel() {
      var a = this.axis,
          b = a.options,
          c = a.chart,
          d = a.categories,
          e = a.names,
          f = this.pos,
          g = b.labels,
          h = a.tickPositions,
          i = f === h[0],
          j = f === h[h.length - 1],
          e = d ? q(d[f], e[f], f) : f,
          d = this.label,
          h = h.info,
          k;a.isDatetimeAxis && h && (k = b.dateTimeLabelFormats[h.higherRanks[f] || h.unitName]);this.isFirst = i;this.isLast = j;b = a.labelFormatter.call({ axis: a, chart: c, isFirst: i, isLast: j, dateTimeLabelFormat: k, value: a.isLog ? V(a.lin2log(e)) : e });t(d) ? d && d.attr({ text: b }) : (this.labelLength = (this.label = d = t(b) && g.enabled ? c.renderer.text(b, 0, 0, g.useHTML).css(D(g.style)).add(a.labelGroup) : null) && d.getBBox().width, this.rotation = 0);
    }, getLabelSize: function getLabelSize() {
      return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
    }, handleOverflow: function handleOverflow(a) {
      var b = this.axis,
          c = a.x,
          d = b.chart.chartWidth,
          e = b.chart.spacing,
          f = q(b.labelLeft, E(b.pos, e[3])),
          e = q(b.labelRight, y(b.pos + b.len, d - e[1])),
          g = this.label,
          h = this.rotation,
          i = { left: 0, center: 0.5, right: 1 }[b.labelAlign],
          j = g.getBBox().width,
          k = b.getSlotWidth(),
          l = k,
          m = 1,
          n,
          p = {};if (h) h < 0 && c - i * j < f ? n = A(c / fa(h * ta) - f) : h > 0 && c + i * j > e && (n = A((d - c) / fa(h * ta)));else if (d = c + (1 - i) * j, c - i * j < f ? l = a.x + l * (1 - i) - f : d > e && (l = e - a.x + l * i, m = -1), l = E(k, l), l < k && b.labelAlign === "center" && (a.x += m * (k - l - i * (k - E(j, l)))), j > l || b.autoRotation && g.styles.width) n = l;if (n) {
        p.width = n;if (!b.options.labels.style.textOverflow) p.textOverflow = "ellipsis";g.css(p);
      }
    }, getPosition: function getPosition(a, b, c, d) {
      var e = this.axis,
          f = e.chart,
          g = d && f.oldChartHeight || f.chartHeight;return { x: a ? e.translate(b + c, null, null, d) + e.transB : e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0), y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0) : g - e.translate(b + c, null, null, d) - e.transB };
    }, getLabelPosition: function getLabelPosition(a, b, c, d, e, f, g, h) {
      var i = this.axis,
          j = i.transA,
          k = i.reversed,
          l = i.staggerLines,
          m = i.tickRotCorr || { x: 0, y: 0 },
          n = e.y;t(n) || (n = i.side === 0 ? c.rotation ? -8 : -c.getBBox().height : i.side === 2 ? m.y + 8 : fa(c.rotation * ta) * (m.y - c.getBBox(!1, 0).height / 2));a = a + e.x + m.x - (f && d ? f * j * (k ? -1 : 1) : 0);b = b + n - (f && !d ? f * j * (k ? 1 : -1) : 0);l && (c = g / (h || 1) % l, i.opposite && (c = l - c - 1), b += c * (i.labelOffset / l));return { x: a, y: A(b) };
    }, getMarkPath: function getMarkPath(a, b, c, d, e, f) {
      return f.crispLine([W, a, b, R, a + (e ? 0 : -c), b + (e ? c : 0)], d);
    }, render: function render(a, b, c) {
      var d = this.axis,
          e = d.options,
          f = d.chart.renderer,
          g = d.horiz,
          h = this.type,
          i = this.label,
          j = this.pos,
          k = e.labels,
          l = this.gridLine,
          m = h ? h + "Grid" : "grid",
          n = h ? h + "Tick" : "tick",
          p = e[m + "LineWidth"],
          r = e[m + "LineColor"],
          s = e[m + "LineDashStyle"],
          m = d.tickSize(n),
          n = e[n + "Color"],
          o = this.mark,
          u = k.step,
          w = !0,
          F = d.tickmarkOffset,
          L = this.getPosition(g, j, F, b),
          ka = L.x,
          L = L.y,
          t = g && ka === d.pos + d.len || !g && L === d.pos ? -1 : 1,
          c = q(c, 1);this.isActive = !0;if (p) {
        j = d.getPlotLinePath(j + F, p * t, b, !0);if (l === x) {
          l = { stroke: r, "stroke-width": p };if (s) l.dashstyle = s;if (!h) l.zIndex = 1;if (b) l.opacity = 0;this.gridLine = l = p ? f.path(j).attr(l).add(d.gridGroup) : null;
        }if (!b && l && j) l[this.isNew ? "attr" : "animate"]({ d: j, opacity: c });
      }if (m) d.opposite && (m[0] = -m[0]), h = this.getMarkPath(ka, L, m[0], m[1] * t, g, f), o ? o.animate({ d: h, opacity: c }) : this.mark = f.path(h).attr({ stroke: n, "stroke-width": m[1],
        opacity: c }).add(d.axisGroup);if (i && z(ka)) i.xy = L = this.getLabelPosition(ka, L, i, g, k, F, a, u), this.isFirst && !this.isLast && !q(e.showFirstLabel, 1) || this.isLast && !this.isFirst && !q(e.showLastLabel, 1) ? w = !1 : g && !d.isRadial && !k.step && !k.rotation && !b && c !== 0 && this.handleOverflow(L), u && a % u && (w = !1), w && z(L.y) ? (L.opacity = c, i[this.isNew ? "attr" : "animate"](L)) : (Qa(i), i.attr("y", -9999)), this.isNew = !1;
    }, destroy: function destroy() {
      Oa(this, this.axis);
    } };B.PlotLineOrBand = function (a, b) {
    this.axis = a;if (b) this.options = b, this.id = b.id;
  };B.PlotLineOrBand.prototype = { render: function render() {
      var a = this,
          b = a.axis,
          c = b.horiz,
          d = a.options,
          e = d.label,
          f = a.label,
          g = d.width,
          h = d.to,
          i = d.from,
          j = t(i) && t(h),
          k = d.value,
          l = d.dashStyle,
          m = a.svgElem,
          n = [],
          p,
          r = d.color,
          s = q(d.zIndex, 0),
          o = d.events,
          u = {},
          w = b.chart.renderer,
          n = b.log2lin;b.isLog && (i = n(i), h = n(h), k = n(k));if (g) {
        if (n = b.getPlotLinePath(k, g), u = { stroke: r, "stroke-width": g }, l) u.dashstyle = l;
      } else if (j) {
        n = b.getPlotBandPath(i, h, d);if (r) u.fill = r;if (d.borderWidth) u.stroke = d.borderColor, u["stroke-width"] = d.borderWidth;
      } else return;u.zIndex = s;if (m) {
        if (n) m.show(), m.animate({ d: n });else {
          if (m.hide(), f) a.label = f = f.destroy();
        }
      } else if (n && n.length && (a.svgElem = m = w.path(n).attr(u).add(), o)) for (p in d = function d(b) {
        m.on(b, function (c) {
          o[b].apply(a, [c]);
        });
      }, o) {
        d(p);
      }e && t(e.text) && n && n.length && b.width > 0 && b.height > 0 && !n.flat ? (e = D({ align: c && j && "center", x: c ? !j && 4 : 10, verticalAlign: !c && j && "middle", y: c ? j ? 16 : 10 : j ? 6 : -4, rotation: c && !j && 90 }, e), this.renderLabel(e, n, j, s)) : f && f.hide();return a;
    }, renderLabel: function renderLabel(a, b, c, d) {
      var e = this.label,
          f = this.axis.chart.renderer;if (!e) e = { align: a.textAlign || a.align, rotation: a.rotation }, e.zIndex = d, this.label = e = f.text(a.text, 0, 0, a.useHTML).attr(e).css(a.style).add();d = [b[1], b[4], c ? b[6] : b[1]];b = [b[2], b[5], c ? b[7] : b[2]];c = Na(d);f = Na(b);e.align(a, !1, { x: c, y: f, width: Fa(d) - c, height: Fa(b) - f });e.show();
    }, destroy: function destroy() {
      Ba(this.axis.plotLinesAndBands, this);delete this.axis;Oa(this);
    } };var J = B.Axis = function () {
    this.init.apply(this, arguments);
  };J.prototype = { defaultOptions: { dateTimeLabelFormats: { millisecond: "%H:%M:%S.%L", second: "%H:%M:%S", minute: "%H:%M", hour: "%H:%M",
        day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y" }, endOnTick: !1, gridLineColor: "#D8D8D8", labels: { enabled: !0, style: { color: "#606060", cursor: "default", fontSize: "11px" }, x: 0 }, lineColor: "#C0D0E0", lineWidth: 1, minPadding: 0.01, maxPadding: 0.01, minorGridLineColor: "#E0E0E0", minorGridLineWidth: 1, minorTickColor: "#A0A0A0", minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: !1, tickColor: "#C0D0E0", tickLength: 10, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", title: { align: "middle",
        style: { color: "#707070" } }, type: "linear" }, defaultYAxisOptions: { endOnTick: !0, gridLineWidth: 1, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8 }, lineWidth: 0, maxPadding: 0.05, minPadding: 0.05, startOnTick: !0, title: { rotation: 270, text: "Values" }, stackLabels: { enabled: !1, formatter: function formatter() {
          return B.numberFormat(this.total, -1);
        }, style: D(X.line.dataLabels.style, { color: "#000000" }) } }, defaultLeftAxisOptions: { labels: { x: -15 }, title: { rotation: 270 } }, defaultRightAxisOptions: { labels: { x: 15 }, title: { rotation: 90 } }, defaultBottomAxisOptions: { labels: { autoRotation: [-45],
        x: 0 }, title: { rotation: 0 } }, defaultTopAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } }, init: function init(a, b) {
      var c = b.isX;this.chart = a;this.horiz = a.inverted ? !c : c;this.coll = (this.isXAxis = c) ? "xAxis" : "yAxis";this.opposite = b.opposite;this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);this.setOptions(b);var d = this.options,
          e = d.type;this.labelFormatter = d.labels.formatter || this.defaultLabelFormatter;this.userOptions = b;this.minPixelPadding = 0;this.reversed = d.reversed;this.visible = d.visible !== !1;this.zoomEnabled = d.zoomEnabled !== !1;this.categories = d.categories || e === "category";this.names = this.names || [];this.isLog = e === "logarithmic";this.isDatetimeAxis = e === "datetime";this.isLinked = t(d.linkedTo);this.ticks = {};this.labelEdge = [];this.minorTicks = {};this.plotLinesAndBands = [];this.alternateBands = {};this.len = 0;this.minRange = this.userMinRange = d.minRange || d.maxZoom;this.range = d.range;this.offset = d.offset || 0;this.stacks = {};this.oldStacks = {};this.stacksTouched = 0;this.min = this.max = null;this.crosshair = q(d.crosshair, sa(a.options.tooltip.crosshairs)[c ? 0 : 1], !1);var f,
          d = this.options.events;qa(this, a.axes) === -1 && (c && !this.isColorAxis ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));this.series = this.series || [];if (a.inverted && c && this.reversed === x) this.reversed = !0;this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;for (f in d) {
        G(this, f, d[f]);
      }if (this.isLog) this.val2lin = this.log2lin, this.lin2val = this.lin2log;
    }, setOptions: function setOptions(a) {
      this.options = D(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], D(Q[this.coll], a));
    }, defaultLabelFormatter: function defaultLabelFormatter() {
      var a = this.axis,
          b = this.value,
          c = a.categories,
          d = this.dateTimeLabelFormat,
          e = Q.lang.numericSymbols,
          f = e && e.length,
          g,
          h = a.options.labels.format,
          a = a.isLog ? b : a.tickInterval;if (h) g = Ma(h, this);else if (c) g = b;else if (d) g = pa(d, b);else if (f && a >= 1E3) for (; f-- && g === x;) {
        c = Math.pow(1E3, f + 1), a >= c && b * 10 % c === 0 && e[f] !== null && b !== 0 && (g = B.numberFormat(b / c, -1) + e[f]);
      }g === x && (g = T(b) >= 1E4 ? B.numberFormat(b, -1) : B.numberFormat(b, -1, x, ""));return g;
    }, getSeriesExtremes: function getSeriesExtremes() {
      var a = this,
          b = a.chart;a.hasVisibleSeries = !1;a.dataMin = a.dataMax = a.threshold = null;a.softThreshold = !a.isXAxis;a.buildStacks && a.buildStacks();o(a.series, function (c) {
        if (c.visible || !b.options.chart.ignoreHiddenSeries) {
          var d = c.options,
              e = d.threshold,
              f;a.hasVisibleSeries = !0;a.isLog && e <= 0 && (e = null);if (a.isXAxis) {
            if (d = c.xData, d.length) c = Na(d), !z(c) && !(c instanceof ea) && (d = Ha(d, function (a) {
              return z(a);
            }), c = Na(d)), a.dataMin = E(q(a.dataMin, d[0]), c), a.dataMax = y(q(a.dataMax, d[0]), Fa(d));
          } else {
            c.getExtremes();f = c.dataMax;c = c.dataMin;if (t(c) && t(f)) a.dataMin = E(q(a.dataMin, c), c), a.dataMax = y(q(a.dataMax, f), f);if (t(e)) a.threshold = e;if (!d.softThreshold || a.isLog) a.softThreshold = !1;
          }
        }
      });
    }, translate: function translate(a, b, c, d, e, f) {
      var g = this.linkedParent || this,
          h = 1,
          i = 0,
          j = d ? g.oldTransA : g.transA,
          d = d ? g.oldMin : g.min,
          k = g.minPixelPadding,
          e = (g.isOrdinal || g.isBroken || g.isLog && e) && g.lin2val;if (!j) j = g.transA;if (c) h *= -1, i = g.len;g.reversed && (h *= -1, i -= h * (g.sector || g.len));b ? (a = a * h + i, a -= k, a = a / j + d, e && (a = g.lin2val(a))) : (e && (a = g.val2lin(a)), f === "between" && (f = 0.5), a = h * (a - d) * j + i + h * k + (z(f) ? j * f * g.pointRange : 0));return a;
    }, toPixels: function toPixels(a, b) {
      return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
    }, toValue: function toValue(a, b) {
      return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
    }, getPlotLinePath: function getPlotLinePath(a, b, c, d, e) {
      var f = this.chart,
          g = this.left,
          h = this.top,
          i,
          j,
          k = c && f.oldChartHeight || f.chartHeight,
          l = c && f.oldChartWidth || f.chartWidth,
          m;i = this.transB;var n = function n(a, b, c) {
        if (a < b || a > c) d ? a = E(y(b, a), c) : m = !0;return a;
      },
          e = q(e, this.translate(a, null, null, c)),
          a = c = A(e + i);i = j = A(k - e - i);z(e) ? this.horiz ? (i = h, j = k - this.bottom, a = c = n(a, g, g + this.width)) : (a = g, c = l - this.right, i = j = n(i, h, h + this.height)) : m = !0;return m && !d ? null : f.renderer.crispLine([W, a, i, R, c, j], b || 1);
    }, getLinearTickPositions: function getLinearTickPositions(a, b, c) {
      var d,
          e = V(Y(b / a) * a),
          f = V(Ga(c / a) * a),
          g = [];if (b === c && z(b)) return [b];for (b = e; b <= f;) {
        g.push(b);b = V(b + a);
        if (b === d) break;d = b;
      }return g;
    }, getMinorTickPositions: function getMinorTickPositions() {
      var a = this.options,
          b = this.tickPositions,
          c = this.minorTickInterval,
          d = [],
          e,
          f = this.pointRangePadding || 0;e = this.min - f;var f = this.max + f,
          g = f - e;if (g && g / c < this.len / 3) if (this.isLog) {
        f = b.length;for (e = 1; e < f; e++) {
          d = d.concat(this.getLogTickPositions(c, b[e - 1], b[e], !0));
        }
      } else if (this.isDatetimeAxis && a.minorTickInterval === "auto") d = d.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c), e, f, a.startOfWeek));else for (b = e + (b[0] - e) % c; b <= f; b += c) {
        d.push(b);
      }d.length !== 0 && this.trimTicks(d, a.startOnTick, a.endOnTick);return d;
    }, adjustForMinRange: function adjustForMinRange() {
      var a = this.options,
          b = this.min,
          c = this.max,
          d,
          e = this.dataMax - this.dataMin >= this.minRange,
          f,
          g,
          h,
          i,
          j,
          k;if (this.isXAxis && this.minRange === x && !this.isLog) t(a.min) || t(a.max) ? this.minRange = null : (o(this.series, function (a) {
        i = a.xData;for (g = j = a.xIncrement ? 1 : i.length - 1; g > 0; g--) {
          if (h = i[g] - i[g - 1], f === x || h < f) f = h;
        }
      }), this.minRange = E(f * 5, this.dataMax - this.dataMin));if (c - b < this.minRange) {
        k = this.minRange;d = (k - c + b) / 2;d = [b - d, q(a.min, b - d)];if (e) d[2] = this.dataMin;b = Fa(d);c = [b + k, q(a.max, b + k)];if (e) c[2] = this.dataMax;c = Na(c);c - b < k && (d[0] = c - k, d[1] = q(a.min, c - k), b = Fa(d));
      }this.min = b;this.max = c;
    }, getClosest: function getClosest() {
      var a;this.categories ? a = 1 : o(this.series, function (b) {
        var c = b.closestPointRange;!b.noSharedTooltip && t(c) && (a = t(a) ? E(a, c) : c);
      });return a;
    }, setAxisTranslation: function setAxisTranslation(a) {
      var b = this,
          c = b.max - b.min,
          d = b.axisPointRange || 0,
          e,
          f = 0,
          g = 0,
          h = b.linkedParent,
          i = !!b.categories,
          j = b.transA,
          k = b.isXAxis;if (k || i || d) if (h ? (f = h.minPointOffset, g = h.pointRangePadding) : (e = b.getClosest(), o(b.series, function (a) {
        var c = i ? 1 : k ? q(a.options.pointRange, e, 0) : b.axisPointRange || 0,
            a = a.options.pointPlacement;d = y(d, c);b.single || (f = y(f, Ea(a) ? 0 : c / 2), g = y(g, a === "on" ? 0 : c));
      })), h = b.ordinalSlope && e ? b.ordinalSlope / e : 1, b.minPointOffset = f *= h, b.pointRangePadding = g *= h, b.pointRange = E(d, c), k) b.closestPointRange = e;if (a) b.oldTransA = j;b.translationSlope = b.transA = j = b.len / (c + g || 1);b.transB = b.horiz ? b.left : b.bottom;b.minPixelPadding = j * f;
    }, minFromRange: function minFromRange() {
      return this.max - this.range;
    }, setTickInterval: function setTickInterval(a) {
      var b = this,
          c = b.chart,
          d = b.options,
          e = b.isLog,
          f = b.log2lin,
          g = b.isDatetimeAxis,
          h = b.isXAxis,
          i = b.isLinked,
          j = d.maxPadding,
          k = d.minPadding,
          l = d.tickInterval,
          m = d.tickPixelInterval,
          n = b.categories,
          p = b.threshold,
          r = b.softThreshold,
          s,
          Z,
          u,
          w;!g && !n && !i && this.getTickAmount();u = q(b.userMin, d.min);w = q(b.userMax, d.max);i ? (b.linkedParent = c[b.coll][d.linkedTo], c = b.linkedParent.getExtremes(), b.min = q(c.min, c.dataMin), b.max = q(c.max, c.dataMax), d.type !== b.linkedParent.options.type && ja(11, 1)) : (!r && t(p) && (b.dataMin >= p ? (s = p, k = 0) : b.dataMax <= p && (Z = p, j = 0)), b.min = q(u, s, b.dataMin), b.max = q(w, Z, b.dataMax));if (e) !a && E(b.min, q(b.dataMin, b.min)) <= 0 && ja(10, 1), b.min = V(f(b.min), 15), b.max = V(f(b.max), 15);if (b.range && t(b.max)) b.userMin = b.min = u = y(b.min, b.minFromRange()), b.userMax = w = b.max, b.range = null;K(b, "foundExtremes");b.beforePadding && b.beforePadding();b.adjustForMinRange();if (!n && !b.axisPointRange && !b.usePercentage && !i && t(b.min) && t(b.max) && (f = b.max - b.min)) !t(u) && k && (b.min -= f * k), !t(w) && j && (b.max += f * j);if (z(d.floor)) b.min = y(b.min, d.floor);if (z(d.ceiling)) b.max = E(b.max, d.ceiling);if (r && t(b.dataMin)) if (p = p || 0, !t(u) && b.min < p && b.dataMin >= p) b.min = p;else if (!t(w) && b.max > p && b.dataMax <= p) b.max = p;b.tickInterval = b.min === b.max || b.min === void 0 || b.max === void 0 ? 1 : i && !l && m === b.linkedParent.options.tickPixelInterval ? l = b.linkedParent.tickInterval : q(l, this.tickAmount ? (b.max - b.min) / y(this.tickAmount - 1, 1) : void 0, n ? 1 : (b.max - b.min) * m / y(b.len, m));h && !a && o(b.series, function (a) {
        a.processData(b.min !== b.oldMin || b.max !== b.oldMax);
      });b.setAxisTranslation(!0);b.beforeSetTickPositions && b.beforeSetTickPositions();if (b.postProcessTickInterval) b.tickInterval = b.postProcessTickInterval(b.tickInterval);if (b.pointRange && !l) b.tickInterval = y(b.pointRange, b.tickInterval);a = q(d.minTickInterval, b.isDatetimeAxis && b.closestPointRange);if (!l && b.tickInterval < a) b.tickInterval = a;if (!g && !e && !l) b.tickInterval = Db(b.tickInterval, null, Cb(b.tickInterval), q(d.allowDecimals, !(b.tickInterval > 0.5 && b.tickInterval < 5 && b.max > 1E3 && b.max < 9999)), !!this.tickAmount);if (!this.tickAmount && this.len) b.tickInterval = b.unsquish();
      this.setTickPositions();
    }, setTickPositions: function setTickPositions() {
      var a = this.options,
          b,
          c = a.tickPositions,
          d = a.tickPositioner,
          e = a.startOnTick,
          f = a.endOnTick,
          g;this.tickmarkOffset = this.categories && a.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;this.minorTickInterval = a.minorTickInterval === "auto" && this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;this.tickPositions = b = c && c.slice();if (!b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()]), this.tickPositions = b, d && (d = d.apply(this, [this.min, this.max])))) this.tickPositions = b = d;if (!this.isLinked) this.trimTicks(b, e, f), this.min === this.max && t(this.min) && !this.tickAmount && (g = !0, this.min -= 0.5, this.max += 0.5), this.single = g, !c && !d && this.adjustTickAmount();
    },
    trimTicks: function trimTicks(a, b, c) {
      var d = a[0],
          e = a[a.length - 1],
          f = this.minPointOffset || 0;if (b) this.min = d;else for (; this.min - f > a[0];) {
        a.shift();
      }if (c) this.max = e;else for (; this.max + f < a[a.length - 1];) {
        a.pop();
      }a.length === 0 && t(d) && a.push((e + d) / 2);
    }, alignToOthers: function alignToOthers() {
      var a = {},
          b,
          c = this.options;this.chart.options.chart.alignTicks !== !1 && c.alignTicks !== !1 && o(this.chart[this.coll], function (c) {
        var e = c.options,
            e = [c.horiz ? e.left : e.top, e.width, e.height, e.pane].join(",");c.series.length && (a[e] ? b = !0 : a[e] = 1);
      });return b;
    }, getTickAmount: function getTickAmount() {
      var a = this.options,
          b = a.tickAmount,
          c = a.tickPixelInterval;!t(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);!b && this.alignToOthers() && (b = Ga(this.len / c) + 1);if (b < 4) this.finalTickAmt = b, b = 5;this.tickAmount = b;
    }, adjustTickAmount: function adjustTickAmount() {
      var a = this.tickInterval,
          b = this.tickPositions,
          c = this.tickAmount,
          d = this.finalTickAmt,
          e = b && b.length;if (e < c) {
        for (; b.length < c;) {
          b.push(V(b[b.length - 1] + a));
        }this.transA *= (e - 1) / (c - 1);this.max = b[b.length - 1];
      } else e > c && (this.tickInterval *= 2, this.setTickPositions());
      if (t(d)) {
        for (a = c = b.length; a--;) {
          (d === 3 && a % 2 === 1 || d <= 2 && a > 0 && a < c - 1) && b.splice(a, 1);
        }this.finalTickAmt = x;
      }
    }, setScale: function setScale() {
      var a, b;this.oldMin = this.min;this.oldMax = this.max;this.oldAxisLength = this.len;this.setAxisSize();b = this.len !== this.oldAxisLength;o(this.series, function (b) {
        if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;
      });if (b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers()) {
        if (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, !this.isDirty) this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax;
      } else this.cleanStacks && this.cleanStacks();
    }, setExtremes: function setExtremes(a, b, c, d, e) {
      var f = this,
          g = f.chart,
          c = q(c, !0);o(f.series, function (a) {
        delete a.kdTree;
      });e = v(e, { min: a, max: b });K(f, "setExtremes", e, function () {
        f.userMin = a;f.userMax = b;f.eventArgs = e;c && g.redraw(d);
      });
    }, zoom: function zoom(a, b) {
      var c = this.dataMin,
          d = this.dataMax,
          e = this.options,
          f = E(c, q(e.min, c)),
          e = y(d, q(e.max, d));this.allowZoomOutside || (t(c) && a <= f && (a = f), t(d) && b >= e && (b = e));this.displayBtn = a !== x || b !== x;this.setExtremes(a, b, !1, x, { trigger: "zoom" });return !0;
    }, setAxisSize: function setAxisSize() {
      var a = this.chart,
          b = this.options,
          c = b.offsetLeft || 0,
          d = this.horiz,
          e = q(b.width, a.plotWidth - c + (b.offsetRight || 0)),
          f = q(b.height, a.plotHeight),
          g = q(b.top, a.plotTop),
          b = q(b.left, a.plotLeft + c),
          c = /%$/;c.test(f) && (f = Math.round(parseFloat(f) / 100 * a.plotHeight));c.test(g) && (g = Math.round(parseFloat(g) / 100 * a.plotHeight + a.plotTop));this.left = b;this.top = g;this.width = e;this.height = f;this.bottom = a.chartHeight - f - g;this.right = a.chartWidth - e - b;this.len = y(d ? e : f, 0);this.pos = d ? b : g;
    }, getExtremes: function getExtremes() {
      var a = this.isLog,
          b = this.lin2log;return { min: a ? V(b(this.min)) : this.min, max: a ? V(b(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
    }, getThreshold: function getThreshold(a) {
      var b = this.isLog,
          c = this.lin2log,
          d = b ? c(this.min) : this.min,
          b = b ? c(this.max) : this.max;a === null ? a = d : d > a ? a = d : b < a && (a = b);
      return this.translate(a, 0, 1, 0, 1);
    }, autoLabelAlign: function autoLabelAlign(a) {
      a = (q(a, 0) - this.side * 90 + 720) % 360;return a > 15 && a < 165 ? "right" : a > 195 && a < 345 ? "left" : "center";
    }, tickSize: function tickSize(a) {
      var b = this.options,
          c = b[a + "Length"],
          d = q(b[a + "Width"], a === "tick" && this.isXAxis ? 1 : 0);if (d && c) return b[a + "Position"] === "inside" && (c = -c), [c, d];
    }, labelMetrics: function labelMetrics() {
      return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[0] && this.ticks[0].label);
    }, unsquish: function unsquish() {
      var a = this.options.labels,
          b = this.horiz,
          c = this.tickInterval,
          d = c,
          e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),
          f,
          g = a.rotation,
          h = this.labelMetrics(),
          i,
          j = Number.MAX_VALUE,
          k,
          l = function l(a) {
        a /= e || 1;a = a > 1 ? Ga(a) : 1;return a * c;
      };b ? (k = !a.staggerLines && !a.step && (t(g) ? [g] : e < q(a.autoRotationLimit, 80) && a.autoRotation)) && o(k, function (a) {
        var b;if (a === g || a && a >= -90 && a <= 90) i = l(T(h.h / na(ta * a))), b = i + T(a / 360), b < j && (j = b, f = a, d = i);
      }) : a.step || (d = l(h.h));this.autoRotation = k;this.labelRotation = q(f, g);return d;
    }, getSlotWidth: function getSlotWidth() {
      var a = this.chart,
          b = this.horiz,
          c = this.options.labels,
          d = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          e = a.margin[3];return b && (c.step || 0) < 2 && !c.rotation && (this.staggerLines || 1) * a.plotWidth / d || !b && (e && e - a.spacing[3] || a.chartWidth * 0.33);
    }, renderUnsquish: function renderUnsquish() {
      var a = this.chart,
          b = a.renderer,
          c = this.tickPositions,
          d = this.ticks,
          e = this.options.labels,
          f = this.horiz,
          g = this.getSlotWidth(),
          h = y(1, A(g - 2 * (e.padding || 5))),
          i = {},
          j = this.labelMetrics(),
          k = e.style.textOverflow,
          l,
          m = 0,
          n,
          p;if (!Ea(e.rotation)) i.rotation = e.rotation || 0;if (this.autoRotation) o(c, function (a) {
        if ((a = d[a]) && a.labelLength > m) m = a.labelLength;
      }), m > h && m > j.h ? i.rotation = this.labelRotation : this.labelRotation = 0;else if (g && (l = { width: h + "px" }, !k)) {
        l.textOverflow = "clip";for (n = c.length; !f && n--;) {
          if (p = c[n], h = d[p].label) if (h.styles.textOverflow === "ellipsis" ? h.css({ textOverflow: "clip" }) : d[p].labelLength > g && h.css({ width: g + "px" }), h.getBBox().height > this.len / c.length - (j.h - j.f)) h.specCss = { textOverflow: "ellipsis" };
        }
      }if (i.rotation && (l = { width: (m > a.chartHeight * 0.5 ? a.chartHeight * 0.33 : a.chartHeight) + "px" }, !k)) l.textOverflow = "ellipsis";if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) i.align = this.labelAlign;o(c, function (a) {
        var b = (a = d[a]) && a.label;if (b) b.attr(i), l && b.css(D(l, b.specCss)), delete b.specCss, a.rotation = i.rotation;
      });this.tickRotCorr = b.rotCorr(j.b, this.labelRotation || 0, this.side !== 0);
    }, hasData: function hasData() {
      return this.hasVisibleSeries || t(this.min) && t(this.max) && !!this.tickPositions;
    }, getOffset: function getOffset() {
      var a = this,
          b = a.chart,
          c = b.renderer,
          d = a.options,
          e = a.tickPositions,
          f = a.ticks,
          g = a.horiz,
          h = a.side,
          i = b.inverted ? [1, 0, 3, 2][h] : h,
          j,
          k,
          l = 0,
          m,
          n = 0,
          p = d.title,
          r = d.labels,
          s = 0,
          Z = a.opposite,
          u = b.axisOffset,
          b = b.clipOffset,
          w = [-1, 1, 1, -1][h],
          F,
          L = a.axisParent,
          ka = this.tickSize("tick");j = a.hasData();a.showAxis = k = j || q(d.showEmpty, !0);a.staggerLines = a.horiz && r.staggerLines;if (!a.axisGroup) a.gridGroup = c.g("grid").attr({ zIndex: d.gridZIndex || 1 }).add(L), a.axisGroup = c.g("axis").attr({ zIndex: d.zIndex || 2 }).add(L), a.labelGroup = c.g("axis-labels").attr({ zIndex: r.zIndex || 7 }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels").add(L);if (j || a.isLinked) {
        if (o(e, function (b) {
          f[b] ? f[b].addLabel() : f[b] = new eb(a, b);
        }), a.renderUnsquish(), r.reserveSpace !== !1 && (h === 0 || h === 2 || { 1: "left", 3: "right" }[h] === a.labelAlign || a.labelAlign === "center") && o(e, function (a) {
          s = y(f[a].getLabelSize(), s);
        }), a.staggerLines) s *= a.staggerLines, a.labelOffset = s * (a.opposite ? -1 : 1);
      } else for (F in f) {
        f[F].destroy(), delete f[F];
      }if (p && p.text && p.enabled !== !1) {
        if (!a.axisTitle) (F = p.textAlign) || (F = (g ? { low: "left", middle: "center", high: "right" } : { low: Z ? "right" : "left",
          middle: "center", high: Z ? "left" : "right" })[p.align]), a.axisTitle = c.text(p.text, 0, 0, p.useHTML).attr({ zIndex: 7, rotation: p.rotation || 0, align: F }).addClass("highcharts-" + this.coll.toLowerCase() + "-title").css(p.style).add(a.axisGroup), a.axisTitle.isNew = !0;if (k) l = a.axisTitle.getBBox()[g ? "height" : "width"], m = p.offset, n = t(m) ? 0 : q(p.margin, g ? 5 : 10);a.axisTitle[k ? "show" : "hide"](!0);
      }a.offset = w * q(d.offset, u[h]);a.tickRotCorr = a.tickRotCorr || { x: 0, y: 0 };c = h === 0 ? -a.labelMetrics().h : h === 2 ? a.tickRotCorr.y : 0;n = Math.abs(s) + n;s && (n -= c, n += w * (g ? q(r.y, a.tickRotCorr.y + w * 8) : r.x));a.axisTitleMargin = q(m, n);u[h] = y(u[h], a.axisTitleMargin + l + w * a.offset, n, j && e.length && ka ? ka[0] : 0);d = d.offset ? 0 : Y(d.lineWidth / 2) * 2;b[i] = y(b[i], d);
    }, getLinePath: function getLinePath(a) {
      var b = this.chart,
          c = this.opposite,
          d = this.offset,
          e = this.horiz,
          f = this.left + (c ? this.width : 0) + d,
          d = b.chartHeight - this.bottom - (c ? this.height : 0) + d;c && (a *= -1);return b.renderer.crispLine([W, e ? this.left : f, e ? d : this.top, R, e ? b.chartWidth - this.right : f, e ? d : b.chartHeight - this.bottom], a);
    }, getTitlePosition: function getTitlePosition() {
      var a = this.horiz,
          b = this.left,
          c = this.top,
          d = this.len,
          e = this.options.title,
          f = a ? b : c,
          g = this.opposite,
          h = this.offset,
          i = e.x || 0,
          j = e.y || 0,
          k = this.chart.renderer.fontMetrics(e.style.fontSize).f,
          d = { low: f + (a ? 0 : d), middle: f + d / 2, high: f + (a ? d : 0) }[e.align],
          b = (a ? c + this.height : b) + (a ? 1 : -1) * (g ? -1 : 1) * this.axisTitleMargin + (this.side === 2 ? k : 0);return { x: a ? d + i : b + (g ? this.width : 0) + h + i, y: a ? b + j - (g ? this.height : 0) + h : d + j };
    }, render: function render() {
      var a = this,
          b = a.chart,
          c = b.renderer,
          d = a.options,
          e = a.isLog,
          f = a.lin2log,
          g = a.isLinked,
          h = a.tickPositions,
          i = a.axisTitle,
          j = a.ticks,
          k = a.minorTicks,
          l = a.alternateBands,
          m = d.stackLabels,
          n = d.alternateGridColor,
          p = a.tickmarkOffset,
          r = d.lineWidth,
          s,
          q = b.hasRendered && z(a.oldMin),
          u = a.showAxis,
          w = ib(c.globalAnimation),
          F,
          L;a.labelEdge.length = 0;a.overlap = !1;o([j, k, l], function (a) {
        for (var b in a) {
          a[b].isActive = !1;
        }
      });if (a.hasData() || g) {
        a.minorTickInterval && !a.categories && o(a.getMinorTickPositions(), function (b) {
          k[b] || (k[b] = new eb(a, b, "minor"));q && k[b].isNew && k[b].render(null, !0);k[b].render(null, !1, 1);
        });if (h.length && (o(h, function (b, c) {
          if (!g || b >= a.min && b <= a.max) j[b] || (j[b] = new eb(a, b)), q && j[b].isNew && j[b].render(c, !0, 0.1), j[b].render(c);
        }), p && (a.min === 0 || a.single))) j[-1] || (j[-1] = new eb(a, -1, null, !0)), j[-1].render(-1);n && o(h, function (c, d) {
          L = h[d + 1] !== x ? h[d + 1] + p : a.max - p;if (d % 2 === 0 && c < a.max && L <= a.max + (b.polar ? -p : p)) l[c] || (l[c] = new B.PlotLineOrBand(a)), F = c + p, l[c].options = { from: e ? f(F) : F, to: e ? f(L) : L, color: n }, l[c].render(), l[c].isActive = !0;
        });if (!a._addedPlotLB) o((d.plotLines || []).concat(d.plotBands || []), function (b) {
          a.addPlotBandOrLine(b);
        }), a._addedPlotLB = !0;
      }o([j, k, l], function (a) {
        var c,
            d,
            e = [],
            f = w.duration;for (c in a) {
          if (!a[c].isActive) a[c].render(c, !1, 0), a[c].isActive = !1, e.push(c);
        }bb(function () {
          for (d = e.length; d--;) {
            a[e[d]] && !a[e[d]].isActive && (a[e[d]].destroy(), delete a[e[d]]);
          }
        }, a === l || !b.hasRendered || !f ? 0 : f);
      });if (r) s = a.getLinePath(r), a.axisLine ? a.axisLine.animate({ d: s }) : a.axisLine = c.path(s).attr({ stroke: d.lineColor, "stroke-width": r, zIndex: 7 }).add(a.axisGroup), a.axisLine[u ? "show" : "hide"](!0);if (i && u) i[i.isNew ? "attr" : "animate"](a.getTitlePosition()), i.isNew = !1;m && m.enabled && a.renderStackTotals();a.isDirty = !1;
    }, redraw: function redraw() {
      this.visible && (this.render(), o(this.plotLinesAndBands, function (a) {
        a.render();
      }));o(this.series, function (a) {
        a.isDirty = !0;
      });
    }, destroy: function destroy(a) {
      var b = this,
          c = b.stacks,
          d,
          e = b.plotLinesAndBands;a || U(b);for (d in c) {
        Oa(c[d]), c[d] = null;
      }o([b.ticks, b.minorTicks, b.alternateBands], function (a) {
        Oa(a);
      });for (a = e.length; a--;) {
        e[a].destroy();
      }o("stackTotalGroup,axisLine,axisTitle,axisGroup,gridGroup,labelGroup,cross".split(","), function (a) {
        b[a] && (b[a] = b[a].destroy());
      });this._addedPlotLB = this.chart._labelPanes = this.ordinalSlope = void 0;
    }, drawCrosshair: function drawCrosshair(a, b) {
      var c,
          d = this.crosshair,
          e,
          f;a || (a = this.cross && this.cross.e);if (!this.crosshair || (t(b) || !q(d.snap, !0)) === !1) this.hideCrosshair();else if (q(d.snap, !0) ? t(b) && (c = this.isXAxis ? b.plotX : this.len - b.plotY) : c = this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos, c = this.isRadial ? this.getPlotLinePath(this.isXAxis ? b.x : q(b.stackY, b.y)) || null : this.getPlotLinePath(null, null, null, null, c) || null, c === null) this.hideCrosshair();else {
        e = this.categories && !this.isRadial;f = q(d.width, e ? this.transA : 1);if (this.cross) this.cross.attr({ d: c, visibility: "visible", "stroke-width": f });else {
          e = { "pointer-events": "none", "stroke-width": f, stroke: d.color || (e ? "rgba(155,200,255,0.2)" : "#C0C0C0"), zIndex: q(d.zIndex, 2) };if (d.dashStyle) e.dashstyle = d.dashStyle;this.cross = this.chart.renderer.path(c).attr(e).add();
        }this.cross.e = a;
      }
    }, hideCrosshair: function hideCrosshair() {
      this.cross && this.cross.hide();
    } };v(J.prototype, { getPlotBandPath: function getPlotBandPath(a, b) {
      var c = this.getPlotLinePath(b, null, null, !0),
          d = this.getPlotLinePath(a, null, null, !0);d && c ? (d.flat = d.toString() === c.toString(), d.push(c[4], c[5], c[1], c[2])) : d = null;return d;
    }, addPlotBand: function addPlotBand(a) {
      return this.addPlotBandOrLine(a, "plotBands");
    }, addPlotLine: function addPlotLine(a) {
      return this.addPlotBandOrLine(a, "plotLines");
    }, addPlotBandOrLine: function addPlotBandOrLine(a, b) {
      var c = new B.PlotLineOrBand(this, a).render(),
          d = this.userOptions;c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c));return c;
    }, removePlotBandOrLine: function removePlotBandOrLine(a) {
      for (var b = this.plotLinesAndBands, c = this.options, d = this.userOptions, e = b.length; e--;) {
        b[e].id === a && b[e].destroy();
      }o([c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || []], function (b) {
        for (e = b.length; e--;) {
          b[e].id === a && Ba(b, b[e]);
        }
      });
    } });J.prototype.getTimeTicks = function (a, b, c, d) {
    var e = [],
        f = {},
        g = Q.global.useUTC,
        h,
        i = new ea(b - gb(b)),
        j = a.unitRange,
        k = a.count;if (t(b)) {
      i[Rb](j >= N.second ? 0 : k * Y(i.getMilliseconds() / k));if (j >= N.second) i[Sb](j >= N.minute ? 0 : k * Y(i.getSeconds() / k));if (j >= N.minute) i[Tb](j >= N.hour ? 0 : k * Y(i[Eb]() / k));if (j >= N.hour) i[Ub](j >= N.day ? 0 : k * Y(i[Fb]() / k));if (j >= N.day) i[sb](j >= N.month ? 1 : k * Y(i[db]() / k));j >= N.month && (i[Hb](j >= N.year ? 0 : k * Y(i[jb]() / k)), h = i[kb]());j >= N.year && (h -= h % k, i[Ib](h));if (j === N.week) i[sb](i[db]() - i[Gb]() + q(d, 1));b = 1;if (Bb || hb) i = i.getTime(), i = new ea(i + gb(i));h = i[kb]();for (var d = i.getTime(), l = i[jb](), m = i[db](), n = !g || !!hb, p = (N.day + (g ? gb(i) : i.getTimezoneOffset() * 6E4)) % N.day; d < c;) {
        e.push(d), j === N.year ? d = rb(h + b * k, 0) : j === N.month ? d = rb(h, l + b * k) : n && (j === N.day || j === N.week) ? d = rb(h, l, m + b * k * (j === N.day ? 1 : 7)) : d += j * k, b++;
      }e.push(d);o(Ha(e, function (a) {
        return j <= N.hour && a % N.day === p;
      }), function (a) {
        f[a] = "day";
      });
    }e.info = v(a, { higherRanks: f, totalRange: j * k });return e;
  };J.prototype.normalizeTimeTickInterval = function (a, b) {
    var c = b || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]],
        d = c[c.length - 1],
        e = N[d[0]],
        f = d[1],
        g;for (g = 0; g < c.length; g++) {
      if (d = c[g], e = N[d[0]], f = d[1], c[g + 1] && a <= (e * f[f.length - 1] + N[c[g + 1][0]]) / 2) break;
    }e === N.year && a < 5 * e && (f = [1, 2, 5]);c = Db(a / e, f, d[0] === "year" ? y(Cb(a / e), 1) : 1);return { unitRange: e, count: c, unitName: d[0] };
  };J.prototype.getLogTickPositions = function (a, b, c, d) {
    var e = this.options,
        f = this.len,
        g = this.lin2log,
        h = this.log2lin,
        i = [];if (!d) this._minorAutoInterval = null;if (a >= 0.5) a = A(a), i = this.getLinearTickPositions(a, b, c);else if (a >= 0.08) for (var f = Y(b), j, k, l, m, n, e = a > 0.3 ? [1, 2, 4] : a > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; f < c + 1 && !n; f++) {
      k = e.length;for (j = 0; j < k && !n; j++) {
        l = h(g(f) * e[j]), l > b && (!d || m <= c) && m !== x && i.push(m), m > c && (n = !0), m = l;
      }
    } else if (b = g(b), c = g(c), a = e[d ? "minorTickInterval" : "tickInterval"], a = q(a === "auto" ? null : a, this._minorAutoInterval, (c - b) * (e.tickPixelInterval / (d ? 5 : 1)) / ((d ? f / this.tickPositions.length : f) || 1)), a = Db(a, null, Cb(a)), i = wa(this.getLinearTickPositions(a, b, c), h), !d) this._minorAutoInterval = a / 5;if (!d) this.tickInterval = a;return i;
  };J.prototype.log2lin = function (a) {
    return aa.log(a) / aa.LN10;
  };J.prototype.lin2log = function (a) {
    return aa.pow(10, a);
  };
  var Nb = B.Tooltip = function () {
    this.init.apply(this, arguments);
  };Nb.prototype = { init: function init(a, b) {
      var c = b.borderWidth,
          d = b.style,
          e = H(d.padding);this.chart = a;this.options = b;this.crosshairs = [];this.now = { x: 0, y: 0 };this.isHidden = !0;this.label = a.renderer.label("", 0, 0, b.shape || "callout", null, null, b.useHTML, null, "tooltip").attr({ padding: e, fill: b.backgroundColor, "stroke-width": c, r: b.borderRadius, zIndex: 8 }).css(d).css({ padding: 0 }).add().attr({ y: -9E9 });ua || this.label.shadow(b.shadow);this.shared = b.shared;
    }, destroy: function destroy() {
      if (this.label) this.label = this.label.destroy();clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout);
    }, move: function move(a, b, c, d) {
      var e = this,
          f = e.now,
          g = e.options.animation !== !1 && !e.isHidden && (T(a - f.x) > 1 || T(b - f.y) > 1),
          h = e.followPointer || e.len > 1;v(f, { x: g ? (2 * f.x + a) / 3 : a, y: g ? (f.y + b) / 2 : b, anchorX: h ? x : g ? (2 * f.anchorX + c) / 3 : c, anchorY: h ? x : g ? (f.anchorY + d) / 2 : d });e.label.attr(f);if (g) clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
        e && e.move(a, b, c, d);
      }, 32);
    }, hide: function hide(a) {
      var b = this;clearTimeout(this.hideTimer);
      a = q(a, this.options.hideDelay, 500);if (!this.isHidden) this.hideTimer = bb(function () {
        b.label[a ? "fadeOut" : "hide"]();b.isHidden = !0;
      }, a);
    }, getAnchor: function getAnchor(a, b) {
      var c,
          d = this.chart,
          e = d.inverted,
          f = d.plotTop,
          g = d.plotLeft,
          h = 0,
          i = 0,
          j,
          k,
          a = sa(a);c = a[0].tooltipPos;this.followPointer && b && (b.chartX === x && (b = d.pointer.normalize(b)), c = [b.chartX - d.plotLeft, b.chartY - f]);c || (o(a, function (a) {
        j = a.series.yAxis;k = a.series.xAxis;h += a.plotX + (!e && k ? k.left - g : 0);i += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!e && j ? j.top - f : 0);
      }), h /= a.length, i /= a.length, c = [e ? d.plotWidth - i : h, this.shared && !e && a.length > 1 && b ? b.chartY - f : e ? d.plotHeight - h : i]);return wa(c, A);
    }, getPosition: function getPosition(a, b, c) {
      var d = this.chart,
          e = this.distance,
          f = {},
          g = c.h || 0,
          h,
          i = ["y", d.chartHeight, b, c.plotY + d.plotTop, d.plotTop, d.plotTop + d.plotHeight],
          j = ["x", d.chartWidth, a, c.plotX + d.plotLeft, d.plotLeft, d.plotLeft + d.plotWidth],
          k = !this.followPointer && q(c.ttBelow, !d.inverted === !!c.negative),
          l = function l(a, b, c, d, h, i) {
        var j = c < d - e,
            m = d + e + c < b,
            l = d - e - c;d += e;if (k && m) f[a] = d;else if (!k && j) f[a] = l;else if (j) f[a] = E(i - c, l - g < 0 ? l : l - g);else if (m) f[a] = y(h, d + g + c > b ? d : d + g);else return !1;
      },
          m = function m(a, b, c, d) {
        var g;d < e || d > b - e ? g = !1 : f[a] = d < c / 2 ? 1 : d > b - c / 2 ? b - c - 2 : d - c / 2;return g;
      },
          n = function n(a) {
        var b = i;i = j;j = b;h = a;
      },
          p = function p() {
        l.apply(0, i) !== !1 ? m.apply(0, j) === !1 && !h && (n(!0), p()) : h ? f.x = f.y = 0 : (n(!0), p());
      };(d.inverted || this.len > 1) && n();p();return f;
    }, defaultFormatter: function defaultFormatter(a) {
      var b = this.points || sa(this),
          c;c = [a.tooltipFooterHeaderFormatter(b[0])];c = c.concat(a.bodyFormatter(b));c.push(a.tooltipFooterHeaderFormatter(b[0], !0));return c.join("");
    }, refresh: function refresh(a, b) {
      var c = this.chart,
          d = this.label,
          e = this.options,
          f,
          g,
          h,
          i = {},
          j,
          k = [];j = e.formatter || this.defaultFormatter;var i = c.hoverPoints,
          l,
          m = this.shared;clearTimeout(this.hideTimer);this.followPointer = sa(a)[0].series.tooltipOptions.followPointer;h = this.getAnchor(a, b);f = h[0];g = h[1];m && (!a.series || !a.series.noSharedTooltip) ? (c.hoverPoints = a, i && o(i, function (a) {
        a.setState();
      }), o(a, function (a) {
        a.setState("hover");k.push(a.getLabelConfig());
      }), i = { x: a[0].category, y: a[0].y }, i.points = k, this.len = k.length, a = a[0]) : i = a.getLabelConfig();j = j.call(i, this);i = a.series;this.distance = q(i.tooltipOptions.distance, 16);j === !1 ? this.hide() : (this.isHidden && (Qa(d), d.attr("opacity", 1).show()), d.attr({ text: j }), l = e.borderColor || a.color || i.color || "#606060", d.attr({ stroke: l }), this.updatePosition({ plotX: f, plotY: g, negative: a.negative, ttBelow: a.ttBelow, h: h[2] || 0 }), this.isHidden = !1);K(c, "tooltipRefresh", { text: j, x: f + c.plotLeft, y: g + c.plotTop, borderColor: l });
    }, updatePosition: function updatePosition(a) {
      var b = this.chart,
          c = this.label,
          c = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a);this.move(A(c.x), A(c.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop);
    }, getXDateFormat: function getXDateFormat(a, b, c) {
      var d,
          b = b.dateTimeLabelFormats,
          e = c && c.closestPointRange,
          f,
          g = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 },
          h,
          i = "millisecond";if (e) {
        h = pa("%m-%d %H:%M:%S.%L", a.x);for (f in N) {
          if (e === N.week && +pa("%w", a.x) === c.options.startOfWeek && h.substr(6) === "00:00:00.000") {
            f = "week";break;
          }if (N[f] > e) {
            f = i;break;
          }if (g[f] && h.substr(g[f]) !== "01-01 00:00:00.000".substr(g[f])) break;
          f !== "week" && (i = f);
        }f && (d = b[f]);
      } else d = b.day;return d || b.year;
    }, tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(a, b) {
      var c = b ? "footer" : "header",
          d = a.series,
          e = d.tooltipOptions,
          f = e.xDateFormat,
          g = d.xAxis,
          h = g && g.options.type === "datetime" && z(a.key),
          c = e[c + "Format"];h && !f && (f = this.getXDateFormat(a, e, g));h && f && (c = c.replace("{point.key}", "{point.key:" + f + "}"));return Ma(c, { point: a, series: d });
    }, bodyFormatter: function bodyFormatter(a) {
      return wa(a, function (a) {
        var c = a.series.tooltipOptions;return (c.pointFormatter || a.point.tooltipFormatter).call(a.point, c.pointFormat);
      });
    } };var ra;$a = C && C.documentElement.ontouchstart !== x;var ab = B.Pointer = function (a, b) {
    this.init(a, b);
  };ab.prototype = { init: function init(a, b) {
      var c = b.chart,
          d = c.events,
          e = ua ? "" : c.zoomType,
          c = a.inverted,
          f;this.options = b;this.chart = a;this.zoomX = f = /x/.test(e);this.zoomY = e = /y/.test(e);this.zoomHor = f && !c || e && c;this.zoomVert = e && !c || f && c;this.hasZoom = f || e;this.runChartClick = d && !!d.click;this.pinchDown = [];this.lastValidTouch = {};if (B.Tooltip && b.tooltip.enabled) a.tooltip = new Nb(a, b.tooltip), this.followTouchMove = q(b.tooltip.followTouchMove, !0);this.setDOMEvents();
    }, normalize: function normalize(a, b) {
      var c,
          d,
          a = a || M.event;if (!a.target) a.target = a.srcElement;d = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;if (!b) this.chartPosition = b = Mb(this.chart.container);d.pageX === x ? (c = y(a.x, a.clientX - b.left), d = a.y) : (c = d.pageX - b.left, d = d.pageY - b.top);return v(a, { chartX: A(c), chartY: A(d) });
    }, getCoordinates: function getCoordinates(a) {
      var b = { xAxis: [], yAxis: [] };o(this.chart.axes, function (c) {
        b[c.isXAxis ? "xAxis" : "yAxis"].push({ axis: c, value: c.toValue(a[c.horiz ? "chartX" : "chartY"]) });
      });return b;
    }, runPointActions: function runPointActions(a) {
      var b = this.chart,
          c = b.series,
          d = b.tooltip,
          e = d ? d.shared : !1,
          f = b.hoverPoint,
          g = b.hoverSeries,
          h,
          i = [Number.MAX_VALUE, Number.MAX_VALUE],
          j,
          k,
          l = [],
          m = [],
          n;if (!e && !g) for (h = 0; h < c.length; h++) {
        if (c[h].directTouch || !c[h].options.stickyTracking) c = [];
      }g && (e ? g.noSharedTooltip : g.directTouch) && f ? m = [f] : (o(c, function (b) {
        j = b.noSharedTooltip && e;k = !e && b.directTouch;b.visible && !j && !k && q(b.options.enableMouseTracking, !0) && (n = b.searchPoint(a, !j && b.kdDimensions === 1)) && n.series && l.push(n);
      }), o(l, function (a) {
        a && o(["dist", "distX"], function (b, c) {
          if (z(a[b])) {
            var d = a[b] === i[c] && a.series.group.zIndex >= m[c].series.group.zIndex;if (a[b] < i[c] || d) i[c] = a[b], m[c] = a;
          }
        });
      }));if (e) for (h = l.length; h--;) {
        (l[h].clientX !== m[1].clientX || l[h].series.noSharedTooltip) && l.splice(h, 1);
      }if (m[0] && (m[0] !== this.prevKDPoint || d && d.isHidden)) {
        if (e && !m[0].series.noSharedTooltip) l.length && d && d.refresh(l, a), o(l, function (b) {
          b.onMouseOver(a, b !== (g && g.directTouch && f || m[0]));
        }), this.prevKDPoint = m[1];else {
          d && d.refresh(m[0], a);if (!g || !g.directTouch) m[0].onMouseOver(a);this.prevKDPoint = m[0];
        }
      } else c = g && g.tooltipOptions.followPointer, d && c && !d.isHidden && (c = d.getAnchor([{}], a), d.updatePosition({ plotX: c[0], plotY: c[1] }));if (!this._onDocumentMouseMove) this._onDocumentMouseMove = function (a) {
        if (ca[ra]) ca[ra].pointer.onDocumentMouseMove(a);
      }, G(C, "mousemove", this._onDocumentMouseMove);o(e ? l : [q(f, m[1])], function (c) {
        o(b.axes, function (b) {
          (!c || c.series[b.coll] === b) && b.drawCrosshair(a, c);
        });
      });
    }, reset: function reset(a, b) {
      var c = this.chart,
          d = c.hoverSeries,
          e = c.hoverPoint,
          f = c.hoverPoints,
          g = c.tooltip,
          h = g && g.shared ? f : e;a && h && o(sa(h), function (b) {
        b.series.isCartesian && b.plotX === void 0 && (a = !1);
      });if (a) g && h && (g.refresh(h), e && (e.setState(e.state, !0), o(c.axes, function (a) {
        a.crosshair && a.drawCrosshair(null, e);
      })));else {
        if (e) e.onMouseOut();f && o(f, function (a) {
          a.setState();
        });if (d) d.onMouseOut();g && g.hide(b);if (this._onDocumentMouseMove) U(C, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove = null;o(c.axes, function (a) {
          a.hideCrosshair();
        });
        this.hoverX = this.prevKDPoint = c.hoverPoints = c.hoverPoint = null;
      }
    }, scaleGroups: function scaleGroups(a, b) {
      var c = this.chart,
          d;o(c.series, function (e) {
        d = a || e.getPlotBox();e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(b ? c.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d));
      });c.clipRect.attr(b || c.clipBox);
    }, dragStart: function dragStart(a) {
      var b = this.chart;b.mouseIsDown = a.type;b.cancelClick = !1;b.mouseDownX = this.mouseDownX = a.chartX;b.mouseDownY = this.mouseDownY = a.chartY;
    },
    drag: function drag(a) {
      var b = this.chart,
          c = b.options.chart,
          d = a.chartX,
          e = a.chartY,
          f = this.zoomHor,
          g = this.zoomVert,
          h = b.plotLeft,
          i = b.plotTop,
          j = b.plotWidth,
          k = b.plotHeight,
          l,
          m = this.selectionMarker,
          n = this.mouseDownX,
          p = this.mouseDownY,
          r = c.panKey && a[c.panKey + "Key"];if (!m || !m.touch) if (d < h ? d = h : d > h + j && (d = h + j), e < i ? e = i : e > i + k && (e = i + k), this.hasDragged = Math.sqrt(Math.pow(n - d, 2) + Math.pow(p - e, 2)), this.hasDragged > 10) {
        l = b.isInsidePlot(n - h, p - i);if (b.hasCartesianSeries && (this.zoomX || this.zoomY) && l && !r && !m) this.selectionMarker = m = b.renderer.rect(h, i, f ? 1 : j, g ? 1 : k, 0).attr({ fill: c.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex: 7 }).add();m && f && (d -= n, m.attr({ width: T(d), x: (d > 0 ? 0 : d) + n }));m && g && (d = e - p, m.attr({ height: T(d), y: (d > 0 ? 0 : d) + p }));l && !m && c.panning && b.pan(a, c.panning);
      }
    }, drop: function drop(a) {
      var b = this,
          c = this.chart,
          d = this.hasPinched;if (this.selectionMarker) {
        var e = { originalEvent: a, xAxis: [], yAxis: [] },
            f = this.selectionMarker,
            g = f.attr ? f.attr("x") : f.x,
            h = f.attr ? f.attr("y") : f.y,
            i = f.attr ? f.attr("width") : f.width,
            j = f.attr ? f.attr("height") : f.height,
            k;if (this.hasDragged || d) o(c.axes, function (c) {
          if (c.zoomEnabled && t(c.min) && (d || b[{ xAxis: "zoomX", yAxis: "zoomY" }[c.coll]])) {
            var f = c.horiz,
                n = a.type === "touchend" ? c.minPixelPadding : 0,
                p = c.toValue((f ? g : h) + n),
                f = c.toValue((f ? g + i : h + j) - n);e[c.coll].push({ axis: c, min: E(p, f), max: y(p, f) });k = !0;
          }
        }), k && K(c, "selection", e, function (a) {
          c.zoom(v(a, d ? { animation: !1 } : null));
        });this.selectionMarker = this.selectionMarker.destroy();d && this.scaleGroups();
      }if (c) O(c.container, { cursor: c._cursor }), c.cancelClick = this.hasDragged > 10, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [];
    }, onContainerMouseDown: function onContainerMouseDown(a) {
      a = this.normalize(a);a.preventDefault && a.preventDefault();this.dragStart(a);
    }, onDocumentMouseUp: function onDocumentMouseUp(a) {
      ca[ra] && ca[ra].pointer.drop(a);
    }, onDocumentMouseMove: function onDocumentMouseMove(a) {
      var b = this.chart,
          c = this.chartPosition,
          a = this.normalize(a, c);c && !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && this.reset();
    }, onContainerMouseLeave: function onContainerMouseLeave(a) {
      var b = ca[ra];
      if (b && (a.relatedTarget || a.toElement)) b.pointer.reset(), b.pointer.chartPosition = null;
    }, onContainerMouseMove: function onContainerMouseMove(a) {
      var b = this.chart;if (!t(ra) || !ca[ra] || !ca[ra].mouseIsDown) ra = b.index;a = this.normalize(a);a.returnValue = !1;b.mouseIsDown === "mousedown" && this.drag(a);(this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop)) && !b.openMenu && this.runPointActions(a);
    }, inClass: function inClass(a, b) {
      for (var c; a;) {
        if (c = $(a, "class")) {
          if (c.indexOf(b) !== -1) return !0;if (c.indexOf("highcharts-container") !== -1) return !1;
        }a = a.parentNode;
      }
    }, onTrackerMouseOut: function onTrackerMouseOut(a) {
      var b = this.chart.hoverSeries,
          a = a.relatedTarget || a.toElement;if (b && a && !b.options.stickyTracking && !this.inClass(a, "highcharts-tooltip") && !this.inClass(a, "highcharts-series-" + b.index)) b.onMouseOut();
    }, onContainerClick: function onContainerClick(a) {
      var b = this.chart,
          c = b.hoverPoint,
          d = b.plotLeft,
          e = b.plotTop,
          a = this.normalize(a);b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (K(c.series, "click", v(a, { point: c })), b.hoverPoint && c.firePointEvent("click", a)) : (v(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - d, a.chartY - e) && K(b, "click", a)));
    }, setDOMEvents: function setDOMEvents() {
      var a = this,
          b = a.chart.container;b.onmousedown = function (b) {
        a.onContainerMouseDown(b);
      };b.onmousemove = function (b) {
        a.onContainerMouseMove(b);
      };b.onclick = function (b) {
        a.onContainerClick(b);
      };G(b, "mouseleave", a.onContainerMouseLeave);mb === 1 && G(C, "mouseup", a.onDocumentMouseUp);if ($a) b.ontouchstart = function (b) {
        a.onContainerTouchStart(b);
      }, b.ontouchmove = function (b) {
        a.onContainerTouchMove(b);
      }, mb === 1 && G(C, "touchend", a.onDocumentTouchEnd);
    }, destroy: function destroy() {
      var a;U(this.chart.container, "mouseleave", this.onContainerMouseLeave);mb || (U(C, "mouseup", this.onDocumentMouseUp), U(C, "touchend", this.onDocumentTouchEnd));clearInterval(this.tooltipTimeout);for (a in this) {
        this[a] = null;
      }
    } };v(B.Pointer.prototype, { pinchTranslate: function pinchTranslate(a, b, c, d, e, f) {
      (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, a, b, c, d, e, f);(this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, a, b, c, d, e, f);
    }, pinchTranslateDirection: function pinchTranslateDirection(a, b, c, d, e, f, g, h) {
      var i = this.chart,
          j = a ? "x" : "y",
          k = a ? "X" : "Y",
          l = "chart" + k,
          m = a ? "width" : "height",
          n = i["plot" + (a ? "Left" : "Top")],
          p,
          r,
          s = h || 1,
          q = i.inverted,
          o = i.bounds[a ? "h" : "v"],
          w = b.length === 1,
          F = b[0][l],
          L = c[0][l],
          t = !w && b[1][l],
          y = !w && c[1][l],
          x,
          c = function c() {
        !w && T(F - t) > 20 && (s = h || T(L - y) / T(F - t));r = (n - L) / s + F;p = i["plot" + (a ? "Width" : "Height")] / s;
      };c();b = r;b < o.min ? (b = o.min, x = !0) : b + p > o.max && (b = o.max - p, x = !0);x ? (L -= 0.8 * (L - g[j][0]), w || (y -= 0.8 * (y - g[j][1])), c()) : g[j] = [L, y];q || (f[j] = r - n, f[m] = p);f = q ? 1 / s : s;e[m] = p;e[j] = b;d[q ? a ? "scaleY" : "scaleX" : "scale" + k] = s;d["translate" + k] = f * n + (L - f * F);
    }, pinch: function pinch(a) {
      var b = this,
          c = b.chart,
          d = b.pinchDown,
          e = a.touches,
          f = e.length,
          g = b.lastValidTouch,
          h = b.hasZoom,
          i = b.selectionMarker,
          j = {},
          k = f === 1 && (b.inClass(a.target, "highcharts-tracker") && c.runTrackerClick || b.runChartClick),
          l = {};if (f > 1) b.initiated = !0;h && b.initiated && !k && a.preventDefault();wa(e, function (a) {
        return b.normalize(a);
      });if (a.type === "touchstart") o(e, function (a, b) {
        d[b] = { chartX: a.chartX, chartY: a.chartY };
      }), g.x = [d[0].chartX, d[1] && d[1].chartX], g.y = [d[0].chartY, d[1] && d[1].chartY], o(c.axes, function (a) {
        if (a.zoomEnabled) {
          var b = c.bounds[a.horiz ? "h" : "v"],
              d = a.minPixelPadding,
              e = a.toPixels(q(a.options.min, a.dataMin)),
              f = a.toPixels(q(a.options.max, a.dataMax)),
              g = E(e, f),
              e = y(e, f);b.min = E(a.pos, g - d);b.max = y(a.pos + a.len, e + d);
        }
      }), b.res = !0;else if (d.length) {
        if (!i) b.selectionMarker = i = v({ destroy: va, touch: !0 }, c.plotBox);b.pinchTranslate(d, e, j, i, l, g);b.hasPinched = h;b.scaleGroups(j, l);if (!h && b.followTouchMove && f === 1) this.runPointActions(b.normalize(a));else if (b.res) b.res = !1, this.reset(!1, 0);
      }
    }, touch: function touch(a, b) {
      var c = this.chart,
          d;ra = c.index;if (a.touches.length === 1) {
        if (a = this.normalize(a), c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop) && !c.openMenu) {
          b && this.runPointActions(a);if (a.type === "touchmove") c = this.pinchDown, d = c[0] ? Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) >= 4 : !1;q(d, !0) && this.pinch(a);
        } else b && this.reset();
      } else a.touches.length === 2 && this.pinch(a);
    }, onContainerTouchStart: function onContainerTouchStart(a) {
      this.touch(a, !0);
    }, onContainerTouchMove: function onContainerTouchMove(a) {
      this.touch(a);
    },
    onDocumentTouchEnd: function onDocumentTouchEnd(a) {
      ca[ra] && ca[ra].pointer.drop(a);
    } });if (M.PointerEvent || M.MSPointerEvent) {
    var Ia = {},
        Ob = !!M.PointerEvent,
        dc = function dc() {
      var a,
          b = [];b.item = function (a) {
        return this[a];
      };for (a in Ia) {
        Ia.hasOwnProperty(a) && b.push({ pageX: Ia[a].pageX, pageY: Ia[a].pageY, target: Ia[a].target });
      }return b;
    },
        Pb = function Pb(a, b, c, d) {
      if ((a.pointerType === "touch" || a.pointerType === a.MSPOINTER_TYPE_TOUCH) && ca[ra]) d(a), d = ca[ra].pointer, d[b]({ type: c, target: a.currentTarget, preventDefault: va, touches: dc() });
    };v(ab.prototype, { onContainerPointerDown: function onContainerPointerDown(a) {
        Pb(a, "onContainerTouchStart", "touchstart", function (a) {
          Ia[a.pointerId] = { pageX: a.pageX, pageY: a.pageY, target: a.currentTarget };
        });
      }, onContainerPointerMove: function onContainerPointerMove(a) {
        Pb(a, "onContainerTouchMove", "touchmove", function (a) {
          Ia[a.pointerId] = { pageX: a.pageX, pageY: a.pageY };if (!Ia[a.pointerId].target) Ia[a.pointerId].target = a.currentTarget;
        });
      }, onDocumentPointerUp: function onDocumentPointerUp(a) {
        Pb(a, "onDocumentTouchEnd", "touchend", function (a) {
          delete Ia[a.pointerId];
        });
      }, batchMSEvents: function batchMSEvents(a) {
        a(this.chart.container, Ob ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);a(this.chart.container, Ob ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);a(C, Ob ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      } });S(ab.prototype, "init", function (a, b, c) {
      a.call(this, b, c);this.hasZoom && O(b.container, { "-ms-touch-action": "none", "touch-action": "none" });
    });S(ab.prototype, "setDOMEvents", function (a) {
      a.apply(this);(this.hasZoom || this.followTouchMove) && this.batchMSEvents(G);
    });S(ab.prototype, "destroy", function (a) {
      this.batchMSEvents(U);
      a.call(this);
    });
  }var xb = B.Legend = function (a, b) {
    this.init(a, b);
  };xb.prototype = { init: function init(a, b) {
      var c = this,
          d = b.itemStyle,
          e = b.itemMarginTop || 0;this.options = b;if (b.enabled) c.itemStyle = d, c.itemHiddenStyle = D(d, b.itemHiddenStyle), c.itemMarginTop = e, c.padding = d = q(b.padding, 8), c.initialItemX = d, c.initialItemY = d - 5, c.maxItemWidth = 0, c.chart = a, c.itemHeight = 0, c.symbolWidth = q(b.symbolWidth, 16), c.pages = [], c.render(), G(c.chart, "endResize", function () {
        c.positionCheckboxes();
      });
    }, colorizeItem: function colorizeItem(a, b) {
      var c = this.options,
          d = a.legendItem,
          e = a.legendLine,
          f = a.legendSymbol,
          g = this.itemHiddenStyle.color,
          c = b ? c.itemStyle.color : g,
          h = b ? a.legendColor || a.color || "#CCC" : g,
          g = a.options && a.options.marker,
          i = { fill: h },
          j;d && d.css({ fill: c, color: c });e && e.attr({ stroke: h });if (f) {
        if (g && f.isMarker) for (j in i.stroke = h, g = a.convertAttribs(g), g) {
          d = g[j], d !== x && (i[j] = d);
        }f.attr(i);
      }
    }, positionItem: function positionItem(a) {
      var b = this.options,
          c = b.symbolPadding,
          b = !b.rtl,
          d = a._legendItemPos,
          e = d[0],
          d = d[1],
          f = a.checkbox;(a = a.legendGroup) && a.element && a.translate(b ? e : this.legendWidth - e - 2 * c - 4, d);if (f) f.x = e, f.y = d;
    }, destroyItem: function destroyItem(a) {
      var b = a.checkbox;o(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (b) {
        a[b] && (a[b] = a[b].destroy());
      });b && Wa(a.checkbox);
    }, destroy: function destroy() {
      var a = this.group,
          b = this.box;if (b) this.box = b.destroy();if (a) this.group = a.destroy();
    }, positionCheckboxes: function positionCheckboxes(a) {
      var b = this.group.alignAttr,
          c,
          d = this.clipHeight || this.legendHeight,
          e = this.titleHeight;if (b) c = b.translateY, o(this.allItems, function (f) {
        var g = f.checkbox,
            h;g && (h = c + e + g.y + (a || 0) + 3, O(g, { left: b.translateX + f.checkboxOffset + g.x - 20 + "px", top: h + "px", display: h > c - 6 && h < c + d - 6 ? "" : "none" }));
      });
    }, renderTitle: function renderTitle() {
      var a = this.padding,
          b = this.options.title,
          c = 0;if (b.text) {
        if (!this.title) this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({ zIndex: 1 }).css(b.style).add(this.group);a = this.title.getBBox();c = a.height;this.offsetWidth = a.width;this.contentGroup.attr({ translateY: c });
      }this.titleHeight = c;
    }, setText: function setText(a) {
      var b = this.options;a.legendItem.attr({ text: b.labelFormat ? Ma(b.labelFormat, a) : b.labelFormatter.call(a) });
    }, renderItem: function renderItem(a) {
      var b = this.chart,
          c = b.renderer,
          d = this.options,
          e = d.layout === "horizontal",
          f = this.symbolWidth,
          g = d.symbolPadding,
          h = this.itemStyle,
          i = this.itemHiddenStyle,
          j = this.padding,
          k = e ? q(d.itemDistance, 20) : 0,
          l = !d.rtl,
          m = d.width,
          n = d.itemMarginBottom || 0,
          p = this.itemMarginTop,
          r = this.initialItemX,
          s = a.legendItem,
          o = a.series && a.series.drawLegendSymbol ? a.series : a,
          u = o.options,
          u = this.createCheckboxForItem && u && u.showCheckbox,
          w = d.useHTML;if (!s) {
        a.legendGroup = c.g("legend-item").attr({ zIndex: 1 }).add(this.scrollGroup);a.legendItem = s = c.text("", l ? f + g : -g, this.baseline || 0, w).css(D(a.visible ? h : i)).attr({ align: l ? "left" : "right", zIndex: 2 }).add(a.legendGroup);if (!this.baseline) this.fontMetrics = c.fontMetrics(h.fontSize, s), this.baseline = this.fontMetrics.f + 3 + p, s.attr("y", this.baseline);o.drawLegendSymbol(this, a);this.setItemEvents && this.setItemEvents(a, s, w, h, i);u && this.createCheckboxForItem(a);
      }this.colorizeItem(a, a.visible);this.setText(a);c = s.getBBox();f = a.checkboxOffset = d.itemWidth || a.legendItemWidth || f + g + c.width + k + (u ? 20 : 0);this.itemHeight = g = A(a.legendItemHeight || c.height);if (e && this.itemX - r + f > (m || b.chartWidth - 2 * j - r - d.x)) this.itemX = r, this.itemY += p + this.lastLineHeight + n, this.lastLineHeight = 0;this.maxItemWidth = y(this.maxItemWidth, f);this.lastItemY = p + this.itemY + n;this.lastLineHeight = y(g, this.lastLineHeight);a._legendItemPos = [this.itemX, this.itemY];e ? this.itemX += f : (this.itemY += p + g + n, this.lastLineHeight = g);this.offsetWidth = m || y((e ? this.itemX - r - k : f) + j, this.offsetWidth);
    },
    getAllItems: function getAllItems() {
      var a = [];o(this.chart.series, function (b) {
        var c = b.options;if (q(c.showInLegend, !t(c.linkedTo) ? x : !1, !0)) a = a.concat(b.legendItems || (c.legendType === "point" ? b.data : b));
      });return a;
    }, adjustMargins: function adjustMargins(a, b) {
      var c = this.chart,
          d = this.options,
          e = d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);d.floating || o([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (f, g) {
        f.test(e) && !t(a[g]) && (c[wb[g]] = y(c[wb[g]], c.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * d[g % 2 ? "x" : "y"] + q(d.margin, 12) + b[g]));
      });
    }, render: function render() {
      var a = this,
          b = a.chart,
          c = b.renderer,
          d = a.group,
          e,
          f,
          g,
          h,
          i = a.box,
          j = a.options,
          k = a.padding,
          l = j.borderWidth,
          m = j.backgroundColor;a.itemX = a.initialItemX;a.itemY = a.initialItemY;a.offsetWidth = 0;a.lastItemY = 0;if (!d) a.group = d = c.g("legend").attr({ zIndex: 7 }).add(), a.contentGroup = c.g().attr({ zIndex: 1 }).add(d), a.scrollGroup = c.g().add(a.contentGroup);a.renderTitle();e = a.getAllItems();pb(e, function (a, b) {
        return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
      });j.reversed && e.reverse();a.allItems = e;a.display = f = !!e.length;a.lastLineHeight = 0;o(e, function (b) {
        a.renderItem(b);
      });g = (j.width || a.offsetWidth) + k;h = a.lastItemY + a.lastLineHeight + a.titleHeight;h = a.handleOverflow(h);h += k;if (l || m) {
        if (i) {
          if (g > 0 && h > 0) i[i.isNew ? "attr" : "animate"](i.crisp({ width: g, height: h })), i.isNew = !1;
        } else a.box = i = c.rect(0, 0, g, h, j.borderRadius, l || 0).attr({ stroke: j.borderColor, "stroke-width": l || 0, fill: m || "none" }).add(d).shadow(j.shadow), i.isNew = !0;i[f ? "show" : "hide"]();
      }a.legendWidth = g;a.legendHeight = h;o(e, function (b) {
        a.positionItem(b);
      });f && d.align(v({ width: g, height: h }, j), !0, "spacingBox");b.isResizing || this.positionCheckboxes();
    }, handleOverflow: function handleOverflow(a) {
      var b = this,
          c = this.chart,
          d = c.renderer,
          e = this.options,
          f = e.y,
          f = c.spacingBox.height + (e.verticalAlign === "top" ? -f : f) - this.padding,
          g = e.maxHeight,
          h,
          i = this.clipRect,
          j = e.navigation,
          k = q(j.animation, !0),
          l = j.arrowSize || 12,
          m = this.nav,
          n = this.pages,
          p = this.padding,
          r,
          s = this.allItems,
          Z = function Z(a) {
        i.attr({ height: a });
        if (b.contentGroup.div) b.contentGroup.div.style.clip = "rect(" + p + "px,9999px," + (p + a) + "px,0)";
      };e.layout === "horizontal" && (f /= 2);g && (f = E(f, g));n.length = 0;if (a > f && j.enabled !== !1) {
        this.clipHeight = h = y(f - 20 - this.titleHeight - p, 0);this.currentPage = q(this.currentPage, 1);this.fullHeight = a;o(s, function (a, b) {
          var c = a._legendItemPos[1],
              d = A(a.legendItem.getBBox().height),
              e = n.length;if (!e || c - n[e - 1] > h && (r || c) !== n[e - 1]) n.push(r || c), e++;b === s.length - 1 && c + d - n[e - 1] > h && n.push(c);c !== r && (r = c);
        });if (!i) i = b.clipRect = d.clipRect(0, p, 9999, 0), b.contentGroup.clip(i);Z(h);if (!m) this.nav = m = d.g().attr({ zIndex: 1 }).add(this.group), this.up = d.symbol("triangle", 0, 0, l, l).on("click", function () {
          b.scroll(-1, k);
        }).add(m), this.pager = d.text("", 15, 10).css(j.style).add(m), this.down = d.symbol("triangle-down", 0, 0, l, l).on("click", function () {
          b.scroll(1, k);
        }).add(m);b.scroll(0);a = f;
      } else if (m) Z(c.chartHeight), m.hide(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0;return a;
    }, scroll: function scroll(a, b) {
      var c = this.pages,
          d = c.length,
          e = this.currentPage + a,
          f = this.clipHeight,
          g = this.options.navigation,
          h = g.activeColor,
          g = g.inactiveColor,
          i = this.pager,
          j = this.padding;e > d && (e = d);if (e > 0) b !== x && cb(b, this.chart), this.nav.attr({ translateX: j, translateY: f + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ fill: e === 1 ? g : h }).css({ cursor: e === 1 ? "default" : "pointer" }), i.attr({ text: e + "/" + d }), this.down.attr({ x: 18 + this.pager.getBBox().width, fill: e === d ? g : h }).css({ cursor: e === d ? "default" : "pointer" }), c = -c[e - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: c }), this.currentPage = e, this.positionCheckboxes(c);
    } };da = B.LegendSymbolMixin = { drawRectangle: function drawRectangle(a, b) {
      var c = a.options.symbolHeight || a.fontMetrics.f;b.legendSymbol = this.chart.renderer.rect(0, a.baseline - c + 1, a.symbolWidth, c, a.options.symbolRadius || 0).attr({ zIndex: 3 }).add(b.legendGroup);
    }, drawLineMarker: function drawLineMarker(a) {
      var b = this.options,
          c = b.marker,
          d = a.symbolWidth,
          e = this.chart.renderer,
          f = this.legendGroup,
          a = a.baseline - A(a.fontMetrics.b * 0.3),
          g;if (b.lineWidth) {
        g = { "stroke-width": b.lineWidth };if (b.dashStyle) g.dashstyle = b.dashStyle;this.legendLine = e.path([W, 0, a, R, d, a]).attr(g).add(f);
      }if (c && c.enabled !== !1) b = c.radius, this.legendSymbol = c = e.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b, c).add(f), c.isMarker = !0;
    } };(/Trident\/7\.0/.test(Pa) || Ya) && S(xb.prototype, "positionItem", function (a, b) {
    var c = this,
        d = function d() {
      b._legendItemPos && a.call(c, b);
    };d();setTimeout(d);
  });var Da = B.Chart = function () {
    this.getArgs.apply(this, arguments);
  };B.chart = function (a, b, c) {
    return new Da(a, b, c);
  };Da.prototype = { callbacks: [], getArgs: function getArgs() {
      var a = [].slice.call(arguments);
      if (Ea(a[0]) || a[0].nodeName) this.renderTo = a.shift();this.init(a[0], a[1]);
    }, init: function init(a, b) {
      var c,
          d = a.series;a.series = null;c = D(Q, a);c.series = a.series = d;this.userOptions = a;d = c.chart;this.margin = this.splashArray("margin", d);this.spacing = this.splashArray("spacing", d);var e = d.events;this.bounds = { h: {}, v: {} };this.callback = b;this.isResizing = 0;this.options = c;this.axes = [];this.series = [];this.hasCartesianSeries = d.showAxes;var f = this,
          g;f.index = ca.length;ca.push(f);mb++;d.reflow !== !1 && G(f, "load", function () {
        f.initReflow();
      });
      if (e) for (g in e) {
        G(f, g, e[g]);
      }f.xAxis = [];f.yAxis = [];f.animation = ua ? !1 : q(d.animation, !0);f.pointCount = f.colorCounter = f.symbolCounter = 0;f.firstRender();
    }, initSeries: function initSeries(a) {
      var b = this.options.chart;(b = I[a.type || b.type || b.defaultSeriesType]) || ja(17, !0);b = new b();b.init(this, a);return b;
    }, isInsidePlot: function isInsidePlot(a, b, c) {
      var d = c ? b : a,
          a = c ? a : b;return d >= 0 && d <= this.plotWidth && a >= 0 && a <= this.plotHeight;
    }, redraw: function redraw(a) {
      var b = this.axes,
          c = this.series,
          d = this.pointer,
          e = this.legend,
          f = this.isDirtyLegend,
          g,
          h,
          i = this.hasCartesianSeries,
          j = this.isDirtyBox,
          k = c.length,
          l = k,
          m = this.renderer,
          n = m.isHidden(),
          p = [];cb(a, this);n && this.cloneRenderTo();for (this.layOutTitles(); l--;) {
        if (a = c[l], a.options.stacking && (g = !0, a.isDirty)) {
          h = !0;break;
        }
      }if (h) for (l = k; l--;) {
        if (a = c[l], a.options.stacking) a.isDirty = !0;
      }o(c, function (a) {
        a.isDirty && a.options.legendType === "point" && (a.updateTotals && a.updateTotals(), f = !0);a.isDirtyData && K(a, "updatedData");
      });if (f && e.options.enabled) e.render(), this.isDirtyLegend = !1;g && this.getStacks();if (i && !this.isResizing) this.maxTicks = null, o(b, function (a) {
        a.setScale();
      });this.getMargins();i && (o(b, function (a) {
        a.isDirty && (j = !0);
      }), o(b, function (a) {
        var b = a.min + "," + a.max;if (a.extKey !== b) a.extKey = b, p.push(function () {
          K(a, "afterSetExtremes", v(a.eventArgs, a.getExtremes()));delete a.eventArgs;
        });(j || g) && a.redraw();
      }));j && this.drawChartBox();o(c, function (a) {
        a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw();
      });d && d.reset(!0);m.draw();K(this, "redraw");n && this.cloneRenderTo(!0);o(p, function (a) {
        a.call();
      });
    }, get: function get(a) {
      var b = this.axes,
          c = this.series,
          d,
          e;for (d = 0; d < b.length; d++) {
        if (b[d].options.id === a) return b[d];
      }for (d = 0; d < c.length; d++) {
        if (c[d].options.id === a) return c[d];
      }for (d = 0; d < c.length; d++) {
        e = c[d].points || [];for (b = 0; b < e.length; b++) {
          if (e[b].id === a) return e[b];
        }
      }return null;
    }, getAxes: function getAxes() {
      var a = this,
          b = this.options,
          c = b.xAxis = sa(b.xAxis || {}),
          b = b.yAxis = sa(b.yAxis || {});o(c, function (a, b) {
        a.index = b;a.isX = !0;
      });o(b, function (a, b) {
        a.index = b;
      });c = c.concat(b);o(c, function (b) {
        new J(a, b);
      });
    }, getSelectedPoints: function getSelectedPoints() {
      var a = [];o(this.series, function (b) {
        a = a.concat(Ha(b.points || [], function (a) {
          return a.selected;
        }));
      });return a;
    }, getSelectedSeries: function getSelectedSeries() {
      return Ha(this.series, function (a) {
        return a.selected;
      });
    }, setTitle: function setTitle(a, b, c) {
      var g;var d = this,
          e = d.options,
          f;f = e.title = D(e.title, a);g = e.subtitle = D(e.subtitle, b), e = g;o([["title", a, f], ["subtitle", b, e]], function (a) {
        var b = a[0],
            c = d[b],
            e = a[1],
            a = a[2];c && e && (d[b] = c = c.destroy());a && a.text && !c && (d[b] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({ align: a.align, "class": "highcharts-" + b, zIndex: a.zIndex || 4 }).css(a.style).add());
      });d.layOutTitles(c);
    }, layOutTitles: function layOutTitles(a) {
      var b = 0,
          c = this.title,
          d = this.subtitle,
          e = this.options,
          f = e.title,
          e = e.subtitle,
          g = this.renderer,
          h = this.spacingBox;if (c && (c.css({ width: (f.width || h.width + f.widthAdjust) + "px" }).align(v({ y: g.fontMetrics(f.style.fontSize, c).b - 3 }, f), !1, h), !f.floating && !f.verticalAlign)) b = c.getBBox().height;d && (d.css({ width: (e.width || h.width + e.widthAdjust) + "px" }).align(v({ y: b + (f.margin - 13) + g.fontMetrics(e.style.fontSize, c).b }, e), !1, h), !e.floating && !e.verticalAlign && (b = Ga(b + d.getBBox().height)));c = this.titleOffset !== b;this.titleOffset = b;if (!this.isDirtyBox && c) this.isDirtyBox = c, this.hasRendered && q(a, !0) && this.isDirtyBox && this.redraw();
    }, getChartSize: function getChartSize() {
      var a = this.options.chart,
          b = a.width,
          a = a.height,
          c = this.renderToClone || this.renderTo;if (!t(b)) this.containerWidth = _ya2(c, "width");if (!t(a)) this.containerHeight = _ya2(c, "height");this.chartWidth = y(0, b || this.containerWidth || 600);this.chartHeight = y(0, q(a, this.containerHeight > 19 ? this.containerHeight : 400));
    }, cloneRenderTo: function cloneRenderTo(a) {
      var b = this.renderToClone,
          c = this.container;a ? b && (this.renderTo.appendChild(c), Wa(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), O(b, { position: "absolute", top: "-9999px", display: "block" }), b.style.setProperty && b.style.setProperty("display", "block", "important"), C.body.appendChild(b), c && b.appendChild(c));
    }, getContainer: function getContainer() {
      var a,
          b = this.options,
          c = b.chart,
          d,
          e;a = this.renderTo;var f = "highcharts-" + Lb++;if (!a) this.renderTo = a = c.renderTo;if (Ea(a)) this.renderTo = a = C.getElementById(a);a || ja(13, !0);d = H($(a, "data-highcharts-chart"));z(d) && ca[d] && ca[d].hasRendered && ca[d].destroy();$(a, "data-highcharts-chart", this.index);a.innerHTML = "";!c.skipClone && !a.offsetWidth && this.cloneRenderTo();this.getChartSize();d = this.chartWidth;e = this.chartHeight;this.container = a = ia(Xa, { className: "highcharts-container" + (c.className ? " " + c.className : ""), id: f }, v({ position: "relative", overflow: "hidden", width: d + "px", height: e + "px", textAlign: "left", lineHeight: "normal",
        zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, c.style), this.renderToClone || a);this._cursor = a.style.cursor;this.renderer = new (B[c.renderer] || Za)(a, d, e, c.style, c.forExport, b.exporting && b.exporting.allowHTML);ua && this.renderer.create(this, a, d, e);this.renderer.chartIndex = this.index;
    }, getMargins: function getMargins(a) {
      var b = this.spacing,
          c = this.margin,
          d = this.titleOffset;this.resetMargins();if (d && !t(c[0])) this.plotTop = y(this.plotTop, d + this.options.title.margin + b[0]);this.legend.display && this.legend.adjustMargins(c, b);this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin);this.extraTopMargin && (this.plotTop += this.extraTopMargin);a || this.getAxisMargins();
    }, getAxisMargins: function getAxisMargins() {
      var a = this,
          b = a.axisOffset = [0, 0, 0, 0],
          c = a.margin;a.hasCartesianSeries && o(a.axes, function (a) {
        a.visible && a.getOffset();
      });o(wb, function (d, e) {
        t(c[e]) || (a[d] += b[e]);
      });a.setChartSize();
    }, reflow: function reflow(a) {
      var b = this,
          c = b.options.chart,
          d = b.renderTo,
          e = t(c.width),
          f = c.width || _ya2(d, "width"),
          c = c.height || _ya2(d, "height"),
          d = a ? a.target : M;if (!e && !b.isPrinting && f && c && (d === M || d === C)) {
        if (f !== b.containerWidth || c !== b.containerHeight) clearTimeout(b.reflowTimeout), b.reflowTimeout = bb(function () {
          b.container && b.setSize(void 0, void 0, !1);
        }, a ? 100 : 0);b.containerWidth = f;b.containerHeight = c;
      }
    }, initReflow: function initReflow() {
      var a = this,
          b = function b(_b2) {
        a.reflow(_b2);
      };G(M, "resize", b);G(a, "destroy", function () {
        U(M, "resize", b);
      });
    }, setSize: function setSize(a, b, c) {
      var d = this,
          e = d.renderer;d.isResizing += 1;cb(c, d);d.oldChartHeight = d.chartHeight;d.oldChartWidth = d.chartWidth;if (a !== void 0) d.options.chart.width = a;if (b !== void 0) d.options.chart.height = b;d.getChartSize();a = e.globalAnimation;(a ? fb : O)(d.container, { width: d.chartWidth + "px", height: d.chartHeight + "px" }, a);d.setChartSize(!0);e.setSize(d.chartWidth, d.chartHeight, c);d.maxTicks = null;o(d.axes, function (a) {
        a.isDirty = !0;a.setScale();
      });o(d.series, function (a) {
        a.isDirty = !0;
      });d.isDirtyLegend = !0;d.isDirtyBox = !0;d.layOutTitles();d.getMargins();d.redraw(c);d.oldChartHeight = null;K(d, "resize");bb(function () {
        d && K(d, "endResize", null, function () {
          d.isResizing -= 1;
        });
      }, ib(a).duration);
    },
    setChartSize: function setChartSize(a) {
      var b = this.inverted,
          c = this.renderer,
          d = this.chartWidth,
          e = this.chartHeight,
          f = this.options.chart,
          g = this.spacing,
          h = this.clipOffset,
          i,
          j,
          k,
          l;this.plotLeft = i = A(this.plotLeft);this.plotTop = j = A(this.plotTop);this.plotWidth = k = y(0, A(d - i - this.marginRight));this.plotHeight = l = y(0, A(e - j - this.marginBottom));this.plotSizeX = b ? l : k;this.plotSizeY = b ? k : l;this.plotBorderWidth = f.plotBorderWidth || 0;this.spacingBox = c.spacingBox = { x: g[3], y: g[0], width: d - g[3] - g[1], height: e - g[0] - g[2] };this.plotBox = c.plotBox = { x: i, y: j, width: k, height: l };d = 2 * Y(this.plotBorderWidth / 2);b = Ga(y(d, h[3]) / 2);c = Ga(y(d, h[0]) / 2);this.clipBox = { x: b, y: c, width: Y(this.plotSizeX - y(d, h[1]) / 2 - b), height: y(0, Y(this.plotSizeY - y(d, h[2]) / 2 - c)) };a || o(this.axes, function (a) {
        a.setAxisSize();a.setAxisTranslation();
      });
    }, resetMargins: function resetMargins() {
      var a = this;o(wb, function (b, c) {
        a[b] = q(a.margin[c], a.spacing[c]);
      });a.axisOffset = [0, 0, 0, 0];a.clipOffset = [0, 0, 0, 0];
    }, drawChartBox: function drawChartBox() {
      var a = this.options.chart,
          b = this.renderer,
          c = this.chartWidth,
          d = this.chartHeight,
          e = this.chartBackground,
          f = this.plotBackground,
          g = this.plotBorder,
          h = this.plotBGImage,
          i = a.borderWidth || 0,
          j = a.backgroundColor,
          k = a.plotBackgroundColor,
          l = a.plotBackgroundImage,
          m = a.plotBorderWidth || 0,
          n,
          p = this.plotLeft,
          r = this.plotTop,
          s = this.plotWidth,
          q = this.plotHeight,
          o = this.plotBox,
          w = this.clipRect,
          F = this.clipBox;n = i + (a.shadow ? 8 : 0);if (i || j) if (e) e.animate(e.crisp({ width: c - n, height: d - n }));else {
        e = { fill: j || "none" };if (i) e.stroke = a.borderColor, e["stroke-width"] = i;this.chartBackground = b.rect(n / 2, n / 2, c - n, d - n, a.borderRadius, i).attr(e).addClass("highcharts-background").add().shadow(a.shadow);
      }if (k) f ? f.animate(o) : this.plotBackground = b.rect(p, r, s, q, 0).attr({ fill: k }).add().shadow(a.plotShadow);if (l) h ? h.animate(o) : this.plotBGImage = b.image(l, p, r, s, q).add();w ? w.animate({ width: F.width, height: F.height }) : this.clipRect = b.clipRect(F);if (m) g ? (g.strokeWidth = -m, g.animate(g.crisp({ x: p, y: r, width: s, height: q }))) : this.plotBorder = b.rect(p, r, s, q, 0, -m).attr({ stroke: a.plotBorderColor, "stroke-width": m, fill: "none", zIndex: 1 }).add();this.isDirtyBox = !1;
    }, propFromSeries: function propFromSeries() {
      var a = this,
          b = a.options.chart,
          c,
          d = a.options.series,
          e,
          f;o(["inverted", "angular", "polar"], function (g) {
        c = I[b.type || b.defaultSeriesType];f = a[g] || b[g] || c && c.prototype[g];for (e = d && d.length; !f && e--;) {
          (c = I[d[e].type]) && c.prototype[g] && (f = !0);
        }a[g] = f;
      });
    }, linkSeries: function linkSeries() {
      var a = this,
          b = a.series;o(b, function (a) {
        a.linkedSeries.length = 0;
      });o(b, function (b) {
        var d = b.options.linkedTo;if (Ea(d) && (d = d === ":previous" ? a.series[b.index - 1] : a.get(d))) d.linkedSeries.push(b), b.linkedParent = d, b.visible = q(b.options.visible, d.options.visible, b.visible);
      });
    }, renderSeries: function renderSeries() {
      o(this.series, function (a) {
        a.translate();a.render();
      });
    }, renderLabels: function renderLabels() {
      var a = this,
          b = a.options.labels;b.items && o(b.items, function (c) {
        var d = v(b.style, c.style),
            e = H(d.left) + a.plotLeft,
            f = H(d.top) + a.plotTop + 12;delete d.left;delete d.top;a.renderer.text(c.html, e, f).attr({ zIndex: 2 }).css(d).add();
      });
    }, render: function render() {
      var a = this.axes,
          b = this.renderer,
          c = this.options,
          d,
          e,
          f,
          g;this.setTitle();this.legend = new xb(this, c.legend);this.getStacks && this.getStacks();this.getMargins(!0);this.setChartSize();d = this.plotWidth;e = this.plotHeight -= 21;o(a, function (a) {
        a.setScale();
      });this.getAxisMargins();f = d / this.plotWidth > 1.1;g = e / this.plotHeight > 1.05;if (f || g) this.maxTicks = null, o(a, function (a) {
        (a.horiz && f || !a.horiz && g) && a.setTickInterval(!0);
      }), this.getMargins();this.drawChartBox();this.hasCartesianSeries && o(a, function (a) {
        a.visible && a.render();
      });if (!this.seriesGroup) this.seriesGroup = b.g("series-group").attr({ zIndex: 3 }).add();this.renderSeries();this.renderLabels();
      this.showCredits(c.credits);this.hasRendered = !0;
    }, showCredits: function showCredits(a) {
      if (a.enabled && !this.credits) this.credits = this.renderer.text(a.text, 0, 0).on("click", function () {
        if (a.href) M.location.href = a.href;
      }).attr({ align: a.position.align, zIndex: 8 }).css(a.style).add().align(a.position);
    }, destroy: function destroy() {
      var a = this,
          b = a.axes,
          c = a.series,
          d = a.container,
          e,
          f = d && d.parentNode;K(a, "destroy");ca[a.index] = x;mb--;a.renderTo.removeAttribute("data-highcharts-chart");U(a);for (e = b.length; e--;) {
        b[e] = b[e].destroy();
      }for (e = c.length; e--;) {
        c[e] = c[e].destroy();
      }o("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","), function (b) {
        var c = a[b];c && c.destroy && (a[b] = c.destroy());
      });if (d) d.innerHTML = "", U(d), f && Wa(d);for (e in a) {
        delete a[e];
      }
    }, isReadyToRender: function isReadyToRender() {
      var a = this;return !ma && M == M.top && C.readyState !== "complete" || ua && !M.canvg ? (ua ? Zb.push(function () {
        a.firstRender();
      }, a.options.global.canvasToolsURL) : C.attachEvent("onreadystatechange", function () {
        C.detachEvent("onreadystatechange", a.firstRender);C.readyState === "complete" && a.firstRender();
      }), !1) : !0;
    }, firstRender: function firstRender() {
      var a = this,
          b = a.options;if (a.isReadyToRender()) {
        a.getContainer();K(a, "init");a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();o(b.series || [], function (b) {
          a.initSeries(b);
        });a.linkSeries();K(a, "beforeRender");if (B.Pointer) a.pointer = new ab(a, b);a.render();a.renderer.draw();if (!a.renderer.imgCount && a.onload) a.onload();
        a.cloneRenderTo(!0);
      }
    }, onload: function onload() {
      var a = this;o([this.callback].concat(this.callbacks), function (b) {
        b && a.index !== void 0 && b.apply(a, [a]);
      });K(a, "load");this.onload = null;
    }, splashArray: function splashArray(a, b) {
      var c = b[a],
          c = ha(c) ? c : [c, c, c, c];return [q(b[a + "Top"], c[0]), q(b[a + "Right"], c[1]), q(b[a + "Bottom"], c[2]), q(b[a + "Left"], c[3])];
    } };var ec = B.CenteredSeriesMixin = { getCenter: function getCenter() {
      var a = this.options,
          b = this.chart,
          c = 2 * (a.slicedOffset || 0),
          d = b.plotWidth - 2 * c,
          b = b.plotHeight - 2 * c,
          e = a.center,
          e = [q(e[0], "50%"), q(e[1], "50%"), a.size || "100%", a.innerSize || 0],
          f = E(d, b),
          g,
          h;for (g = 0; g < 4; ++g) {
        h = e[g], a = g < 2 || g === 2 && /%$/.test(h), e[g] = (/%$/.test(h) ? [d, b, f, e[2]][g] * parseFloat(h) / 100 : parseFloat(h)) + (a ? c : 0);
      }e[3] > e[2] && (e[3] = e[2]);return e;
    } },
      Ja = function Ja() {};Ja.prototype = { init: function init(a, b, c) {
      this.series = a;this.color = a.color;this.applyOptions(b, c);this.pointAttr = {};if (a.options.colorByPoint && (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter++], a.colorCounter === b.length)) a.colorCounter = 0;a.chart.pointCount++;
      return this;
    }, applyOptions: function applyOptions(a, b) {
      var c = this.series,
          d = c.options.pointValKey || c.pointValKey,
          a = Ja.prototype.optionsToObject.call(this, a);v(this, a);this.options = this.options ? v(this.options, a) : a;if (d) this.y = this[d];this.isNull = this.x === null || !z(this.y, !0);if (this.x === void 0 && c) this.x = b === void 0 ? c.autoIncrement(this) : b;if (c.xAxis && c.xAxis.names) c.xAxis.names[this.x] = this.name;return this;
    }, optionsToObject: function optionsToObject(a) {
      var b = {},
          c = this.series,
          d = c.options.keys,
          e = d || c.pointArrayMap || ["y"],
          f = e.length,
          g = 0,
          h = 0;if (z(a) || a === null) b[e[0]] = a;else if (Ra(a)) {
        if (!d && a.length > f) {
          c = _typeof(a[0]);if (c === "string") b.name = a[0];else if (c === "number") b.x = a[0];g++;
        }for (; h < f;) {
          if (!d || a[g] !== void 0) b[e[h]] = a[g];g++;h++;
        }
      } else if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === "object") {
        b = a;if (a.dataLabels) c._hasPointLabels = !0;if (a.marker) c._hasPointMarkers = !0;
      }return b;
    }, destroy: function destroy() {
      var a = this.series.chart,
          b = a.hoverPoints,
          c;a.pointCount--;if (b && (this.setState(), Ba(b, this), !b.length)) a.hoverPoints = null;if (this === a.hoverPoint) this.onMouseOut();if (this.graphic || this.dataLabel) U(this), this.destroyElements();this.legendItem && a.legend.destroyItem(this);for (c in this) {
        this[c] = null;
      }
    }, destroyElements: function destroyElements() {
      for (var a = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], b, c = 6; c--;) {
        b = a[c], this[b] && (this[b] = this[b].destroy());
      }
    }, getLabelConfig: function getLabelConfig() {
      return { x: this.category, y: this.y, color: this.color, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
    }, tooltipFormatter: function tooltipFormatter(a) {
      var b = this.series,
          c = b.tooltipOptions,
          d = q(c.valueDecimals, ""),
          e = c.valuePrefix || "",
          f = c.valueSuffix || "";o(b.pointArrayMap || ["y"], function (b) {
        b = "{point." + b;if (e || f) a = a.replace(b + "}", e + b + "}" + f);a = a.replace(b + "}", b + ":,." + d + "f}");
      });return Ma(a, { point: this, series: this.series });
    }, firePointEvent: function firePointEvent(a, b, c) {
      var d = this,
          e = this.series.options;(e.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();a === "click" && e.allowPointSelect && (c = function c(a) {
        d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
      });K(this, a, b, c);
    }, visible: !0 };var P = B.Series = function () {};P.prototype = { isCartesian: !0, type: "line", pointClass: Ja, sorted: !0, requireSorting: !0, pointAttrToOptions: { stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor", r: "radius" }, directTouch: !1, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], init: function init(a, b) {
      var c = this,
          d,
          e,
          f = a.series,
          g = function g(a, b) {
        return q(a.options.index, a._i) - q(b.options.index, b._i);
      };c.chart = a;c.options = b = c.setOptions(b);c.linkedSeries = [];c.bindAxes();v(c, { name: b.name, state: "", pointAttr: {}, visible: b.visible !== !1, selected: b.selected === !0 });if (ua) b.animation = !1;e = b.events;for (d in e) {
        G(c, d, e[d]);
      }if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;c.getColor();c.getSymbol();o(c.parallelArrays, function (a) {
        c[a + "Data"] = [];
      });c.setData(b.data, !1);if (c.isCartesian) a.hasCartesianSeries = !0;f.push(c);c._i = f.length - 1;pb(f, g);this.yAxis && pb(this.yAxis.series, g);o(f, function (a, b) {
        a.index = b;a.name = a.name || "Series " + (b + 1);
      });
    }, bindAxes: function bindAxes() {
      var a = this,
          b = a.options,
          c = a.chart,
          d;o(a.axisTypes || [], function (e) {
        o(c[e], function (c) {
          d = c.options;if (b[e] === d.index || b[e] !== x && b[e] === d.id || b[e] === x && d.index === 0) c.series.push(a), a[e] = c, c.isDirty = !0;
        });!a[e] && a.optionalAxis !== e && ja(18, !0);
      });
    }, updateParallelArrays: function updateParallelArrays(a, b) {
      var c = a.series,
          d = arguments,
          e = z(b) ? function (d) {
        var e = d === "y" && c.toYData ? c.toYData(a) : a[d];c[d + "Data"][b] = e;
      } : function (a) {
        Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2));
      };o(c.parallelArrays, e);
    }, autoIncrement: function autoIncrement(a) {
      var g;var b = this.options,
          c = this.xIncrement,
          d = b.pointIntervalUnit,
          e = this.xAxis,
          f,
          c = q(c, b.pointStart, 0);this.pointInterval = b = q(this.pointInterval, b.pointInterval, 1);if (e && e.categories && a.name) if (this.requireSorting = !1, g = (f = Ra(e.categories)) ? e.categories : e.names, e = g, a = qa(a.name, e), a === -1) {
        if (!f) c = e.length;
      } else c = a;d && (a = new ea(c), d === "day" ? a = +a[sb](a[db]() + b) : d === "month" ? a = +a[Hb](a[jb]() + b) : d === "year" && (a = +a[Ib](a[kb]() + b)), b = a - c);this.xIncrement = c + b;return c;
    }, setOptions: function setOptions(a) {
      var b = this.chart,
          c = b.options.plotOptions,
          b = b.userOptions || {},
          d = b.plotOptions || {},
          e = c[this.type];this.userOptions = a;c = D(e, c.series, a);this.tooltipOptions = D(Q.tooltip, Q.plotOptions[this.type].tooltip, b.tooltip, d.series && d.series.tooltip, d[this.type] && d[this.type].tooltip, a.tooltip);e.marker === null && delete c.marker;this.zoneAxis = c.zoneAxis;a = this.zones = (c.zones || []).slice();if ((c.negativeColor || c.negativeFillColor) && !c.zones) a.push({ value: c[this.zoneAxis + "Threshold"] || c.threshold || 0, color: c.negativeColor, fillColor: c.negativeFillColor });a.length && t(a[a.length - 1].value) && a.push({ color: this.color, fillColor: this.fillColor });return c;
    }, getCyclic: function getCyclic(a, b, c) {
      var d = this.userOptions,
          e = "_" + a + "Index",
          f = a + "Counter";b || (t(d[e]) ? b = d[e] : (d[e] = b = this.chart[f] % c.length, this.chart[f] += 1), b = c[b]);this[a] = b;
    }, getColor: function getColor() {
      this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || X[this.type].color, this.chart.options.colors);
    }, getSymbol: function getSymbol() {
      var a = this.options.marker;this.getCyclic("symbol", a.symbol, this.chart.options.symbols);if (/^url/.test(this.symbol)) a.radius = 0;
    }, drawLegendSymbol: da.drawLineMarker, setData: function setData(a, b, c, d) {
      var e = this,
          f = e.points,
          g = f && f.length || 0,
          h,
          i = e.options,
          j = e.chart,
          k = null,
          l = e.xAxis,
          m = i.turboThreshold,
          n = this.xData,
          p = this.yData,
          r = (h = e.pointArrayMap) && h.length,
          a = a || [];h = a.length;b = q(b, !0);if (d !== !1 && h && g === h && !e.cropped && !e.hasGroupedData && e.visible) o(a, function (a, b) {
        f[b].update && a !== i.data[b] && f[b].update(a, !1, null, !1);
      });else {
        e.xIncrement = null;e.colorCounter = 0;o(this.parallelArrays, function (a) {
          e[a + "Data"].length = 0;
        });if (m && h > m) {
          for (c = 0; k === null && c < h;) {
            k = a[c], c++;
          }if (z(k)) {
            k = q(i.pointStart, 0);r = q(i.pointInterval, 1);for (c = 0; c < h; c++) {
              n[c] = k, p[c] = a[c], k += r;
            }e.xIncrement = k;
          } else if (Ra(k)) {
            if (r) for (c = 0; c < h; c++) {
              k = a[c], n[c] = k[0], p[c] = k.slice(1, r + 1);
            } else for (c = 0; c < h; c++) {
              k = a[c], n[c] = k[0], p[c] = k[1];
            }
          } else ja(12);
        } else for (c = 0; c < h; c++) {
          a[c] !== x && (k = { series: e }, e.pointClass.prototype.applyOptions.apply(k, [a[c]]), e.updateParallelArrays(k, c));
        }Ea(p[0]) && ja(14, !0);e.data = [];e.options.data = e.userOptions.data = a;for (c = g; c--;) {
          f[c] && f[c].destroy && f[c].destroy();
        }if (l) l.minRange = l.userMinRange;e.isDirty = e.isDirtyData = j.isDirtyBox = !0;c = !1;
      }i.legendType === "point" && (this.processData(), this.generatePoints());b && j.redraw(c);
    }, processData: function processData(a) {
      var b = this.xData,
          c = this.yData,
          d = b.length,
          e;e = 0;var f,
          g,
          h = this.xAxis,
          i,
          j = this.options;i = j.cropThreshold;var k = this.getExtremesFromAll || j.getExtremesFromAll,
          l = this.isCartesian,
          j = h && h.val2lin,
          m = h && h.isLog,
          n,
          p;if (l && !this.isDirty && !h.isDirty && !this.yAxis.isDirty && !a) return !1;if (h) a = h.getExtremes(), n = a.min, p = a.max;if (l && this.sorted && !k && (!i || d > i || this.forceCrop)) if (b[d - 1] < n || b[0] > p) b = [], c = [];else if (b[0] < n || b[d - 1] > p) e = this.cropData(this.xData, this.yData, n, p), b = e.xData, c = e.yData, e = e.start, f = !0;for (i = b.length || 1; --i;) {
        d = m ? j(b[i]) - j(b[i - 1]) : b[i] - b[i - 1], d > 0 && (g === x || d < g) ? g = d : d < 0 && this.requireSorting && ja(15);
      }this.cropped = f;this.cropStart = e;this.processedXData = b;this.processedYData = c;this.closestPointRange = g;
    }, cropData: function cropData(a, b, c, d) {
      var e = a.length,
          f = 0,
          g = e,
          h = q(this.cropShoulder, 1),
          i;for (i = 0; i < e; i++) {
        if (a[i] >= c) {
          f = y(0, i - h);break;
        }
      }for (c = i; c < e; c++) {
        if (a[c] > d) {
          g = c + h;break;
        }
      }return { xData: a.slice(f, g), yData: b.slice(f, g), start: f, end: g };
    }, generatePoints: function generatePoints() {
      var a = this.options.data,
          b = this.data,
          c,
          d = this.processedXData,
          e = this.processedYData,
          f = this.pointClass,
          g = d.length,
          h = this.cropStart || 0,
          i,
          j = this.hasGroupedData,
          k,
          l = [],
          m;if (!b && !j) b = [], b.length = a.length, b = this.data = b;for (m = 0; m < g; m++) {
        i = h + m, j ? (l[m] = new f().init(this, [d[m]].concat(sa(e[m]))), l[m].dataGroup = this.groupMap[m]) : (b[i] ? k = b[i] : a[i] !== x && (b[i] = k = new f().init(this, a[i], d[m])), l[m] = k), l[m].index = i;
      }if (b && (g !== (c = b.length) || j)) for (m = 0; m < c; m++) {
        if (m === h && !j && (m += g), b[m]) b[m].destroyElements(), b[m].plotX = x;
      }this.data = b;this.points = l;
    }, getExtremes: function getExtremes(a) {
      var b = this.yAxis,
          c = this.processedXData,
          d,
          e = [],
          f = 0;d = this.xAxis.getExtremes();var g = d.min,
          h = d.max,
          i,
          j,
          k,
          l,
          a = a || this.stackedYData || this.processedYData || [];d = a.length;for (l = 0; l < d; l++) {
        if (j = c[l], k = a[l], i = k !== null && k !== x && (!b.isLog || k.length || k > 0), j = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[l + 1] || j) >= g && (c[l - 1] || j) <= h, i && j) if (i = k.length) for (; i--;) {
          k[i] !== null && (e[f++] = k[i]);
        } else e[f++] = k;
      }this.dataMin = Na(e);this.dataMax = Fa(e);
    }, translate: function translate() {
      this.processedXData || this.processData();this.generatePoints();for (var a = this.options, b = a.stacking, c = this.xAxis, d = c.categories, e = this.yAxis, f = this.points, g = f.length, h = !!this.modifyValue, i = a.pointPlacement, j = i === "between" || z(i), k = a.threshold, l = a.startFromThreshold ? k : 0, m, n, p, r, s = Number.MAX_VALUE, a = 0; a < g; a++) {
        var o = f[a],
            u = o.x,
            w = o.y;n = o.low;var F = b && e.stacks[(this.negStacks && w < (l ? 0 : k) ? "-" : "") + this.stackKey],
            L;if (e.isLog && w !== null && w <= 0) o.y = w = null, ja(10);o.plotX = m = V(E(y(-1E5, c.translate(u, 0, 0, 0, 1, i, this.type === "flags")), 1E5));if (b && this.visible && !o.isNull && F && F[u]) r = this.getStackIndicator(r, u, this.index), L = F[u], w = L.points[r.key], n = w[0], w = w[1], n === l && r.key === F[u].base && (n = q(k, e.min)), e.isLog && n <= 0 && (n = null), o.total = o.stackTotal = L.total, o.percentage = L.total && o.y / L.total * 100, o.stackY = w, L.setOffset(this.pointXOffset || 0, this.barW || 0);o.yBottom = t(n) ? e.translate(n, 0, 1, 0, 1) : null;h && (w = this.modifyValue(w, o));o.plotY = n = typeof w === "number" && w !== Infinity ? E(y(-1E5, e.translate(w, 0, 1, 0, 1)), 1E5) : x;o.isInside = n !== x && n >= 0 && n <= e.len && m >= 0 && m <= c.len;o.clientX = j ? V(c.translate(u, 0, 0, 0, 1)) : m;o.negative = o.y < (k || 0);o.category = d && d[o.x] !== x ? d[o.x] : o.x;o.isNull || (p !== void 0 && (s = E(s, T(m - p))), p = m);
      }this.closestPointRangePx = s;
    }, getValidPoints: function getValidPoints(a, b) {
      var c = this.chart;
      return Ha(a || this.points || [], function (a) {
        return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull;
      });
    }, setClip: function setClip(a) {
      var b = this.chart,
          c = this.options,
          d = b.renderer,
          e = b.inverted,
          f = this.clipBox,
          g = f || b.clipBox,
          h = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(","),
          i = b[h],
          j = b[h + "m"];if (!i) {
        if (a) g.width = 0, b[h + "m"] = j = d.clipRect(-99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight);b[h] = i = d.clipRect(g);i.count = { length: 0 };
      }a && !i.count[this.index] && (i.count[this.index] = !0, i.count.length += 1);if (c.clip !== !1) this.group.clip(a || f ? i : b.clipRect), this.markerGroup.clip(j), this.sharedClipKey = h;a || (i.count[this.index] && (delete i.count[this.index], i.count.length -= 1), i.count.length === 0 && h && b[h] && (f || (b[h] = b[h].destroy()), b[h + "m"] && (b[h + "m"] = b[h + "m"].destroy())));
    }, animate: function animate(a) {
      var b = this.chart,
          c = this.options.animation,
          d;if (c && !ha(c)) c = X[this.type].animation;a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({ width: b.plotSizeX }, c), b[d + "m"] && b[d + "m"].animate({ width: b.plotSizeX + 99 }, c), this.animate = null);
    }, afterAnimate: function afterAnimate() {
      this.setClip();K(this, "afterAnimate");
    }, drawPoints: function drawPoints() {
      var a,
          b = this.points,
          c = this.chart,
          d,
          e,
          f,
          g,
          h,
          i,
          j,
          k,
          l = this.options.marker,
          m = this.pointAttr[""],
          n,
          p,
          r,
          s = this.markerGroup,
          o = q(l.enabled, this.xAxis.isRadial, this.closestPointRangePx > 2 * l.radius);if (l.enabled !== !1 || this._hasPointMarkers) for (f = b.length; f--;) {
        if (g = b[f], d = Y(g.plotX), e = g.plotY, k = g.graphic, n = g.marker || {}, p = !!g.marker, a = o && n.enabled === x || n.enabled, r = g.isInside, a && z(e) && g.y !== null) {
          if (a = g.pointAttr[g.selected ? "select" : ""] || m, h = a.r, i = q(n.symbol, this.symbol), j = i.indexOf("url") === 0, k) k[r ? "show" : "hide"](!0).attr(a).animate(v({ x: d - h, y: e - h }, k.symbolName ? { width: 2 * h, height: 2 * h } : {}));else {
            if (r && (h > 0 || j)) g.graphic = c.renderer.symbol(i, d - h, e - h, 2 * h, 2 * h, p ? n : l).attr(a).add(s);
          }
        } else if (k) g.graphic = k.destroy();
      }
    }, convertAttribs: function convertAttribs(a, b, c, d) {
      var e = this.pointAttrToOptions,
          f,
          g,
          h = {},
          a = a || {},
          b = b || {},
          c = c || {},
          d = d || {};for (f in e) {
        g = e[f], h[f] = q(a[g], b[f], c[f], d[f]);
      }return h;
    },
    getAttribs: function getAttribs() {
      var a = this,
          b = a.options,
          c = X[a.type].marker ? b.marker : b,
          d = c.states,
          e = d.hover,
          f,
          g = a.color,
          h = a.options.negativeColor,
          i = { stroke: g, fill: g },
          j = a.points || [],
          k,
          l = [],
          m,
          n = a.pointAttrToOptions;f = a.hasPointSpecificOptions;var p = c.lineColor,
          r = c.fillColor;k = b.turboThreshold;var s = a.zones,
          Z = a.zoneAxis || "y",
          u,
          w;b.marker ? (e.radius = +e.radius || +c.radius + +e.radiusPlus, e.lineWidth = e.lineWidth || c.lineWidth + e.lineWidthPlus) : (e.color = e.color || xa(e.color || g).brighten(e.brightness).get(), e.negativeColor = e.negativeColor || xa(e.negativeColor || h).brighten(e.brightness).get());l[""] = a.convertAttribs(c, i);o(["hover", "select"], function (b) {
        l[b] = a.convertAttribs(d[b], l[""]);
      });a.pointAttr = l;g = j.length;if (!k || g < k || f) for (; g--;) {
        k = j[g];if ((c = k.options && k.options.marker || k.options) && c.enabled === !1) c.radius = 0;i = null;if (s.length) {
          f = 0;for (i = s[f]; k[Z] >= i.value;) {
            i = s[++f];
          }k.color = k.fillColor = i = q(i.color, a.color);
        }f = b.colorByPoint || k.color;if (k.options) for (w in n) {
          t(c[n[w]]) && (f = !0);
        }if (f) {
          c = c || {};m = [];d = c.states || {};f = d.hover = d.hover || {};if (!b.marker || k.negative && !f.fillColor && !e.fillColor) f[a.pointAttrToOptions.fill] = f.color || !k.options.color && e[k.negative && h ? "negativeColor" : "color"] || xa(k.color).brighten(f.brightness || e.brightness).get();u = { color: k.color };if (!r) u.fillColor = k.color;if (!p) u.lineColor = k.color;c.hasOwnProperty("color") && !c.color && delete c.color;if (i && !e.fillColor) f.fillColor = i;m[""] = a.convertAttribs(v(u, c), l[""]);m.hover = a.convertAttribs(d.hover, l.hover, m[""]);m.select = a.convertAttribs(d.select, l.select, m[""]);
        } else m = l;k.pointAttr = m;
      }
    }, destroy: function destroy() {
      var a = this,
          b = a.chart,
          c = /AppleWebKit\/533/.test(Pa),
          d,
          e = a.data || [],
          f,
          g,
          h;K(a, "destroy");U(a);o(a.axisTypes || [], function (b) {
        if (h = a[b]) Ba(h.series, a), h.isDirty = h.forceRedraw = !0;
      });a.legendItem && a.chart.legend.destroyItem(a);for (d = e.length; d--;) {
        (f = e[d]) && f.destroy && f.destroy();
      }a.points = null;clearTimeout(a.animationTimeout);for (g in a) {
        a[g] instanceof ba && !a[g].survive && (d = c && g === "group" ? "hide" : "destroy", a[g][d]());
      }if (b.hoverSeries === a) b.hoverSeries = null;Ba(b.series, a);for (g in a) {
        delete a[g];
      }
    }, getGraphPath: function getGraphPath(a, b, c) {
      var d = this,
          e = d.options,
          f = e.step,
          g,
          h = [],
          i = [],
          j,
          a = a || d.points;(g = a.reversed) && a.reverse();(f = { right: 1, center: 2 }[f] || f && 3) && g && (f = 4 - f);e.connectNulls && !b && !c && (a = this.getValidPoints(a));o(a, function (g, l) {
        var m = g.plotX,
            n = g.plotY,
            p = a[l - 1];if ((g.leftCliff || p && p.rightCliff) && !c) j = !0;g.isNull && !t(b) && l > 0 ? j = !e.connectNulls : g.isNull && !b ? j = !0 : (l === 0 || j ? p = [W, g.plotX, g.plotY] : d.getPointSpline ? p = d.getPointSpline(a, g, l) : f ? (p = f === 1 ? [R, p.plotX, n] : f === 2 ? [R, (p.plotX + m) / 2, p.plotY, R, (p.plotX + m) / 2, n] : [R, m, p.plotY], p.push(R, m, n)) : p = [R, m, n], i.push(g.x), f && i.push(g.x), h.push.apply(h, p), j = !1);
      });h.xMap = i;return d.graphPath = h;
    }, drawGraph: function drawGraph() {
      var a = this,
          b = this.options,
          c = [["graph", b.lineColor || this.color, b.dashStyle]],
          d = b.lineWidth,
          e = b.linecap !== "square",
          f = (this.gappedPath || this.getGraphPath).call(this);o(this.zones, function (d, e) {
        c.push(["zoneGraph" + e, d.color || a.color, d.dashStyle || b.dashStyle]);
      });o(c, function (c, h) {
        var i = c[0],
            j = a[i];if (j) j.endX = f.xMap, j.animate({ d: f });else if (d && f.length) j = { stroke: c[1], "stroke-width": d, fill: "none", zIndex: 1 }, c[2] ? j.dashstyle = c[2] : e && (j["stroke-linecap"] = j["stroke-linejoin"] = "round"), j = a[i] = a.chart.renderer.path(f).attr(j).add(a.group).shadow(h < 2 && b.shadow);if (j) j.startX = f.xMap, j.isArea = f.isArea;
      });
    }, applyZones: function applyZones() {
      var a = this,
          b = this.chart,
          c = b.renderer,
          d = this.zones,
          e,
          f,
          g = this.clips || [],
          h,
          i = this.graph,
          j = this.area,
          k = y(b.chartWidth, b.chartHeight),
          l = this[(this.zoneAxis || "y") + "Axis"],
          m,
          n = l.reversed,
          p = b.inverted,
          r = l.horiz,
          s,
          Z,
          u,
          w = !1;if (d.length && (i || j) && l.min !== x) i && i.hide(), j && j.hide(), m = l.getExtremes(), o(d, function (d, o) {
        e = n ? r ? b.plotWidth : 0 : r ? 0 : l.toPixels(m.min);e = E(y(q(f, e), 0), k);f = E(y(A(l.toPixels(q(d.value, m.max), !0)), 0), k);w && (e = f = l.toPixels(m.max));s = Math.abs(e - f);Z = E(e, f);u = y(e, f);if (l.isXAxis) {
          if (h = { x: p ? u : Z, y: 0, width: s, height: k }, !r) h.x = b.plotHeight - h.x;
        } else if (h = { x: 0, y: p ? u : Z, width: k, height: s }, r) h.y = b.plotWidth - h.y;b.inverted && c.isVML && (h = l.isXAxis ? { x: 0, y: n ? Z : u, height: h.width, width: b.chartWidth } : { x: h.y - b.plotLeft - b.spacingBox.x, y: 0, width: h.height, height: b.chartHeight });g[o] ? g[o].animate(h) : (g[o] = c.clipRect(h), i && a["zoneGraph" + o].clip(g[o]), j && a["zoneArea" + o].clip(g[o]));w = d.value > m.max;
      }), this.clips = g;
    }, invertGroups: function invertGroups() {
      function a() {
        var a = { width: b.yAxis.len, height: b.xAxis.len };o(["group", "markerGroup"], function (c) {
          b[c] && b[c].attr(a).invert();
        });
      }var b = this,
          c = b.chart;if (b.xAxis) G(c, "resize", a), G(b, "destroy", function () {
        U(c, "resize", a);
      }), a(), b.invertGroups = a;
    }, plotGroup: function plotGroup(a, b, c, d, e) {
      var f = this[a],
          g = !f;g && (this[a] = f = this.chart.renderer.g(b).attr({ zIndex: d || 0.1 }).add(e), f.addClass("highcharts-series-" + this.index));f.attr({ visibility: c })[g ? "attr" : "animate"](this.getPlotBox());return f;
    }, getPlotBox: function getPlotBox() {
      var a = this.chart,
          b = this.xAxis,
          c = this.yAxis;if (a.inverted) b = c, c = this.xAxis;return { translateX: b ? b.left : a.plotLeft, translateY: c ? c.top : a.plotTop, scaleX: 1, scaleY: 1 };
    }, render: function render() {
      var a = this,
          b = a.chart,
          c,
          d = a.options,
          e = !!a.animate && b.renderer.isSVG && ib(d.animation).duration,
          f = a.visible ? "inherit" : "hidden",
          g = d.zIndex,
          h = a.hasRendered,
          i = b.seriesGroup;c = a.plotGroup("group", "series", f, g, i);a.markerGroup = a.plotGroup("markerGroup", "markers", f, g, i);e && a.animate(!0);a.getAttribs();c.inverted = a.isCartesian ? b.inverted : !1;a.drawGraph && (a.drawGraph(), a.applyZones());o(a.points, function (a) {
        a.redraw && a.redraw();
      });a.drawDataLabels && a.drawDataLabels();a.visible && a.drawPoints();a.drawTracker && a.options.enableMouseTracking !== !1 && a.drawTracker();b.inverted && a.invertGroups();d.clip !== !1 && !a.sharedClipKey && !h && c.clip(b.clipRect);e && a.animate();if (!h) a.animationTimeout = bb(function () {
        a.afterAnimate();
      }, e);a.isDirty = a.isDirtyData = !1;a.hasRendered = !0;
    }, redraw: function redraw() {
      var a = this.chart,
          b = this.isDirty || this.isDirtyData,
          c = this.group,
          d = this.xAxis,
          e = this.yAxis;c && (a.inverted && c.attr({ width: a.plotWidth, height: a.plotHeight }), c.animate({ translateX: q(d && d.left, a.plotLeft), translateY: q(e && e.top, a.plotTop) }));this.translate();this.render();b && delete this.kdTree;
    }, kdDimensions: 1, kdAxisArray: ["clientX", "plotY"], searchPoint: function searchPoint(a, b) {
      var c = this.xAxis,
          d = this.yAxis,
          e = this.chart.inverted;return this.searchKDTree({ clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos, plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos }, b);
    }, buildKDTree: function buildKDTree() {
      function a(c, e, f) {
        var g, h;if (h = c && c.length) return g = b.kdAxisArray[e % f], c.sort(function (a, b) {
          return a[g] - b[g];
        }), h = Math.floor(h / 2), { point: c[h], left: a(c.slice(0, h), e + 1, f), right: a(c.slice(h + 1), e + 1, f) };
      }var b = this,
          c = b.kdDimensions;delete b.kdTree;bb(function () {
        b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);
      }, b.options.kdNow ? 0 : 1);
    }, searchKDTree: function searchKDTree(a, b) {
      function c(a, b, j, k) {
        var l = b.point,
            m = d.kdAxisArray[j % k],
            n,
            p,
            r = l;p = t(a[e]) && t(l[e]) ? Math.pow(a[e] - l[e], 2) : null;n = t(a[f]) && t(l[f]) ? Math.pow(a[f] - l[f], 2) : null;n = (p || 0) + (n || 0);l.dist = t(n) ? Math.sqrt(n) : Number.MAX_VALUE;l.distX = t(p) ? Math.sqrt(p) : Number.MAX_VALUE;m = a[m] - l[m];n = m < 0 ? "left" : "right";p = m < 0 ? "right" : "left";b[n] && (n = c(a, b[n], j + 1, k), r = n[g] < r[g] ? n : l);b[p] && Math.sqrt(m * m) < r[g] && (a = c(a, b[p], j + 1, k), r = a[g] < r[g] ? a : r);return r;
      }var d = this,
          e = this.kdAxisArray[0],
          f = this.kdAxisArray[1],
          g = b ? "distX" : "dist";this.kdTree || this.buildKDTree();if (this.kdTree) return c(a, this.kdTree, this.kdDimensions, this.kdDimensions);
    } };Vb.prototype = { destroy: function destroy() {
      Oa(this, this.axis);
    }, render: function render(a) {
      var b = this.options,
          c = b.format,
          c = c ? Ma(c, this) : b.formatter.call(this);this.label ? this.label.attr({ text: c, visibility: "hidden" }) : this.label = this.axis.chart.renderer.text(c, null, null, b.useHTML).css(b.style).attr({ align: this.textAlign, rotation: b.rotation, visibility: "hidden" }).add(a);
    },
    setOffset: function setOffset(a, b) {
      var c = this.axis,
          d = c.chart,
          e = d.inverted,
          f = c.reversed,
          f = this.isNegative && !f || !this.isNegative && f,
          g = c.translate(c.usePercentage ? 100 : this.total, 0, 0, 0, 1),
          c = c.translate(0),
          c = T(g - c),
          h = d.xAxis[0].translate(this.x) + a,
          i = d.plotHeight,
          f = { x: e ? f ? g : g - c : h, y: e ? i - h - b : f ? i - g - c : i - g, width: e ? c : b, height: e ? b : c };if (e = this.label) e.align(this.alignOptions, null, f), f = e.alignAttr, e[this.options.crop === !1 || d.isInsidePlot(f.x, f.y) ? "show" : "hide"](!0);
    } };Da.prototype.getStacks = function () {
    var a = this;o(a.yAxis, function (a) {
      if (a.stacks && a.hasVisibleSeries) a.oldStacks = a.stacks;
    });o(a.series, function (b) {
      if (b.options.stacking && (b.visible === !0 || a.options.chart.ignoreHiddenSeries === !1)) b.stackKey = b.type + q(b.options.stack, "");
    });
  };J.prototype.buildStacks = function () {
    var a = this.series,
        b,
        c = q(this.options.reversedStacks, !0),
        d = a.length,
        e;if (!this.isXAxis) {
      this.usePercentage = !1;for (e = d; e--;) {
        a[c ? e : d - e - 1].setStackedPoints();
      }for (e = d; e--;) {
        b = a[c ? e : d - e - 1], b.setStackCliffs && b.setStackCliffs();
      }if (this.usePercentage) for (e = 0; e < d; e++) {
        a[e].setPercentStacks();
      }
    }
  };
  J.prototype.renderStackTotals = function () {
    var a = this.chart,
        b = a.renderer,
        c = this.stacks,
        d,
        e,
        f = this.stackTotalGroup;if (!f) this.stackTotalGroup = f = b.g("stack-labels").attr({ visibility: "visible", zIndex: 6 }).add();f.translate(a.plotLeft, a.plotTop);for (d in c) {
      for (e in a = c[d], a) {
        a[e].render(f);
      }
    }
  };J.prototype.resetStacks = function () {
    var a = this.stacks,
        b,
        c;if (!this.isXAxis) for (b in a) {
      for (c in a[b]) {
        a[b][c].touched < this.stacksTouched ? (a[b][c].destroy(), delete a[b][c]) : (a[b][c].total = null, a[b][c].cum = 0);
      }
    }
  };J.prototype.cleanStacks = function () {
    var a, b, c;if (!this.isXAxis) {
      if (this.oldStacks) a = this.stacks = this.oldStacks;for (b in a) {
        for (c in a[b]) {
          a[b][c].cum = a[b][c].total;
        }
      }
    }
  };P.prototype.setStackedPoints = function () {
    if (this.options.stacking && !(this.visible !== !0 && this.chart.options.chart.ignoreHiddenSeries !== !1)) {
      var a = this.processedXData,
          b = this.processedYData,
          c = [],
          d = b.length,
          e = this.options,
          f = e.threshold,
          g = e.startFromThreshold ? f : 0,
          h = e.stack,
          e = e.stacking,
          i = this.stackKey,
          j = "-" + i,
          k = this.negStacks,
          l = this.yAxis,
          m = l.stacks,
          n = l.oldStacks,
          p,
          r,
          s,
          o,
          u,
          w,
          F;l.stacksTouched += 1;for (u = 0; u < d; u++) {
        w = a[u];F = b[u];p = this.getStackIndicator(p, w, this.index);o = p.key;s = (r = k && F < (g ? 0 : f)) ? j : i;m[s] || (m[s] = {});if (!m[s][w]) n[s] && n[s][w] ? (m[s][w] = n[s][w], m[s][w].total = null) : m[s][w] = new Vb(l, l.options.stackLabels, r, w, h);s = m[s][w];if (F !== null) {
          s.points[o] = s.points[this.index] = [q(s.cum, g)];if (!t(s.cum)) s.base = o;s.touched = l.stacksTouched;p.index > 0 && this.singleStacks === !1 && (s.points[o][0] = s.points[this.index + "," + w + ",0"][0]);
        }e === "percent" ? (r = r ? i : j, k && m[r] && m[r][w] ? (r = m[r][w], s.total = r.total = y(r.total, s.total) + T(F) || 0) : s.total = V(s.total + (T(F) || 0))) : s.total = V(s.total + (F || 0));s.cum = q(s.cum, g) + (F || 0);if (F !== null) s.points[o].push(s.cum), c[u] = s.cum;
      }if (e === "percent") l.usePercentage = !0;this.stackedYData = c;l.oldStacks = {};
    }
  };P.prototype.setPercentStacks = function () {
    var a = this,
        b = a.stackKey,
        c = a.yAxis.stacks,
        d = a.processedXData,
        e;o([b, "-" + b], function (b) {
      var f;for (var g = d.length, h, i; g--;) {
        if (h = d[g], e = a.getStackIndicator(e, h, a.index), f = (i = c[b] && c[b][h]) && i.points[e.key], h = f) i = i.total ? 100 / i.total : 0, h[0] = V(h[0] * i), h[1] = V(h[1] * i), a.stackedYData[g] = h[1];
      }
    });
  };P.prototype.getStackIndicator = function (a, b, c) {
    !t(a) || a.x !== b ? a = { x: b, index: 0 } : a.index++;a.key = [c, b, a.index].join(",");return a;
  };v(Da.prototype, { addSeries: function addSeries(a, b, c) {
      var d,
          e = this;a && (b = q(b, !0), K(e, "addSeries", { options: a }, function () {
        d = e.initSeries(a);e.isDirtyLegend = !0;e.linkSeries();b && e.redraw(c);
      }));return d;
    }, addAxis: function addAxis(a, b, c, d) {
      var e = b ? "xAxis" : "yAxis",
          f = this.options,
          a = D(a, { index: this[e].length, isX: b });new J(this, a);f[e] = sa(f[e] || {});f[e].push(a);q(c, !0) && this.redraw(d);
    }, showLoading: function showLoading(a) {
      var b = this,
          c = b.options,
          d = b.loadingDiv,
          e = c.loading,
          f = function f() {
        d && O(d, { left: b.plotLeft + "px", top: b.plotTop + "px", width: b.plotWidth + "px", height: b.plotHeight + "px" });
      };if (!d) b.loadingDiv = d = ia(Xa, { className: "highcharts-loading" }, v(e.style, { zIndex: 10, display: "none" }), b.container), b.loadingSpan = ia("span", null, e.labelStyle, d), G(b, "redraw", f);b.loadingSpan.innerHTML = a || c.lang.loading;if (!b.loadingShown) O(d, { opacity: 0, display: "" }), fb(d, { opacity: e.style.opacity }, { duration: e.showDuration || 0 }), b.loadingShown = !0;f();
    }, hideLoading: function hideLoading() {
      var a = this.options,
          b = this.loadingDiv;b && fb(b, { opacity: 0 }, { duration: a.loading.hideDuration || 100, complete: function complete() {
          O(b, { display: "none" });
        } });this.loadingShown = !1;
    } });v(Ja.prototype, { update: function update(a, b, c, d) {
      function e() {
        f.applyOptions(a);if (f.y === null && h) f.graphic = h.destroy();if (ha(a, !0)) f.redraw = function () {
          if (h && h.element && a && a.marker && a.marker.symbol) f.graphic = h.destroy();if (a && a.dataLabels && f.dataLabel) f.dataLabel = f.dataLabel.destroy();f.redraw = null;
        };i = f.index;g.updateParallelArrays(f, i);if (l && f.name) l[f.x] = f.name;k.data[i] = ha(k.data[i], !0) ? f.options : a;g.isDirty = g.isDirtyData = !0;if (!g.fixedBox && g.hasCartesianSeries) j.isDirtyBox = !0;if (k.legendType === "point") j.isDirtyLegend = !0;b && j.redraw(c);
      }var f = this,
          g = f.series,
          h = f.graphic,
          i,
          j = g.chart,
          k = g.options,
          l = g.xAxis && g.xAxis.names,
          b = q(b, !0);d === !1 ? e() : f.firePointEvent("update", { options: a }, e);
    }, remove: function remove(a, b) {
      this.series.removePoint(qa(this, this.series.data), a, b);
    } });v(P.prototype, { addPoint: function addPoint(a, b, c, d) {
      var e = this.options,
          f = this.data,
          g = this.chart,
          h = this.xAxis && this.xAxis.names,
          i = e.data,
          j,
          k = this.xData,
          l,
          m;cb(d, g);b = q(b, !0);d = { series: this };this.pointClass.prototype.applyOptions.apply(d, [a]);m = d.x;l = k.length;if (this.requireSorting && m < k[l - 1]) for (j = !0; l && k[l - 1] > m;) {
        l--;
      }this.updateParallelArrays(d, "splice", l, 0, 0);this.updateParallelArrays(d, l);if (h && d.name) h[m] = d.name;i.splice(l, 0, a);j && (this.data.splice(l, 0, null), this.processData());e.legendType === "point" && this.generatePoints();c && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(d, "shift"), i.shift()));this.isDirtyData = this.isDirty = !0;b && (this.getAttribs(), g.redraw());
    }, removePoint: function removePoint(a, b, c) {
      var d = this,
          e = d.data,
          f = e[a],
          g = d.points,
          h = d.chart,
          i = function i() {
        g && g.length === e.length && g.splice(a, 1);e.splice(a, 1);d.options.data.splice(a, 1);d.updateParallelArrays(f || { series: d }, "splice", a, 1);f && f.destroy();d.isDirty = !0;d.isDirtyData = !0;b && h.redraw();
      };cb(c, h);b = q(b, !0);f ? f.firePointEvent("remove", null, i) : i();
    }, remove: function remove(a, b) {
      var c = this,
          d = c.chart;K(c, "remove", null, function () {
        c.destroy();d.isDirtyLegend = d.isDirtyBox = !0;d.linkSeries();q(a, !0) && d.redraw(b);
      });
    }, update: function update(a, b) {
      var c = this,
          d = this.chart,
          e = this.userOptions,
          f = this.type,
          g = I[f].prototype,
          h = ["group", "markerGroup", "dataLabelsGroup"],
          i;if (a.type && a.type !== f || a.zIndex !== void 0) h.length = 0;o(h, function (a) {
        h[a] = c[a];delete c[a];
      });a = D(e, { animation: !1, index: this.index, pointStart: this.xData[0] }, { data: this.options.data }, a);this.remove(!1);
      for (i in g) {
        this[i] = x;
      }v(this, I[a.type || f].prototype);o(h, function (a) {
        c[a] = h[a];
      });this.init(d, a);d.linkSeries();q(b, !0) && d.redraw(!1);
    } });v(J.prototype, { update: function update(a, b) {
      var c = this.chart,
          a = c.options[this.coll][this.options.index] = D(this.userOptions, a);this.destroy(!0);this.init(c, v(a, { events: x }));c.isDirtyBox = !0;q(b, !0) && c.redraw();
    }, remove: function remove(a) {
      for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--;) {
        d[e] && d[e].remove(!1);
      }Ba(b.axes, this);Ba(b[c], this);b.options[c].splice(this.options.index, 1);o(b[c], function (a, b) {
        a.options.index = b;
      });this.destroy();b.isDirtyBox = !0;q(a, !0) && b.redraw();
    }, setTitle: function setTitle(a, b) {
      this.update({ title: a }, b);
    }, setCategories: function setCategories(a, b) {
      this.update({ categories: a }, b);
    } });var Ka = oa(P);I.line = Ka;X.area = D(ga, { softThreshold: !1, threshold: 0 });var Aa = oa(P, { type: "area", singleStacks: !1, getStackPoints: function getStackPoints() {
      var a = [],
          b = [],
          c = this.xAxis,
          d = this.yAxis,
          e = d.stacks[this.stackKey],
          f = {},
          g = this.points,
          h = this.index,
          i = d.series,
          j = i.length,
          k,
          l = q(d.options.reversedStacks, !0) ? 1 : -1,
          m,
          n;if (this.options.stacking) {
        for (m = 0; m < g.length; m++) {
          f[g[m].x] = g[m];
        }for (n in e) {
          e[n].total !== null && b.push(n);
        }b.sort(function (a, b) {
          return a - b;
        });k = wa(i, function () {
          return this.visible;
        });o(b, function (g, i) {
          var n = 0,
              q,
              u;if (f[g] && !f[g].isNull) a.push(f[g]), o([-1, 1], function (a) {
            var c = a === 1 ? "rightNull" : "leftNull",
                d = 0,
                n = e[b[i + a]];if (n) for (m = h; m >= 0 && m < j;) {
              q = n.points[m], q || (m === h ? f[g][c] = !0 : k[m] && (u = e[g].points[m]) && (d -= u[1] - u[0])), m += l;
            }f[g][a === 1 ? "rightCliff" : "leftCliff"] = d;
          });else {
            for (m = h; m >= 0 && m < j;) {
              if (q = e[g].points[m]) {
                n = q[1];break;
              }m += l;
            }n = d.toPixels(n, !0);a.push({ isNull: !0, plotX: c.toPixels(g, !0), plotY: n, yBottom: n });
          }
        });
      }return a;
    }, getGraphPath: function getGraphPath(a) {
      var b = P.prototype.getGraphPath,
          c = this.options,
          d = c.stacking,
          e = this.yAxis,
          f,
          g,
          h = [],
          i = [],
          j = this.index,
          k,
          l = e.stacks[this.stackKey],
          m = c.threshold,
          n = e.getThreshold(c.threshold),
          p,
          c = c.connectNulls || d === "percent",
          r = function r(b, c, f) {
        var g = a[b],
            b = d && l[g.x].points[j],
            p = g[f + "Null"] || 0,
            f = g[f + "Cliff"] || 0,
            r,
            o,
            g = !0;f || p ? (r = (p ? b[0] : b[1]) + f, o = b[0] + f, g = !!p) : !d && a[c] && a[c].isNull && (r = o = m);r !== void 0 && (i.push({ plotX: k, plotY: r === null ? n : e.getThreshold(r), isNull: g }), h.push({ plotX: k, plotY: o === null ? n : e.getThreshold(o) }));
      },
          a = a || this.points;d && (a = this.getStackPoints());for (f = 0; f < a.length; f++) {
        if (g = a[f].isNull, k = q(a[f].rectPlotX, a[f].plotX), p = q(a[f].yBottom, n), !g || c) {
          c || r(f, f - 1, "left");if (!g || d || !c) i.push(a[f]), h.push({ x: f, plotX: k, plotY: p });c || r(f, f + 1, "right");
        }
      }f = b.call(this, i, !0, !0);h.reversed = !0;g = b.call(this, h, !0, !0);g.length && (g[0] = R);g = f.concat(g);b = b.call(this, i, !1, c);g.xMap = f.xMap;
      this.areaPath = g;return b;
    }, drawGraph: function drawGraph() {
      this.areaPath = [];P.prototype.drawGraph.apply(this);var a = this,
          b = this.areaPath,
          c = this.options,
          d = [["area", this.color, c.fillColor]];o(this.zones, function (b, f) {
        d.push(["zoneArea" + f, b.color || a.color, b.fillColor || c.fillColor]);
      });o(d, function (d) {
        var f = d[0],
            g = a[f];g ? (g.endX = b.xMap, g.animate({ d: b })) : (g = { fill: d[2] || d[1], zIndex: 0 }, d[2] || (g["fill-opacity"] = q(c.fillOpacity, 0.75)), g = a[f] = a.chart.renderer.path(b).attr(g).add(a.group), g.isArea = !0);g.startX = b.xMap;g.shiftUnit = c.step ? 2 : 1;
      });
    }, drawLegendSymbol: da.drawRectangle });I.area = Aa;X.spline = D(ga);Ka = oa(P, { type: "spline", getPointSpline: function getPointSpline(a, b, c) {
      var d = b.plotX,
          e = b.plotY,
          f = a[c - 1],
          c = a[c + 1],
          g,
          h,
          i,
          j;if (f && !f.isNull && c && !c.isNull) {
        a = f.plotY;i = c.plotX;var c = c.plotY,
            k = 0;g = (1.5 * d + f.plotX) / 2.5;h = (1.5 * e + a) / 2.5;i = (1.5 * d + i) / 2.5;j = (1.5 * e + c) / 2.5;i !== g && (k = (j - h) * (i - d) / (i - g) + e - j);h += k;j += k;h > a && h > e ? (h = y(a, e), j = 2 * e - h) : h < a && h < e && (h = E(a, e), j = 2 * e - h);j > c && j > e ? (j = y(c, e), h = 2 * e - j) : j < c && j < e && (j = E(c, e), h = 2 * e - j);b.rightContX = i;b.rightContY = j;
      }b = ["C", q(f.rightContX, f.plotX), q(f.rightContY, f.plotY), q(g, d), q(h, e), d, e];f.rightContX = f.rightContY = null;return b;
    } });I.spline = Ka;X.areaspline = D(X.area);Aa = Aa.prototype;Ka = oa(Ka, { type: "areaspline", getStackPoints: Aa.getStackPoints, getGraphPath: Aa.getGraphPath, setStackCliffs: Aa.setStackCliffs, drawGraph: Aa.drawGraph, drawLegendSymbol: da.drawRectangle });I.areaspline = Ka;X.column = D(ga, { borderColor: "#FFFFFF", borderRadius: 0, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null,
    states: { hover: { brightness: 0.1, shadow: !1, halo: !1 }, select: { color: "#C0C0C0", borderColor: "#000000", shadow: !1 } }, dataLabels: { align: null, verticalAlign: null, y: null }, softThreshold: !1, startFromThreshold: !0, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0 });Ka = oa(P, { type: "column", pointAttrToOptions: { stroke: "borderColor", fill: "color", r: "borderRadius" }, cropShoulder: 0, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function init() {
      P.prototype.init.apply(this, arguments);var a = this,
          b = a.chart;
      b.hasRendered && o(b.series, function (b) {
        if (b.type === a.type) b.isDirty = !0;
      });
    }, getColumnMetrics: function getColumnMetrics() {
      var a = this,
          b = a.options,
          c = a.xAxis,
          d = a.yAxis,
          e = c.reversed,
          f,
          g = {},
          h = 0;b.grouping === !1 ? h = 1 : o(a.chart.series, function (b) {
        var c = b.options,
            e = b.yAxis,
            i;if (b.type === a.type && b.visible && d.len === e.len && d.pos === e.pos) c.stacking ? (f = b.stackKey, g[f] === x && (g[f] = h++), i = g[f]) : c.grouping !== !1 && (i = h++), b.columnIndex = i;
      });var i = E(T(c.transA) * (c.ordinalSlope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
          j = i * b.groupPadding,
          k = (i - 2 * j) / h,
          b = E(b.maxPointWidth || c.len, q(b.pointWidth, k * (1 - 2 * b.pointPadding)));a.columnMetrics = { width: b, offset: (k - b) / 2 + (j + ((a.columnIndex || 0) + (e ? 1 : 0)) * k - i / 2) * (e ? -1 : 1) };return a.columnMetrics;
    }, crispCol: function crispCol(a, b, c, d) {
      var e = this.chart,
          f = this.borderWidth,
          g = -(f % 2 ? 0.5 : 0),
          f = f % 2 ? 0.5 : 1;e.inverted && e.renderer.isVML && (f += 1);c = Math.round(a + c) + g;a = Math.round(a) + g;c -= a;d = Math.round(b + d) + f;g = T(b) <= 0.5 && d > 0.5;b = Math.round(b) + f;d -= b;g && d && (b -= 1, d += 1);return { x: a, y: b, width: c, height: d };
    }, translate: function translate() {
      var a = this,
          b = a.chart,
          c = a.options,
          d = a.borderWidth = q(c.borderWidth, a.closestPointRange * a.xAxis.transA < 2 ? 0 : 1),
          e = a.yAxis,
          f = a.translatedThreshold = e.getThreshold(c.threshold),
          g = q(c.minPointLength, 5),
          h = a.getColumnMetrics(),
          i = h.width,
          j = a.barW = y(i, 1 + 2 * d),
          k = a.pointXOffset = h.offset;b.inverted && (f -= 0.5);c.pointPadding && (j = Ga(j));P.prototype.translate.apply(a);o(a.points, function (c) {
        var d = E(q(c.yBottom, f), 9E4),
            h = 999 + T(d),
            h = E(y(-h, c.plotY), e.len + h),
            p = c.plotX + k,
            r = j,
            o = E(h, d),
            t,
            u = y(h, d) - o;T(u) < g && g && (u = g, t = !e.reversed && !c.negative || e.reversed && c.negative, o = T(o - f) > g ? d - g : f - (t ? g : 0));c.barX = p;c.pointWidth = i;c.tooltipPos = b.inverted ? [e.len + e.pos - b.plotLeft - h, a.xAxis.len - p - r / 2, u] : [p + r / 2, h + e.pos - b.plotTop, u];c.shapeType = "rect";c.shapeArgs = a.crispCol(p, o, r, u);
      });
    }, getSymbol: va, drawLegendSymbol: da.drawRectangle, drawGraph: va, drawPoints: function drawPoints() {
      var a = this,
          b = this.chart,
          c = a.options,
          d = b.renderer,
          e = c.animationLimit || 250,
          f,
          g;o(a.points, function (h) {
        var i = h.graphic,
            j;if (z(h.plotY) && h.y !== null) f = h.shapeArgs, j = t(a.borderWidth) ? { "stroke-width": a.borderWidth } : {}, g = h.pointAttr[h.selected ? "select" : ""] || a.pointAttr[""], i ? (Qa(i), i.attr(j).attr(g)[b.pointCount < e ? "animate" : "attr"](D(f))) : h.graphic = d[h.shapeType](f).attr(j).attr(g).add(h.group || a.group).shadow(c.shadow, null, c.stacking && !c.borderRadius);else if (i) h.graphic = i.destroy();
      });
    }, animate: function animate(a) {
      var b = this,
          c = this.yAxis,
          d = b.options,
          e = this.chart.inverted,
          f = {};if (ma) a ? (f.scaleY = 0.001, a = E(c.pos + c.len, y(c.pos, c.toPixels(d.threshold))), e ? f.translateX = a - c.len : f.translateY = a, b.group.attr(f)) : (f[e ? "translateX" : "translateY"] = c.pos, b.group.animate(f, v(ib(b.options.animation), { step: function step(a, c) {
          b.group.attr({ scaleY: y(0.001, c.pos) });
        } })), b.animate = null);
    }, remove: function remove() {
      var a = this,
          b = a.chart;b.hasRendered && o(b.series, function (b) {
        if (b.type === a.type) b.isDirty = !0;
      });P.prototype.remove.apply(a, arguments);
    } });I.column = Ka;X.bar = D(X.column);Aa = oa(Ka, { type: "bar", inverted: !0 });I.bar = Aa;X.scatter = D(ga, { lineWidth: 0, marker: { enabled: !0 }, tooltip: { headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px;\"> {series.name}</span><br/>",
      pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } });Aa = oa(P, { type: "scatter", sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: !1, kdDimensions: 2, drawGraph: function drawGraph() {
      this.options.lineWidth && P.prototype.drawGraph.call(this);
    } });I.scatter = Aa;X.pie = D(ga, { borderColor: "#FFFFFF", borderWidth: 1, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { distance: 30, enabled: !0, formatter: function formatter() {
        return this.y === null ? void 0 : this.point.name;
      },
      x: 0 }, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, states: { hover: { brightness: 0.1, shadow: !1 } }, stickyTracking: !1, tooltip: { followPointer: !0 } });ga = { type: "pie", isCartesian: !1, pointClass: oa(Ja, { init: function init() {
        Ja.prototype.init.apply(this, arguments);var a = this,
            b;a.name = q(a.name, "Slice");b = function b(_b3) {
          a.slice(_b3.type === "select");
        };G(a, "select", b);G(a, "unselect", b);return a;
      }, setVisible: function setVisible(a, b) {
        var c = this,
            d = c.series,
            e = d.chart,
            f = d.options.ignoreHiddenPoint,
            b = q(b, f);if (a !== c.visible) {
          c.visible = c.options.visible = a = a === x ? !c.visible : a;d.options.data[qa(c, d.data)] = c.options;o(["graphic", "dataLabel", "connector", "shadowGroup"], function (b) {
            if (c[b]) c[b][a ? "show" : "hide"](!0);
          });c.legendItem && e.legend.colorizeItem(c, a);!a && c.state === "hover" && c.setState("");if (f) d.isDirty = !0;b && e.redraw();
        }
      }, slice: function slice(a, b, c) {
        var d = this.series;cb(c, d.chart);q(b, !0);this.sliced = this.options.sliced = a = t(a) ? a : !this.sliced;d.options.data[qa(this, d.data)] = this.options;a = a ? this.slicedTranslation : { translateX: 0, translateY: 0 };this.graphic.animate(a);this.shadowGroup && this.shadowGroup.animate(a);
      }, haloPath: function haloPath(a) {
        var b = this.shapeArgs,
            c = this.series.chart;return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.plotLeft + b.x, c.plotTop + b.y, b.r + a, b.r + a, { innerR: this.shapeArgs.r, start: b.start, end: b.end });
      } }), requireSorting: !1, directTouch: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth",
      fill: "color" }, animate: function animate(a) {
      var b = this,
          c = b.points,
          d = b.startAngleRad;if (!a) o(c, function (a) {
        var c = a.graphic,
            g = a.shapeArgs;c && (c.attr({ r: a.startR || b.center[3] / 2, start: d, end: d }), c.animate({ r: g.r, start: g.start, end: g.end }, b.options.animation));
      }), b.animate = null;
    }, updateTotals: function updateTotals() {
      var a,
          b = 0,
          c = this.points,
          d = c.length,
          e,
          f = this.options.ignoreHiddenPoint;for (a = 0; a < d; a++) {
        e = c[a];if (e.y < 0) e.y = null;b += f && !e.visible ? 0 : e.y;
      }this.total = b;for (a = 0; a < d; a++) {
        e = c[a], e.percentage = b > 0 && (e.visible || !f) ? e.y / b * 100 : 0, e.total = b;
      }
    }, generatePoints: function generatePoints() {
      P.prototype.generatePoints.call(this);this.updateTotals();
    }, translate: function translate(a) {
      this.generatePoints();var b = 0,
          c = this.options,
          d = c.slicedOffset,
          e = d + c.borderWidth,
          f,
          g,
          h,
          i = c.startAngle || 0,
          j = this.startAngleRad = Ca / 180 * (i - 90),
          i = (this.endAngleRad = Ca / 180 * (q(c.endAngle, i + 360) - 90)) - j,
          k = this.points,
          l = c.dataLabels.distance,
          c = c.ignoreHiddenPoint,
          m,
          n = k.length,
          p;if (!a) this.center = a = this.getCenter();this.getX = function (b, c) {
        h = aa.asin(E((b - a[1]) / (a[2] / 2 + l), 1));return a[0] + (c ? -1 : 1) * fa(h) * (a[2] / 2 + l);
      };for (m = 0; m < n; m++) {
        p = k[m];f = j + b * i;if (!c || p.visible) b += p.percentage / 100;g = j + b * i;p.shapeType = "arc";p.shapeArgs = { x: a[0], y: a[1], r: a[2] / 2, innerR: a[3] / 2, start: A(f * 1E3) / 1E3, end: A(g * 1E3) / 1E3 };h = (g + f) / 2;h > 1.5 * Ca ? h -= 2 * Ca : h < -Ca / 2 && (h += 2 * Ca);p.slicedTranslation = { translateX: A(fa(h) * d), translateY: A(na(h) * d) };f = fa(h) * a[2] / 2;g = na(h) * a[2] / 2;p.tooltipPos = [a[0] + f * 0.7, a[1] + g * 0.7];p.half = h < -Ca / 2 || h > Ca / 2 ? 1 : 0;p.angle = h;e = E(e, l / 2);p.labelPos = [a[0] + f + fa(h) * l, a[1] + g + na(h) * l, a[0] + f + fa(h) * e, a[1] + g + na(h) * e, a[0] + f, a[1] + g, l < 0 ? "center" : p.half ? "right" : "left", h];
      }
    }, drawGraph: null, drawPoints: function drawPoints() {
      var a = this,
          b = a.chart.renderer,
          c,
          d,
          e = a.options.shadow,
          f,
          g,
          h,
          i;if (e && !a.shadowGroup) a.shadowGroup = b.g("shadow").add(a.group);o(a.points, function (j) {
        if (j.y !== null) {
          d = j.graphic;h = j.shapeArgs;f = j.shadowGroup;g = j.pointAttr[j.selected ? "select" : ""];if (!g.stroke) g.stroke = g.fill;if (e && !f) f = j.shadowGroup = b.g("shadow").add(a.shadowGroup);c = j.sliced ? j.slicedTranslation : { translateX: 0, translateY: 0 };f && f.attr(c);if (d) d.setRadialReference(a.center).attr(g).animate(v(h, c));else {
            i = { "stroke-linejoin": "round" };if (!j.visible) i.visibility = "hidden";j.graphic = d = b[j.shapeType](h).setRadialReference(a.center).attr(g).attr(i).attr(c).add(a.group).shadow(e, f);
          }
        }
      });
    }, searchPoint: va, sortByAngle: function sortByAngle(a, b) {
      a.sort(function (a, d) {
        return a.angle !== void 0 && (d.angle - a.angle) * b;
      });
    }, drawLegendSymbol: da.drawRectangle, getCenter: ec.getCenter, getSymbol: va };ga = oa(P, ga);I.pie = ga;P.prototype.drawDataLabels = function () {
    var a = this,
        b = a.options,
        c = b.cursor,
        d = b.dataLabels,
        e = a.points,
        f,
        g,
        h = a.hasRendered || 0,
        i,
        j,
        k = q(d.defer, !0),
        l = a.chart.renderer;if (d.enabled || a._hasPointLabels) a.dlProcessOptions && a.dlProcessOptions(d), j = a.plotGroup("dataLabelsGroup", "data-labels", k && !h ? "hidden" : "visible", d.zIndex || 6), k && (j.attr({ opacity: +h }), h || G(a, "afterAnimate", function () {
      a.visible && j.show(!0);j[b.animation ? "animate" : "attr"]({ opacity: 1 }, { duration: 200 });
    })), g = d, o(e, function (e) {
      var h,
          k = e.dataLabel,
          r,
          o,
          y = e.connector,
          u = !0,
          w,
          F = {};f = e.dlOptions || e.options && e.options.dataLabels;h = q(f && f.enabled, g.enabled) && e.y !== null;if (k && !h) e.dataLabel = k.destroy();else if (h) {
        d = D(g, f);w = d.style;h = d.rotation;r = e.getLabelConfig();i = d.format ? Ma(d.format, r) : d.formatter.call(r, d);w.color = q(d.color, w.color, a.color, "black");if (k) {
          if (t(i)) k.attr({ text: i }), u = !1;else {
            if (e.dataLabel = k = k.destroy(), y) e.connector = y.destroy();
          }
        } else if (t(i)) {
          k = { fill: d.backgroundColor, stroke: d.borderColor, "stroke-width": d.borderWidth, r: d.borderRadius || 0, rotation: h, padding: d.padding, zIndex: 1 };if (w.color === "contrast") F.color = d.inside || d.distance < 0 || b.stacking ? l.getContrast(e.color || a.color) : "#000000";if (c) F.cursor = c;for (o in k) {
            k[o] === x && delete k[o];
          }k = e.dataLabel = l[h ? "text" : "label"](i, 0, -9999, d.shape, null, null, d.useHTML).attr(k).css(v(w, F)).add(j).shadow(d.shadow);
        }k && a.alignDataLabel(e, k, d, null, u);
      }
    });
  };P.prototype.alignDataLabel = function (a, b, c, d, e) {
    var f = this.chart,
        g = f.inverted,
        h = q(a.plotX, -9999),
        i = q(a.plotY, -9999),
        j = b.getBBox(),
        k = f.renderer.fontMetrics(c.style.fontSize).b,
        l = c.rotation,
        m = c.align,
        n = this.visible && (a.series.forceDL || f.isInsidePlot(h, A(i), g) || d && f.isInsidePlot(h, g ? d.x + 1 : d.y + d.height - 1, g)),
        p = q(c.overflow, "justify") === "justify";if (n) d = v({ x: g ? f.plotWidth - i : h, y: A(g ? f.plotHeight - h : i), width: 0, height: 0 }, d), v(c, { width: j.width, height: j.height }), l ? (p = !1, g = f.renderer.rotCorr(k, l), g = { x: d.x + c.x + d.width / 2 + g.x, y: d.y + c.y + { top: 0, middle: 0.5, bottom: 1 }[c.verticalAlign] * d.height }, b[e ? "attr" : "animate"](g).attr({ align: m }), h = (l + 720) % 360, h = h > 180 && h < 360, m === "left" ? g.y -= h ? j.height : 0 : m === "center" ? (g.x -= j.width / 2, g.y -= j.height / 2) : m === "right" && (g.x -= j.width, g.y -= h ? 0 : j.height)) : (b.align(c, null, d), g = b.alignAttr), p ? this.justifyDataLabel(b, c, g, j, d, e) : q(c.crop, !0) && (n = f.isInsidePlot(g.x, g.y) && f.isInsidePlot(g.x + j.width, g.y + j.height)), c.shape && !l && b.attr({ anchorX: a.plotX, anchorY: a.plotY });if (!n) Qa(b), b.attr({ y: -9999 }), b.placed = !1;
  };P.prototype.justifyDataLabel = function (a, b, c, d, e, f) {
    var g = this.chart,
        h = b.align,
        i = b.verticalAlign,
        j,
        k,
        l = a.box ? 0 : a.padding || 0;j = c.x + l;if (j < 0) h === "right" ? b.align = "left" : b.x = -j, k = !0;j = c.x + d.width - l;if (j > g.plotWidth) h === "left" ? b.align = "right" : b.x = g.plotWidth - j, k = !0;
    j = c.y + l;if (j < 0) i === "bottom" ? b.verticalAlign = "top" : b.y = -j, k = !0;j = c.y + d.height - l;if (j > g.plotHeight) i === "top" ? b.verticalAlign = "bottom" : b.y = g.plotHeight - j, k = !0;if (k) a.placed = !f, a.align(b, null, e);
  };if (I.pie) I.pie.prototype.drawDataLabels = function () {
    var a = this,
        b = a.data,
        c,
        d = a.chart,
        e = a.options.dataLabels,
        f = q(e.connectorPadding, 10),
        g = q(e.connectorWidth, 1),
        h = d.plotWidth,
        i = d.plotHeight,
        j,
        k,
        l = q(e.softConnector, !0),
        m = e.distance,
        n = a.center,
        p = n[2] / 2,
        r = n[1],
        s = m > 0,
        t,
        u,
        w,
        F = [[], []],
        x,
        v,
        B,
        D,
        z,
        C = [0, 0, 0, 0],
        G = function G(a, b) {
      return b.y - a.y;
    };if (a.visible && (e.enabled || a._hasPointLabels)) {
      P.prototype.drawDataLabels.apply(a);o(b, function (a) {
        if (a.dataLabel && a.visible) F[a.half].push(a), a.dataLabel._pos = null;
      });for (D = 2; D--;) {
        var J = [],
            M = [],
            H = F[D],
            K = H.length,
            I;if (K) {
          a.sortByAngle(H, D - 0.5);for (z = b = 0; !b && H[z];) {
            b = H[z] && H[z].dataLabel && (H[z].dataLabel.getBBox().height || 21), z++;
          }if (m > 0) {
            u = E(r + p + m, d.plotHeight);for (z = y(0, r - p - m); z <= u; z += b) {
              J.push(z);
            }u = J.length;if (K > u) {
              c = [].concat(H);c.sort(G);for (z = K; z--;) {
                c[z].rank = z;
              }for (z = K; z--;) {
                H[z].rank >= u && H.splice(z, 1);
              }K = H.length;
            }for (z = 0; z < K; z++) {
              c = H[z];w = c.labelPos;c = 9999;var O, N;for (N = 0; N < u; N++) {
                O = T(J[N] - w[1]), O < c && (c = O, I = N);
              }if (I < z && J[z] !== null) I = z;else for (u < K - z + I && J[z] !== null && (I = u - K + z); J[I] === null;) {
                I++;
              }M.push({ i: I, y: J[I] });J[I] = null;
            }M.sort(G);
          }for (z = 0; z < K; z++) {
            c = H[z];w = c.labelPos;t = c.dataLabel;B = c.visible === !1 ? "hidden" : "inherit";c = w[1];if (m > 0) {
              if (u = M.pop(), I = u.i, v = u.y, c > v && J[I + 1] !== null || c < v && J[I - 1] !== null) v = E(y(0, c), d.plotHeight);
            } else v = c;x = e.justify ? n[0] + (D ? -1 : 1) * (p + m) : a.getX(v === r - p - m || v === r + p + m ? c : v, D);t._attr = { visibility: B, align: w[6] };t._pos = { x: x + e.x + ({ left: f, right: -f }[w[6]] || 0), y: v + e.y - 10 };t.connX = x;t.connY = v;if (this.options.size === null) u = t.width, x - u < f ? C[3] = y(A(u - x + f), C[3]) : x + u > h - f && (C[1] = y(A(x + u - h + f), C[1])), v - b / 2 < 0 ? C[0] = y(A(-v + b / 2), C[0]) : v + b / 2 > i && (C[2] = y(A(v + b / 2 - i), C[2]));
          }
        }
      }if (Fa(C) === 0 || this.verifyDataLabelOverflow(C)) this.placeDataLabels(), s && g && o(this.points, function (b) {
        j = b.connector;w = b.labelPos;if ((t = b.dataLabel) && t._pos && b.visible) B = t._attr.visibility, x = t.connX, v = t.connY, k = l ? [W, x + (w[6] === "left" ? 5 : -5), v, "C", x, v, 2 * w[2] - w[4], 2 * w[3] - w[5], w[2], w[3], R, w[4], w[5]] : [W, x + (w[6] === "left" ? 5 : -5), v, R, w[2], w[3], R, w[4], w[5]], j ? (j.animate({ d: k }), j.attr("visibility", B)) : b.connector = j = a.chart.renderer.path(k).attr({ "stroke-width": g, stroke: e.connectorColor || b.color || "#606060", visibility: B }).add(a.dataLabelsGroup);else if (j) b.connector = j.destroy();
      });
    }
  }, I.pie.prototype.placeDataLabels = function () {
    o(this.points, function (a) {
      var b = a.dataLabel;if (b && a.visible) (a = b._pos) ? (b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), b.moved = !0) : b && b.attr({ y: -9999 });
    });
  }, I.pie.prototype.alignDataLabel = va, I.pie.prototype.verifyDataLabelOverflow = function (a) {
    var b = this.center,
        c = this.options,
        d = c.center,
        e = c.minSize || 80,
        f = e,
        g;d[0] !== null ? f = y(b[2] - y(a[1], a[3]), e) : (f = y(b[2] - a[1] - a[3], e), b[0] += (a[3] - a[1]) / 2);d[1] !== null ? f = y(E(f, b[2] - y(a[0], a[2])), e) : (f = y(E(f, b[2] - a[0] - a[2]), e), b[1] += (a[0] - a[2]) / 2);f < b[2] ? (b[2] = f, b[3] = Math.min(/%$/.test(c.innerSize || 0) ? f * parseFloat(c.innerSize || 0) / 100 : parseFloat(c.innerSize || 0), f), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : g = !0;return g;
  };if (I.column) I.column.prototype.alignDataLabel = function (a, b, c, d, e) {
    var f = this.chart.inverted,
        g = a.series,
        h = a.dlBox || a.shapeArgs,
        i = q(a.below, a.plotY > q(this.translatedThreshold, g.yAxis.len)),
        j = q(c.inside, !!this.options.stacking);if (h) {
      d = D(h);if (d.y < 0) d.height += d.y, d.y = 0;h = d.y + d.height - g.yAxis.len;h > 0 && (d.height -= h);f && (d = { x: g.yAxis.len - d.y - d.height, y: g.xAxis.len - d.x - d.width, width: d.height, height: d.width });if (!j) f ? (d.x += i ? 0 : d.width, d.width = 0) : (d.y += i ? d.height : 0, d.height = 0);
    }c.align = q(c.align, !f || j ? "center" : i ? "right" : "left");c.verticalAlign = q(c.verticalAlign, f || j ? "middle" : i ? "top" : "bottom");P.prototype.alignDataLabel.call(this, a, b, c, d, e);
  };(function (a) {
    var b = a.Chart,
        c = a.each,
        d = a.pick,
        e = a.addEvent;b.prototype.callbacks.push(function (a) {
      function b() {
        var e = [];c(a.series, function (a) {
          var b = a.options.dataLabels,
              f = a.dataLabelCollections || ["dataLabel"];(b.enabled || a._hasPointLabels) && !b.allowOverlap && a.visible && c(f, function (b) {
            c(a.points, function (a) {
              if (a[b]) a[b].labelrank = d(a.labelrank, a.shapeArgs && a.shapeArgs.height), e.push(a[b]);
            });
          });
        });a.hideOverlappingLabels(e);
      }b();e(a, "redraw", b);
    });b.prototype.hideOverlappingLabels = function (a) {
      var b = a.length,
          d,
          e,
          j,
          k,
          l,
          m,
          n,
          p,
          r;for (e = 0; e < b; e++) {
        if (d = a[e]) d.oldOpacity = d.opacity, d.newOpacity = 1;
      }a.sort(function (a, b) {
        return (b.labelrank || 0) - (a.labelrank || 0);
      });for (e = 0; e < b; e++) {
        j = a[e];for (d = e + 1; d < b; ++d) {
          if (k = a[d], j && k && j.placed && k.placed && j.newOpacity !== 0 && k.newOpacity !== 0 && (l = j.alignAttr, m = k.alignAttr, n = j.parentGroup, p = k.parentGroup, r = 2 * (j.box ? 0 : j.padding), l = !(m.x + p.translateX > l.x + n.translateX + (j.width - r) || m.x + p.translateX + (k.width - r) < l.x + n.translateX || m.y + p.translateY > l.y + n.translateY + (j.height - r) || m.y + p.translateY + (k.height - r) < l.y + n.translateY))) (j.labelrank < k.labelrank ? j : k).newOpacity = 0;
        }
      }c(a, function (a) {
        var b, c;if (a) {
          c = a.newOpacity;if (a.oldOpacity !== c && a.placed) c ? a.show(!0) : b = function b() {
            a.hide();
          }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b);a.isOld = !0;
        }
      });
    };
  })(B);var ob = B.TrackerMixin = { drawTrackerPoint: function drawTrackerPoint() {
      var a = this,
          b = a.chart,
          c = b.pointer,
          d = a.options.cursor,
          e = d && { cursor: d },
          f = function f(a) {
        for (var c = a.target, d; c && !d;) {
          d = c.point, c = c.parentNode;
        }if (d !== x && d !== b.hoverPoint) d.onMouseOver(a);
      };o(a.points, function (a) {
        if (a.graphic) a.graphic.element.point = a;if (a.dataLabel) a.dataLabel.element.point = a;
      });if (!a._hasTracking) o(a.trackerGroups, function (b) {
        if (a[b] && (a[b].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (a) {
          c.onTrackerMouseOut(a);
        }).css(e), $a)) a[b].on("touchstart", f);
      }), a._hasTracking = !0;
    },
    drawTrackerGraph: function drawTrackerGraph() {
      var a = this,
          b = a.options,
          c = b.trackByArea,
          d = [].concat(c ? a.areaPath : a.graphPath),
          e = d.length,
          f = a.chart,
          g = f.pointer,
          h = f.renderer,
          i = f.options.tooltip.snap,
          j = a.tracker,
          k = b.cursor,
          l = k && { cursor: k },
          m = function m() {
        if (f.hoverSeries !== a) a.onMouseOver();
      },
          n = "rgba(192,192,192," + (ma ? 1.0E-4 : 0.002) + ")";if (e && !c) for (k = e + 1; k--;) {
        d[k] === W && d.splice(k + 1, 0, d[k + 1] - i, d[k + 2], R), (k && d[k] === W || k === e) && d.splice(k, 0, R, d[k - 2] + i, d[k - 1]);
      }j ? j.attr({ d: d }) : (a.tracker = h.path(d).attr({ "stroke-linejoin": "round",
        visibility: a.visible ? "visible" : "hidden", stroke: n, fill: c ? n : "none", "stroke-width": b.lineWidth + (c ? 0 : 2 * i), zIndex: 2 }).add(a.group), o([a.tracker, a.markerGroup], function (a) {
        a.addClass("highcharts-tracker").on("mouseover", m).on("mouseout", function (a) {
          g.onTrackerMouseOut(a);
        }).css(l);if ($a) a.on("touchstart", m);
      }));
    } };if (I.column) Ka.prototype.drawTracker = ob.drawTrackerPoint;if (I.pie) I.pie.prototype.drawTracker = ob.drawTrackerPoint;if (I.scatter) Aa.prototype.drawTracker = ob.drawTrackerPoint;v(xb.prototype, { setItemEvents: function setItemEvents(a, b, c, d, e) {
      var f = this;(c ? b : a.legendGroup).on("mouseover", function () {
        a.setState("hover");b.css(f.options.itemHoverStyle);
      }).on("mouseout", function () {
        b.css(a.visible ? d : e);a.setState();
      }).on("click", function (b) {
        var c = function c() {
          a.setVisible && a.setVisible();
        },
            b = { browserEvent: b };a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : K(a, "legendItemClick", b, c);
      });
    }, createCheckboxForItem: function createCheckboxForItem(a) {
      a.checkbox = ia("input", { type: "checkbox", checked: a.selected, defaultChecked: a.selected }, this.options.itemCheckboxStyle, this.chart.container);G(a.checkbox, "click", function (b) {
        K(a.series || a, "checkboxClick", { checked: b.target.checked, item: a }, function () {
          a.select();
        });
      });
    } });Q.legend.itemStyle.cursor = "pointer";v(Da.prototype, { showResetZoom: function showResetZoom() {
      var a = this,
          b = Q.lang,
          c = a.options.chart.resetZoomButton,
          d = c.theme,
          e = d.states,
          f = c.relativeTo === "chart" ? null : "plotBox";this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function () {
        a.zoomOut();
      }, d, e && e.hover).attr({ align: c.position.align, title: b.resetZoomTitle }).add().align(c.position, !1, f);
    }, zoomOut: function zoomOut() {
      var a = this;K(a, "selection", { resetSelection: !0 }, function () {
        a.zoom();
      });
    }, zoom: function zoom(a) {
      var b,
          c = this.pointer,
          d = !1,
          e;!a || a.resetSelection ? o(this.axes, function (a) {
        b = a.zoom();
      }) : o(a.xAxis.concat(a.yAxis), function (a) {
        var e = a.axis,
            h = e.isXAxis;if (c[h ? "zoomX" : "zoomY"] || c[h ? "pinchX" : "pinchY"]) b = e.zoom(a.min, a.max), e.displayBtn && (d = !0);
      });e = this.resetZoomButton;if (d && !e) this.showResetZoom();else if (!d && ha(e)) this.resetZoomButton = e.destroy();b && this.redraw(q(this.options.chart.animation, a && a.animation, this.pointCount < 100));
    }, pan: function pan(a, b) {
      var c = this,
          d = c.hoverPoints,
          e;d && o(d, function (a) {
        a.setState();
      });o(b === "xy" ? [1, 0] : [1], function (b) {
        var b = c[b ? "xAxis" : "yAxis"][0],
            d = b.horiz,
            h = a[d ? "chartX" : "chartY"],
            d = d ? "mouseDownX" : "mouseDownY",
            i = c[d],
            j = (b.pointRange || 0) / 2,
            k = b.getExtremes(),
            l = b.toValue(i - h, !0) + j,
            j = b.toValue(i + b.len - h, !0) - j,
            i = i > h;if (b.series.length && (i || l > E(k.dataMin, k.min)) && (!i || j < y(k.dataMax, k.max))) b.setExtremes(l, j, !1, !1, { trigger: "pan" }), e = !0;c[d] = h;
      });e && c.redraw(!1);O(c.container, { cursor: "move" });
    } });v(Ja.prototype, { select: function select(a, b) {
      var c = this,
          d = c.series,
          e = d.chart,
          a = q(a, !c.selected);c.firePointEvent(a ? "select" : "unselect", { accumulate: b }, function () {
        c.selected = c.options.selected = a;d.options.data[qa(c, d.data)] = c.options;c.setState(a && "select");b || o(e.getSelectedPoints(), function (a) {
          if (a.selected && a !== c) a.selected = a.options.selected = !1, d.options.data[qa(a, d.data)] = a.options, a.setState(""), a.firePointEvent("unselect");
        });
      });
    }, onMouseOver: function onMouseOver(a, b) {
      var c = this.series,
          d = c.chart,
          e = d.tooltip,
          f = d.hoverPoint;if (d.hoverSeries !== c) c.onMouseOver();if (f && f !== this) f.onMouseOut();if (this.series && (this.firePointEvent("mouseOver"), e && (!e.shared || c.noSharedTooltip) && e.refresh(this, a), this.setState("hover"), !b)) d.hoverPoint = this;
    }, onMouseOut: function onMouseOut() {
      var a = this.series.chart,
          b = a.hoverPoints;this.firePointEvent("mouseOut");if (!b || qa(this, b) === -1) this.setState(), a.hoverPoint = null;
    }, importEvents: function importEvents() {
      if (!this.hasImportedEvents) {
        var a = D(this.series.options.point, this.options).events,
            b;this.events = a;for (b in a) {
          G(this, b, a[b]);
        }this.hasImportedEvents = !0;
      }
    }, setState: function setState(a, b) {
      var c = Y(this.plotX),
          d = this.plotY,
          e = this.series,
          f = e.options.states,
          g = X[e.type].marker && e.options.marker,
          h = g && !g.enabled,
          i = g && g.states[a],
          j = i && i.enabled === !1,
          k = e.stateMarkerGraphic,
          l = this.marker || {},
          m = e.chart,
          n = e.halo,
          p,
          a = a || "";p = this.pointAttr[a] || e.pointAttr[a];if (!(a === this.state && !b || this.selected && a !== "select" || f[a] && f[a].enabled === !1 || a && (j || h && i.enabled === !1) || a && l.states && l.states[a] && l.states[a].enabled === !1)) {
        if (this.graphic) g = g && this.graphic.symbolName && p.r, this.graphic.attr(D(p, g ? { x: c - g, y: d - g, width: 2 * g, height: 2 * g } : {})), k && k.hide();else {
          if (a && i) if (g = i.radius, l = l.symbol || e.symbol, k && k.currentSymbol !== l && (k = k.destroy()), k) k[b ? "animate" : "attr"]({ x: c - g, y: d - g });else if (l) e.stateMarkerGraphic = k = m.renderer.symbol(l, c - g, d - g, 2 * g, 2 * g).attr(p).add(e.markerGroup), k.currentSymbol = l;if (k) k[a && m.isInsidePlot(c, d, m.inverted) ? "show" : "hide"](), k.element.point = this;
        }if ((c = f[a] && f[a].halo) && c.size) {
          if (!n) e.halo = n = m.renderer.path().add(m.seriesGroup);
          n.attr(v({ fill: this.color || e.color, "fill-opacity": c.opacity, zIndex: -1 }, c.attributes))[b ? "animate" : "attr"]({ d: this.haloPath(c.size) });
        } else n && n.attr({ d: [] });this.state = a;
      }
    }, haloPath: function haloPath(a) {
      var b = this.series,
          c = b.chart,
          d = b.getPlotBox(),
          e = c.inverted,
          f = Math.floor(this.plotX);return c.renderer.symbols.circle(d.translateX + (e ? b.yAxis.len - this.plotY : f) - a, d.translateY + (e ? b.xAxis.len - f : this.plotY) - a, a * 2, a * 2);
    } });v(P.prototype, { onMouseOver: function onMouseOver() {
      var a = this.chart,
          b = a.hoverSeries;if (b && b !== this) b.onMouseOut();
      this.options.events.mouseOver && K(this, "mouseOver");this.setState("hover");a.hoverSeries = this;
    }, onMouseOut: function onMouseOut() {
      var a = this.options,
          b = this.chart,
          c = b.tooltip,
          d = b.hoverPoint;b.hoverSeries = null;if (d) d.onMouseOut();this && a.events.mouseOut && K(this, "mouseOut");c && !a.stickyTracking && (!c.shared || this.noSharedTooltip) && c.hide();this.setState();
    }, setState: function setState(a) {
      var b = this.options,
          c = this.graph,
          d = b.states,
          e = b.lineWidth,
          b = 0,
          a = a || "";if (this.state !== a && (this.state = a, !(d[a] && d[a].enabled === !1) && (a && (e = d[a].lineWidth || e + (d[a].lineWidthPlus || 0)), c && !c.dashstyle))) {
        a = { "stroke-width": e };for (c.attr(a); this["zoneGraph" + b];) {
          this["zoneGraph" + b].attr(a), b += 1;
        }
      }
    }, setVisible: function setVisible(a, b) {
      var c = this,
          d = c.chart,
          e = c.legendItem,
          f,
          g = d.options.chart.ignoreHiddenSeries,
          h = c.visible;f = (c.visible = a = c.userOptions.visible = a === x ? !h : a) ? "show" : "hide";o(["group", "dataLabelsGroup", "markerGroup", "tracker"], function (a) {
        if (c[a]) c[a][f]();
      });if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();e && d.legend.colorizeItem(c, a);c.isDirty = !0;c.options.stacking && o(d.series, function (a) {
        if (a.options.stacking && a.visible) a.isDirty = !0;
      });o(c.linkedSeries, function (b) {
        b.setVisible(a, !1);
      });if (g) d.isDirtyBox = !0;b !== !1 && d.redraw();K(c, f);
    }, show: function show() {
      this.setVisible(!0);
    }, hide: function hide() {
      this.setVisible(!1);
    }, select: function select(a) {
      this.selected = a = a === x ? !this.selected : a;if (this.checkbox) this.checkbox.checked = a;K(this, a ? "select" : "unselect");
    }, drawTracker: ob.drawTrackerGraph });S(P.prototype, "init", function (a) {
    var b;a.apply(this, Array.prototype.slice.call(arguments, 1));(b = this.xAxis) && b.options.ordinal && G(this, "updatedData", function () {
      delete b.ordinalIndex;
    });
  });S(J.prototype, "getTimeTicks", function (a, b, c, d, e, f, g, h) {
    var i = 0,
        j,
        k,
        l = {},
        m,
        n,
        p,
        o = [],
        q = -Number.MAX_VALUE,
        v = this.options.tickPixelInterval;if (!this.options.ordinal && !this.options.breaks || !f || f.length < 3 || c === x) return a.call(this, b, c, d, e);n = f.length;for (j = 0; j < n; j++) {
      p = j && f[j - 1] > d;f[j] < c && (i = j);if (j === n - 1 || f[j + 1] - f[j] > g * 5 || p) {
        if (f[j] > q) {
          for (k = a.call(this, b, f[i], f[j], e); k.length && k[0] <= q;) {
            k.shift();
          }k.length && (q = k[k.length - 1]);o = o.concat(k);
        }i = j + 1;
      }if (p) break;
    }a = k.info;if (h && a.unitRange <= N.hour) {
      j = o.length - 1;for (i = 1; i < j; i++) {
        pa("%d", o[i]) !== pa("%d", o[i - 1]) && (l[o[i]] = "day", m = !0);
      }m && (l[o[0]] = "day");a.higherRanks = l;
    }o.info = a;if (h && t(v)) {
      h = a = o.length;j = [];var u;for (m = []; h--;) {
        i = this.translate(o[h]), u && (m[h] = u - i), j[h] = u = i;
      }m.sort();m = m[Y(m.length / 2)];m < v * 0.6 && (m = null);h = o[a - 1] > d ? a - 1 : a;for (u = void 0; h--;) {
        i = j[h], d = u - i, u && d < v * 0.8 && (m === null || d < m * 0.8) ? (l[o[h]] && !l[o[h + 1]] ? (d = h + 1, u = i) : d = h, o.splice(d, 1)) : u = i;
      }
    }return o;
  });
  v(J.prototype, { beforeSetTickPositions: function beforeSetTickPositions() {
      var a,
          b = [],
          c = !1,
          d,
          e = this.getExtremes(),
          f = e.min,
          g = e.max,
          h,
          i = this.isXAxis && !!this.options.breaks;if ((e = this.options.ordinal) || i) {
        o(this.series, function (c, d) {
          if (c.visible !== !1 && (c.takeOrdinalPosition !== !1 || i)) if (b = b.concat(c.processedXData), a = b.length, b.sort(function (a, b) {
            return a - b;
          }), a) for (d = a - 1; d--;) {
            b[d] === b[d + 1] && b.splice(d, 1);
          }
        });a = b.length;if (a > 2) {
          d = b[1] - b[0];for (h = a - 1; h-- && !c;) {
            b[h + 1] - b[h] !== d && (c = !0);
          }if (!this.options.keepOrdinalPadding && (b[0] - f > d || g - b[b.length - 1] > d)) c = !0;
        }c ? (this.ordinalPositions = b, d = this.val2lin(y(f, b[0]), !0), h = y(this.val2lin(E(g, b[b.length - 1]), !0), 1), this.ordinalSlope = g = (g - f) / (h - d), this.ordinalOffset = f - d * g) : this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = x;
      }this.isOrdinal = e && c;this.groupIntervalFactor = null;
    }, val2lin: function val2lin(a, b) {
      var c = this.ordinalPositions,
          d;if (c) {
        var e = c.length,
            f;for (d = e; d--;) {
          if (c[d] === a) {
            f = d;break;
          }
        }for (d = e - 1; d--;) {
          if (a > c[d] || d === 0) {
            c = (a - c[d]) / (c[d + 1] - c[d]);f = d + c;break;
          }
        }d = b ? f : this.ordinalSlope * (f || 0) + this.ordinalOffset;
      } else d = a;return d;
    }, lin2val: function lin2val(a, b) {
      var c = this.ordinalPositions;if (c) {
        var d = this.ordinalSlope,
            e = this.ordinalOffset,
            f = c.length - 1,
            g,
            h;if (b) a < 0 ? a = c[0] : a > f ? a = c[f] : (f = Y(a), h = a - f);else for (; f--;) {
          if (g = d * f + e, a >= g) {
            d = d * (f + 1) + e;h = (a - g) / (d - g);break;
          }
        }c = h !== x && c[f] !== x ? c[f] + (h ? h * (c[f + 1] - c[f]) : 0) : a;
      } else c = a;return c;
    }, getExtendedPositions: function getExtendedPositions() {
      var a = this.chart,
          b = this.series[0].currentDataGrouping,
          c = this.ordinalIndex,
          d = b ? b.count + b.unitName : "raw",
          e = this.getExtremes(),
          f,
          g;if (!c) c = this.ordinalIndex = {};if (!c[d]) f = { series: [], getExtremes: function getExtremes() {
          return { min: e.dataMin, max: e.dataMax };
        }, options: { ordinal: !0 }, val2lin: J.prototype.val2lin }, o(this.series, function (c) {
        g = { xAxis: f, xData: c.xData, chart: a, destroyGroupedData: va };g.options = { dataGrouping: b ? { enabled: !0, forced: !0, approximation: "open", units: [[b.unitName, [b.count]]] } : { enabled: !1 } };c.processData.apply(g);f.series.push(g);
      }), this.beforeSetTickPositions.apply(f), c[d] = f.ordinalPositions;return c[d];
    }, getGroupIntervalFactor: function getGroupIntervalFactor(a, b, c) {
      var d,
          c = c.processedXData,
          e = c.length,
          f = [];d = this.groupIntervalFactor;if (!d) {
        for (d = 0; d < e - 1; d++) {
          f[d] = c[d + 1] - c[d];
        }f.sort(function (a, b) {
          return a - b;
        });f = f[Y(e / 2)];a = y(a, c[0]);b = E(b, c[e - 1]);this.groupIntervalFactor = d = e * f / (b - a);
      }return d;
    }, postProcessTickInterval: function postProcessTickInterval(a) {
      var b = this.ordinalSlope;return b ? this.options.breaks ? this.closestPointRange : a / (b / this.closestPointRange) : a;
    } });S(Da.prototype, "pan", function (a, b) {
    var c = this.xAxis[0],
        d = b.chartX,
        e = !1;if (c.options.ordinal && c.series.length) {
      var f = this.mouseDownX,
          g = c.getExtremes(),
          h = g.dataMax,
          i = g.min,
          j = g.max,
          k = this.hoverPoints,
          l = c.closestPointRange,
          f = (f - d) / (c.translationSlope * (c.ordinalSlope || l)),
          m = { ordinalPositions: c.getExtendedPositions() },
          l = c.lin2val,
          n = c.val2lin,
          p;if (m.ordinalPositions) {
        if (T(f) > 1) k && o(k, function (a) {
          a.setState();
        }), f < 0 ? (k = m, p = c.ordinalPositions ? c : m) : (k = c.ordinalPositions ? c : m, p = m), m = p.ordinalPositions, h > m[m.length - 1] && m.push(h), this.fixedRange = j - i, f = c.toFixedRange(null, null, l.apply(k, [n.apply(k, [i, !0]) + f, !0]), l.apply(p, [n.apply(p, [j, !0]) + f, !0])), f.min >= E(g.dataMin, i) && f.max <= y(h, j) && c.setExtremes(f.min, f.max, !0, !1, { trigger: "pan" }), this.mouseDownX = d, O(this.container, { cursor: "move" });
      } else e = !0;
    } else e = !0;e && a.apply(this, Array.prototype.slice.call(arguments, 1));
  });P.prototype.gappedPath = function () {
    var a = this.options.gapSize,
        b = this.points.slice(),
        c = b.length - 1;if (a && c > 0) for (; c--;) {
      b[c + 1].x - b[c].x > this.closestPointRange * a && b.splice(c + 1, 0, { isNull: !0 });
    }return this.getGraphPath(b);
  };(function (a) {
    a(B);
  })(function (a) {
    function b() {
      return Array.prototype.slice.call(arguments, 1);
    }function c(a) {
      a.apply(this);this.drawBreaks(this.xAxis, ["x"]);this.drawBreaks(this.yAxis, d(this.pointArrayMap, ["y"]));
    }var d = a.pick,
        e = a.wrap,
        f = a.each,
        g = a.extend,
        h = a.fireEvent,
        i = a.Axis,
        j = a.Series;g(i.prototype, { isInBreak: function isInBreak(a, b) {
        var c = a.repeat || Infinity,
            d = a.from,
            e = a.to - a.from,
            c = b >= d ? (b - d) % c : c - (d - b) % c;return a.inclusive ? c <= e : c < e && c !== 0;
      }, isInAnyBreak: function isInAnyBreak(a, b) {
        var c = this.options.breaks,
            e = c && c.length,
            f,
            g,
            h;if (e) {
          for (; e--;) {
            this.isInBreak(c[e], a) && (f = !0, g || (g = d(c[e].showPoints, this.isXAxis ? !1 : !0)));
          }h = f && b ? f && !g : f;
        }return h;
      } });e(i.prototype, "setTickPositions", function (a) {
      a.apply(this, Array.prototype.slice.call(arguments, 1));if (this.options.breaks) {
        var b = this.tickPositions,
            c = this.tickPositions.info,
            d = [],
            e;for (e = 0; e < b.length; e++) {
          this.isInAnyBreak(b[e]) || d.push(b[e]);
        }this.tickPositions = d;this.tickPositions.info = c;
      }
    });e(i.prototype, "init", function (a, b, c) {
      if (c.breaks && c.breaks.length) c.ordinal = !1;a.call(this, b, c);if (this.options.breaks) {
        var d = this;d.isBroken = !0;this.val2lin = function (a) {
          var b = a,
              c,
              e;for (e = 0; e < d.breakArray.length; e++) {
            if (c = d.breakArray[e], c.to <= a) b -= c.len;else if (c.from >= a) break;else if (d.isInBreak(c, a)) {
              b -= a - c.from;break;
            }
          }return b;
        };this.lin2val = function (a) {
          var b, c;for (c = 0; c < d.breakArray.length; c++) {
            if (b = d.breakArray[c], b.from >= a) break;else b.to < a ? a += b.len : d.isInBreak(b, a) && (a += b.len);
          }return a;
        };this.setExtremes = function (a, b, c, d, e) {
          for (; this.isInAnyBreak(a);) {
            a -= this.closestPointRange;
          }for (; this.isInAnyBreak(b);) {
            b -= this.closestPointRange;
          }i.prototype.setExtremes.call(this, a, b, c, d, e);
        };this.setAxisTranslation = function (a) {
          i.prototype.setAxisTranslation.call(this, a);var b = d.options.breaks,
              a = [],
              c = [],
              e = 0,
              f,
              g,
              j = d.userMin || d.min,
              k = d.userMax || d.max,
              l,
              m;for (m in b) {
            g = b[m], f = g.repeat || Infinity, d.isInBreak(g, j) && (j += g.to % f - j % f), d.isInBreak(g, k) && (k -= k % f - g.from % f);
          }for (m in b) {
            g = b[m];l = g.from;for (f = g.repeat || Infinity; l - f > j;) {
              l -= f;
            }for (; l < j;) {
              l += f;
            }for (; l < k; l += f) {
              a.push({ value: l, move: "in" }), a.push({ value: l + (g.to - g.from), move: "out", size: g.breakSize });
            }
          }a.sort(function (a, b) {
            return a.value === b.value ? (a.move === "in" ? 0 : 1) - (b.move === "in" ? 0 : 1) : a.value - b.value;
          });b = 0;l = j;for (m in a) {
            g = a[m];b += g.move === "in" ? 1 : -1;if (b === 1 && g.move === "in") l = g.value;b === 0 && (c.push({ from: l, to: g.value, len: g.value - l - (g.size || 0) }), e += g.value - l - (g.size || 0));
          }d.breakArray = c;h(d, "afterBreaks");d.transA *= (k - d.min) / (k - j - e);d.min = j;d.max = k;
        };
      }
    });e(j.prototype, "generatePoints", function (a) {
      a.apply(this, b(arguments));var c = this.xAxis,
          d = this.yAxis,
          e = this.points,
          f,
          g = e.length,
          h = this.options.connectNulls,
          i;if (c && d && (c.options.breaks || d.options.breaks)) for (; g--;) {
        if (f = e[g], i = f.y === null && h === !1, !i && (c.isInAnyBreak(f.x, !0) || d.isInAnyBreak(f.y, !0))) e.splice(g, 1), this.data[g] && this.data[g].destroyElements();
      }
    });a.Series.prototype.drawBreaks = function (a, b) {
      var c = this,
          e = c.points,
          g,
          i,
          j,
          o;f(b, function (b) {
        g = a.breakArray || [];i = a.isXAxis ? a.min : d(c.options.threshold, a.min);f(e, function (c) {
          o = d(c["stack" + b.toUpperCase()], c[b]);f(g, function (b) {
            j = !1;if (i < b.from && o > b.to || i > b.from && o < b.from) j = "pointBreak";else if (i < b.from && o > b.from && o < b.to || i > b.from && o > b.to && o < b.from) j = "pointInBreak";
            j && h(a, j, { point: c, brk: b });
          });
        });
      });
    };e(a.seriesTypes.column.prototype, "drawPoints", c);e(a.Series.prototype, "drawPoints", c);
  });var la = P.prototype,
      fc = la.processData,
      gc = la.generatePoints,
      hc = la.destroy,
      ic = { approximation: "average", groupPixelWidth: 2, dateTimeLabelFormats: { millisecond: ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"], second: ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"], minute: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], hour: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], day: ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], week: ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], month: ["%B %Y", "%B", "-%B %Y"], year: ["%Y", "%Y", "-%Y"] } },
      $b = { line: {}, spline: {}, area: {}, areaspline: {}, column: { approximation: "sum", groupPixelWidth: 10 }, arearange: { approximation: "range" }, areasplinerange: { approximation: "range" }, columnrange: { approximation: "range", groupPixelWidth: 10 }, candlestick: { approximation: "ohlc", groupPixelWidth: 10 }, ohlc: { approximation: "ohlc", groupPixelWidth: 5 } },
      ac = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]],
      Va = { sum: function sum(a) {
      var b = a.length,
          c;if (!b && a.hasNulls) c = null;else if (b) for (c = 0; b--;) {
        c += a[b];
      }return c;
    }, average: function average(a) {
      var b = a.length,
          a = Va.sum(a);z(a) && b && (a /= b);return a;
    }, open: function open(a) {
      return a.length ? a[0] : a.hasNulls ? null : x;
    }, high: function high(a) {
      return a.length ? Fa(a) : a.hasNulls ? null : x;
    }, low: function low(a) {
      return a.length ? Na(a) : a.hasNulls ? null : x;
    }, close: function close(a) {
      return a.length ? a[a.length - 1] : a.hasNulls ? null : x;
    }, ohlc: function ohlc(a, b, c, d) {
      a = Va.open(a);b = Va.high(b);c = Va.low(c);d = Va.close(d);if (z(a) || z(b) || z(c) || z(d)) return [a, b, c, d];
    }, range: function range(a, b) {
      a = Va.low(a);b = Va.high(b);if (z(a) || z(b)) return [a, b];
    } };la.groupData = function (a, b, c, d) {
    var e = this.data,
        f = this.options.data,
        g = [],
        h = [],
        i = [],
        j = a.length,
        k,
        l,
        m = !!b,
        n = [[], [], [], []],
        d = typeof d === "function" ? d : Va[d],
        p = this.pointArrayMap,
        o = p && p.length,
        q,
        t = 0,
        u = 0;for (q = 0; q <= j; q++) {
      if (a[q] >= c[0]) break;
    }for (; q <= j; q++) {
      for (; c[t + 1] !== void 0 && a[q] >= c[t + 1] || q === j;) {
        if (k = c[t], l = d.apply(0, n), l !== x && (g.push(k), h.push(l), i.push({ start: u, length: n[0].length })), u = q, n[0] = [], n[1] = [], n[2] = [], n[3] = [], t += 1, q === j) break;
      }if (q === j) break;if (p) {
        k = this.cropStart + q;k = e && e[k] || this.pointClass.prototype.applyOptions.apply({ series: this }, [f[k]]);var w;for (l = 0; l < o; l++) {
          if (w = k[p[l]], z(w)) n[l].push(w);else if (w === null) n[l].hasNulls = !0;
        }
      } else if (k = m ? b[q] : null, z(k)) n[0].push(k);else if (k === null) n[0].hasNulls = !0;
    }return [g, h, i];
  };la.processData = function () {
    var a = this.chart,
        b = this.options.dataGrouping,
        c = this.allowDG !== !1 && b && q(b.enabled, a.options._stock),
        d;this.forceCrop = c;this.groupPixelWidth = null;this.hasProcessed = !0;if (fc.apply(this, arguments) !== !1 && c) {
      this.destroyGroupedData();var e = this.processedXData,
          f = this.processedYData,
          g = a.plotSizeX,
          a = this.xAxis,
          h = a.options.ordinal,
          i = this.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth();if (i) {
        d = !0;this.points = null;var j = a.getExtremes(),
            c = j.min,
            j = j.max,
            h = h && a.getGroupIntervalFactor(c, j, this) || 1,
            g = i * (j - c) / g * h,
            i = a.getTimeTicks(a.normalizeTimeTickInterval(g, b.units || ac), Math.min(c, e[0]), Math.max(j, e[e.length - 1]), a.options.startOfWeek, e, this.closestPointRange),
            e = la.groupData.apply(this, [e, f, i, b.approximation]),
            f = e[0],
            h = e[1];if (b.smoothed) {
          b = f.length - 1;for (f[b] = Math.min(f[b], j); b-- && b > 0;) {
            f[b] += g / 2;
          }f[0] = Math.max(f[0], c);
        }this.currentDataGrouping = i.info;this.closestPointRange = i.info.totalRange;this.groupMap = e[2];if (t(f[0]) && f[0] < a.dataMin) {
          if (a.min === a.dataMin) a.min = f[0];a.dataMin = f[0];
        }this.processedXData = f;this.processedYData = h;
      } else this.currentDataGrouping = this.groupMap = null;this.hasGroupedData = d;
    }
  };la.destroyGroupedData = function () {
    var a = this.groupedData;o(a || [], function (b, c) {
      b && (a[c] = b.destroy ? b.destroy() : null);
    });this.groupedData = null;
  };la.generatePoints = function () {
    gc.apply(this);this.destroyGroupedData();this.groupedData = this.hasGroupedData ? this.points : null;
  };S(Nb.prototype, "tooltipFooterHeaderFormatter", function (a, b, c) {
    var d = b.series,
        e = d.tooltipOptions,
        f = d.options.dataGrouping,
        g = e.xDateFormat,
        h,
        i = d.xAxis;return i && i.options.type === "datetime" && f && z(b.key) ? (a = d.currentDataGrouping, f = f.dateTimeLabelFormats, a ? (i = f[a.unitName], a.count === 1 ? g = i[0] : (g = i[1], h = i[2])) : !g && f && (g = this.getXDateFormat(b, e, i)), g = pa(g, b.key), h && (g += pa(h, b.key + a.totalRange - 1)), Ma(e[(c ? "footer" : "header") + "Format"], { point: v(b.point, { key: g }), series: d })) : a.call(this, b, c);
  });la.destroy = function () {
    for (var a = this.groupedData || [], b = a.length; b--;) {
      a[b] && a[b].destroy();
    }hc.apply(this);
  };S(la, "setOptions", function (a, b) {
    var c = a.call(this, b),
        d = this.type,
        e = this.chart.options.plotOptions,
        f = X[d].dataGrouping;if ($b[d]) f || (f = D(ic, $b[d])), c.dataGrouping = D(f, e.series && e.series.dataGrouping, e[d].dataGrouping, b.dataGrouping);if (this.chart.options._stock) this.requireSorting = !0;return c;
  });S(J.prototype, "setScale", function (a) {
    a.call(this);o(this.series, function (a) {
      a.hasProcessed = !1;
    });
  });J.prototype.getGroupPixelWidth = function () {
    var a = this.series,
        b = a.length,
        c,
        d = 0,
        e = !1,
        f;for (c = b; c--;) {
      (f = a[c].options.dataGrouping) && (d = y(d, f.groupPixelWidth));
    }for (c = b; c--;) {
      if ((f = a[c].options.dataGrouping) && a[c].hasProcessed) if (b = (a[c].processedXData || a[c].data).length, a[c].groupPixelWidth || b > this.chart.plotSizeX / d || b && f.forced) e = !0;
    }return e ? d : 0;
  };J.prototype.setDataGrouping = function (a, b) {
    var c,
        b = q(b, !0);a || (a = { forced: !1, units: null });if (this instanceof J) for (c = this.series.length; c--;) {
      this.series[c].update({ dataGrouping: a }, !1);
    } else o(this.chart.options.series, function (b) {
      b.dataGrouping = a;
    }, !1);b && this.chart.redraw();
  };X.ohlc = D(X.column, { lineWidth: 1, tooltip: { pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>" },
    states: { hover: { lineWidth: 3 } }, threshold: null });ga = oa(I.column, { type: "ohlc", pointArrayMap: ["open", "high", "low", "close"], toYData: function toYData(a) {
      return [a.open, a.high, a.low, a.close];
    }, pointValKey: "high", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, upColorProp: "stroke", getAttribs: function getAttribs() {
      I.column.prototype.getAttribs.apply(this, arguments);var a = this.options,
          b = a.states,
          a = a.upColor || this.color,
          c = D(this.pointAttr),
          d = this.upColorProp;c[""][d] = a;c.hover[d] = b.hover.upColor || a;c.select[d] = b.select.upColor || a;o(this.points, function (a) {
        if (a.open < a.close && !a.options.color) a.pointAttr = c;
      });
    }, translate: function translate() {
      var a = this.yAxis;I.column.prototype.translate.apply(this);o(this.points, function (b) {
        if (b.open !== null) b.plotOpen = a.translate(b.open, 0, 1, 0, 1);if (b.close !== null) b.plotClose = a.translate(b.close, 0, 1, 0, 1);
      });
    }, drawPoints: function drawPoints() {
      var a = this,
          b = a.chart,
          c,
          d,
          e,
          f,
          g,
          h,
          i,
          j;o(a.points, function (k) {
        if (k.plotY !== x) i = k.graphic, c = k.pointAttr[k.selected ? "selected" : ""] || a.pointAttr[""], f = c["stroke-width"] % 2 / 2, j = A(k.plotX) - f, g = A(k.shapeArgs.width / 2), h = ["M", j, A(k.yBottom), "L", j, A(k.plotY)], k.open !== null && (d = A(k.plotOpen) + f, h.push("M", j, d, "L", j - g, d)), k.close !== null && (e = A(k.plotClose) + f, h.push("M", j, e, "L", j + g, e)), i ? i.attr(c).animate({ d: h }) : k.graphic = b.renderer.path(h).attr(c).add(a.group);
      });
    }, animate: null });I.ohlc = ga;X.candlestick = D(X.column, { lineColor: "black", lineWidth: 1, states: { hover: { lineWidth: 2 } }, tooltip: X.ohlc.tooltip, threshold: null, upColor: "white" });ga = oa(ga, { type: "candlestick", pointAttrToOptions: { fill: "color", stroke: "lineColor",
      "stroke-width": "lineWidth" }, upColorProp: "fill", getAttribs: function getAttribs() {
      I.ohlc.prototype.getAttribs.apply(this, arguments);var a = this.options,
          b = a.states,
          c = a.upLineColor || a.lineColor,
          d = b.hover.upLineColor || c,
          e = b.select.upLineColor || c;o(this.points, function (a) {
        if (a.open < a.close) {
          if (a.lineColor) a.pointAttr = D(a.pointAttr), c = a.lineColor;a.pointAttr[""].stroke = c;a.pointAttr.hover.stroke = d;a.pointAttr.select.stroke = e;
        }
      });
    }, drawPoints: function drawPoints() {
      var a = this,
          b = a.chart,
          c,
          d = a.pointAttr[""],
          e,
          f,
          g,
          h,
          i,
          j,
          k,
          l,
          m,
          n,
          p;o(a.points, function (o) {
        m = o.graphic;if (o.plotY !== x) c = o.pointAttr[o.selected ? "selected" : ""] || d, k = c["stroke-width"] % 2 / 2, l = A(o.plotX) - k, e = o.plotOpen, f = o.plotClose, g = aa.min(e, f), h = aa.max(e, f), p = A(o.shapeArgs.width / 2), i = A(g) !== A(o.plotY), j = h !== o.yBottom, g = A(g) + k, h = A(h) + k, n = [], n.push("M", l - p, h, "L", l - p, g, "L", l + p, g, "L", l + p, h, "Z", "M", l, g, "L", l, i ? A(o.plotY) : g, "M", l, h, "L", l, j ? A(o.yBottom) : h), m ? m.attr(c).animate({ d: n }) : o.graphic = b.renderer.path(n).attr(c).add(a.group).shadow(a.options.shadow);
      });
    } });I.candlestick = ga;var yb = za.prototype.symbols;X.flags = D(X.column, { fillColor: "white", lineWidth: 1, pointRange: 0, shape: "flag", stackDistance: 12, states: { hover: { lineColor: "black", fillColor: "#FCFFC5" } }, style: { fontSize: "11px", fontWeight: "bold", textAlign: "center" }, tooltip: { pointFormat: "{point.text}<br/>" }, threshold: null, y: -30 });I.flags = oa(I.column, { type: "flags", sorted: !1, noSharedTooltip: !0, allowDG: !1, takeOrdinalPosition: !1, trackerGroups: ["markerGroup"], forceCrop: !0, init: P.prototype.init, pointAttrToOptions: { fill: "fillColor", stroke: "color",
      "stroke-width": "lineWidth", r: "radius" }, translate: function translate() {
      I.column.prototype.translate.apply(this);var a = this.options,
          b = this.chart,
          c = this.points,
          d = c.length - 1,
          e,
          f,
          g = a.onSeries;e = g && b.get(g);var a = a.onKey || "y",
          g = e && e.options.step,
          h = e && e.points,
          i = h && h.length,
          j = this.xAxis,
          k = j.getExtremes(),
          l,
          m,
          n;if (e && e.visible && i) {
        e = e.currentDataGrouping;m = h[i - 1].x + (e ? e.totalRange : 0);c.sort(function (a, b) {
          return a.x - b.x;
        });for (a = "plot" + a[0].toUpperCase() + a.substr(1); i-- && c[d];) {
          if (e = c[d], l = h[i], l.x <= e.x && l[a] !== void 0) {
            if (e.x <= m) e.plotY = l[a], l.x < e.x && !g && (n = h[i + 1]) && n[a] !== x && (e.plotY += (e.x - l.x) / (n.x - l.x) * (n[a] - l[a]));d--;i++;if (d < 0) break;
          }
        }
      }o(c, function (a, d) {
        var e;if (a.plotY === x) a.x >= k.min && a.x <= k.max ? a.plotY = b.chartHeight - j.bottom - (j.opposite ? j.height : 0) + j.offset - b.plotTop : a.shapeArgs = {};if ((f = c[d - 1]) && f.plotX === a.plotX) {
          if (f.stackIndex === x) f.stackIndex = 0;e = f.stackIndex + 1;
        }a.stackIndex = e;
      });
    }, drawPoints: function drawPoints() {
      var a,
          b = this.pointAttr[""],
          c = this.points,
          d = this.chart,
          e = d.renderer,
          f,
          g,
          h = this.options,
          i = h.y,
          j,
          k,
          l,
          m,
          n,
          p,
          o = this.yAxis,
          s;for (k = c.length; k--;) {
        if (l = c[k], a = l.plotX > this.xAxis.len, f = l.plotX, f > 0 && (f -= q(l.lineWidth, h.lineWidth) % 2), m = l.stackIndex, j = l.options.shape || h.shape, g = l.plotY, g !== x && (g = l.plotY + i - (m !== x && m * h.stackDistance)), n = m ? x : l.plotX, p = m ? x : l.plotY, m = l.graphic, g !== x && f >= 0 && !a) a = l.pointAttr[l.selected ? "select" : ""] || b, s = q(l.options.title, h.title, "A"), m ? m.attr({ text: s }).attr({ x: f, y: g, r: a.r, anchorX: n, anchorY: p }) : l.graphic = e.label(s, f, g, j, n, p, h.useHTML).css(D(h.style, l.style)).attr(a).attr({ align: j === "flag" ? "left" : "center",
          width: h.width, height: h.height }).add(this.markerGroup).shadow(h.shadow), l.tooltipPos = d.inverted ? [o.len + o.pos - d.plotLeft - g, this.xAxis.len - f] : [f, g];else if (m) l.graphic = m.destroy();
      }
    }, drawTracker: function drawTracker() {
      var a = this.points;ob.drawTrackerPoint.apply(this);o(a, function (b) {
        var c = b.graphic;c && G(c.element, "mouseover", function () {
          if (b.stackIndex > 0 && !b.raised) b._y = c.y, c.attr({ y: b._y - 8 }), b.raised = !0;o(a, function (a) {
            if (a !== b && a.raised && a.graphic) a.graphic.attr({ y: a._y }), a.raised = !1;
          });
        });
      });
    }, animate: va, buildKDTree: va,
    setClip: va });yb.flag = function (a, b, c, d, e) {
    return ["M", e && e.anchorX || a, e && e.anchorY || b, "L", a, b + d, a, b, a + c, b, a + c, b + d, a, b + d, "Z"];
  };o(["circle", "square"], function (a) {
    yb[a + "pin"] = function (b, c, d, e, f) {
      var g = f && f.anchorX,
          f = f && f.anchorY;a === "circle" && e > d && (b -= A((e - d) / 2), d = e);b = yb[a](b, c, d, e);g && f && b.push("M", g, c > f ? c : c + e, "L", g, f);return b;
    };
  });Za === B.VMLRenderer && o(["flag", "circlepin", "squarepin"], function (a) {
    nb.prototype.symbols[a] = yb[a];
  });var Wb = { height: lb ? 20 : 14, barBackgroundColor: "#bfc8d1", barBorderRadius: 0, barBorderWidth: 1,
    barBorderColor: "#bfc8d1", buttonArrowColor: "#666", buttonBackgroundColor: "#ebe7e8", buttonBorderColor: "#bbb", buttonBorderRadius: 0, buttonBorderWidth: 1, margin: 10, minWidth: 6, rifleColor: "#666", zIndex: 3, step: 0.2, trackBackgroundColor: "#eeeeee", trackBorderColor: "#eeeeee", trackBorderWidth: 1, liveRedraw: ma && !lb };Q.scrollbar = D(!0, Wb, Q.scrollbar);tb.prototype = { render: function render() {
      var a = this.renderer,
          b = this.options,
          c = b.trackBorderWidth,
          d = b.barBorderWidth,
          e = this.size,
          f;this.group = f = a.g("highcharts-scrollbar").attr({ zIndex: b.zIndex,
        translateY: -99999 }).add();this.track = a.rect().attr({ height: e, width: e, y: -c % 2 / 2, x: -c % 2 / 2, "stroke-width": c, fill: b.trackBackgroundColor, stroke: b.trackBorderColor, r: b.trackBorderRadius || 0 }).add(f);this.scrollbarGroup = a.g().add(f);this.scrollbar = a.rect().attr({ height: e, width: e, y: -d % 2 / 2, x: -d % 2 / 2, "stroke-width": d, fill: b.barBackgroundColor, stroke: b.barBorderColor, r: b.barBorderRadius || 0 }).add(this.scrollbarGroup);this.scrollbarRifles = a.path(this.swapXY([W, -3, e / 4, R, -3, 2 * e / 3, W, 0, e / 4, R, 0, 2 * e / 3, W, 3, e / 4, R, 3, 2 * e / 3], b.vertical)).attr({ stroke: b.rifleColor, "stroke-width": 1 }).add(this.scrollbarGroup);this.drawScrollbarButton(0);this.drawScrollbarButton(1);
    }, position: function position(a, b, c, d) {
      var e = this.options,
          f = e.vertical,
          g = 0,
          h = this.rendered ? "animate" : "attr";this.x = a;this.y = b + e.trackBorderWidth;this.width = c;this.xOffset = this.height = d;this.yOffset = g;f ? (this.width = this.yOffset = c = g = this.size, this.xOffset = b = 0, this.barWidth = d - c * 2, this.x = a += this.options.margin) : (this.height = this.xOffset = d = b = this.size, this.barWidth = c - d * 2, this.y += this.options.margin);this.group[h]({ translateX: a, translateY: this.y });this.track[h]({ width: c, height: d });this.scrollbarButtons[1].attr({ translateX: f ? 0 : c - b, translateY: f ? d - g : 0 });
    }, drawScrollbarButton: function drawScrollbarButton(a) {
      var b = this.renderer,
          c = this.scrollbarButtons,
          d = this.options,
          e = this.size,
          f;f = b.g().add(this.group);c.push(f);b.rect(-0.5, -0.5, e + 1, e + 1, d.buttonBorderRadius, d.buttonBorderWidth).attr({ stroke: d.buttonBorderColor, "stroke-width": d.buttonBorderWidth, fill: d.buttonBackgroundColor }).add(f);b.path(this.swapXY(["M", e / 2 + (a ? -1 : 1), e / 2 - 3, "L", e / 2 + (a ? -1 : 1), e / 2 + 3, "L", e / 2 + (a ? 2 : -2), e / 2], d.vertical)).attr({ fill: d.buttonArrowColor }).add(f);
    }, swapXY: function swapXY(a, b) {
      var c,
          d = a.length,
          e;if (b) for (c = 0; c < d; c += 3) {
        e = a[c + 1], a[c + 1] = a[c + 2], a[c + 2] = e;
      }return a;
    }, setRange: function setRange(a, b) {
      var c = this.options,
          d = c.vertical,
          e,
          f,
          g,
          h = this.rendered && !this.hasDragged ? "animate" : "attr";if (t(this.barWidth)) e = this.barWidth * Math.max(a, 0), f = this.barWidth * Math.min(b, 1), f = Math.max(V(f - e), c.minWidth), e = Math.floor(e + this.xOffset + this.yOffset), g = f / 2 - 0.5, this.from = a, this.to = b, d ? (this.scrollbarGroup[h]({ translateY: e }), this.scrollbar[h]({ height: f }), this.scrollbarRifles[h]({ translateY: g }), this.scrollbarTop = e, this.scrollbarLeft = 0) : (this.scrollbarGroup[h]({ translateX: e }), this.scrollbar[h]({ width: f }), this.scrollbarRifles[h]({ translateX: g }), this.scrollbarLeft = e, this.scrollbarTop = 0), f <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0), c.showFull === !1 && (a <= 0 && b >= 1 ? this.group.hide() : this.group.show()), this.rendered = !0;
    }, initEvents: function initEvents() {
      var a = this;a.mouseMoveHandler = function (b) {
        var c = a.chart.pointer.normalize(b),
            d = a.options.vertical ? "chartY" : "chartX",
            e = a.initPositions;if (a.grabbedCenter && (!b.touches || b.touches[0][d] !== 0)) c = { chartX: (c.chartX - a.x - a.xOffset) / a.barWidth, chartY: (c.chartY - a.y - a.yOffset) / a.barWidth }[d], d = a[d], d = c - d, a.hasDragged = !0, a.updatePosition(e[0] + d, e[1] + d), a.hasDragged && K(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMType: b.type, DOMEvent: b });
      };a.mouseUpHandler = function (b) {
        a.hasDragged && K(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar",
          DOMType: b.type, DOMEvent: b });a.grabbedCenter = a.hasDragged = a.chartX = a.chartY = null;
      };a.mouseDownHandler = function (b) {
        b = a.chart.pointer.normalize(b);a.chartX = (b.chartX - a.x - a.xOffset) / a.barWidth;a.chartY = (b.chartY - a.y - a.yOffset) / a.barWidth;a.initPositions = [a.from, a.to];a.grabbedCenter = !0;
      };a.buttonToMinClick = function (b) {
        var c = V(a.to - a.from) * a.options.step;a.updatePosition(V(a.from - c), V(a.to - c));K(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMEvent: b });
      };a.buttonToMaxClick = function (b) {
        var c = (a.to - a.from) * a.options.step;a.updatePosition(a.from + c, a.to + c);K(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMEvent: b });
      };a.trackClick = function (b) {
        var c = a.chart.pointer.normalize(b),
            d = a.to - a.from,
            e = a.y + a.scrollbarTop,
            f = a.x + a.scrollbarLeft;a.options.vertical && c.chartY > e || !a.options.vertical && c.chartX > f ? a.updatePosition(a.from + d, a.to + d) : a.updatePosition(a.from - d, a.to - d);K(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMEvent: b });
      };
    }, updatePosition: function updatePosition(a, b) {
      b > 1 && (a = V(1 - V(b - a)), b = 1);a < 0 && (b = V(b - a), a = 0);this.from = a;this.to = b;
    }, addEvents: function addEvents() {
      var a = this.options.inverted ? [1, 0] : [0, 1],
          b = this.scrollbarButtons,
          c = this.scrollbarGroup.element,
          d = this.mouseDownHandler,
          e = this.mouseMoveHandler,
          f = this.mouseUpHandler,
          a = [[b[a[0]].element, "click", this.buttonToMinClick], [b[a[1]].element, "click", this.buttonToMaxClick], [this.track.element, "click", this.trackClick], [c, "mousedown", d], [C, "mousemove", e], [C, "mouseup", f]];$a && a.push([c, "touchstart", d], [C, "touchmove", e], [C, "touchend", f]);o(a, function (a) {
        G.apply(null, a);
      });this._events = a;
    }, removeEvents: function removeEvents() {
      o(this._events, function (a) {
        U.apply(null, a);
      });this._events = x;
    }, destroy: function destroy() {
      this.removeEvents();o([this.track, this.scrollbarRifles, this.scrollbar, this.scrollbarGroup, this.group], function (a) {
        a && a.destroy && a.destroy();
      });Oa(this.scrollbarButtons);
    } };S(J.prototype, "init", function (a) {
    var b = this;a.apply(b, [].slice.call(arguments, 1));if (b.options.scrollbar && b.options.scrollbar.enabled) b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new tb(b.chart.renderer, b.options.scrollbar, b.chart), G(b.scrollbar, "changed", function (a) {
      var d = Math.min(q(b.options.min, b.min), b.min, b.dataMin),
          e = Math.max(q(b.options.max, b.max), b.max, b.dataMax) - d,
          f;b.horiz && !b.reversed || !b.horiz && b.reversed ? (f = d + e * this.to, d += e * this.from) : (f = d + e * (1 - this.from), d += e * (1 - this.to));b.setExtremes(d, f, !0, !1, a);
    });
  });S(J.prototype, "render", function (a) {
    var b = Math.min(q(this.options.min, this.min), this.min, this.dataMin),
        c = Math.max(q(this.options.max, this.max), this.max, this.dataMax),
        d = this.scrollbar,
        e;a.apply(this, [].slice.call(arguments, 1));d && (this.horiz ? d.position(this.left, this.top + this.height + this.offset + 2 + (this.opposite ? 0 : this.axisTitleMargin), this.width, this.height) : d.position(this.left + this.width + 2 + this.offset + (this.opposite ? this.axisTitleMargin : 0), this.top, this.width, this.height), isNaN(b) || isNaN(c) || !t(this.min) || !t(this.max) ? d.setRange(0, 0) : (e = (this.min - b) / (c - b), b = (this.max - b) / (c - b), this.horiz && !this.reversed || !this.horiz && this.reversed ? d.setRange(e, b) : d.setRange(1 - b, 1 - e)));
  });S(J.prototype, "getOffset", function (a) {
    var b = this.horiz ? 2 : 1,
        c = this.scrollbar;a.apply(this, [].slice.call(arguments, 1));c && (this.chart.axisOffset[b] += c.size + c.options.margin);
  });S(J.prototype, "destroy", function (a) {
    if (this.scrollbar) this.scrollbar = this.scrollbar.destroy();a.apply(this, [].slice.call(arguments, 1));
  });B.Scrollbar = tb;var ga = [].concat(ac),
      zb = function zb(a) {
    var b = Ha(arguments, z);if (b.length) return Math[a].apply(0, b);
  };ga[4] = ["day", [1, 2, 3, 4]];ga[5] = ["week", [1, 2, 3]];v(Q, { navigator: { handles: { backgroundColor: "#ebe7e8",
        borderColor: "#b2b1b6" }, height: 40, margin: 25, maskFill: "rgba(128,179,236,0.3)", maskInside: !0, outlineColor: "#b2b1b6", outlineWidth: 1, series: { type: I.areaspline === x ? "line" : "areaspline", color: "#4572A7", compare: null, fillOpacity: 0.05, dataGrouping: { approximation: "average", enabled: !0, groupPixelWidth: 2, smoothed: !0, units: ga }, dataLabels: { enabled: !1, zIndex: 2 }, id: "highcharts-navigator-series", lineColor: null, lineWidth: 1, marker: { enabled: !1 }, pointRange: 0, shadow: !1, threshold: null }, xAxis: { tickWidth: 0, lineWidth: 0, gridLineColor: "#EEE",
        gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#888" }, x: 3, y: -4 }, crosshair: !1 }, yAxis: { gridLineWidth: 0, startOnTick: !1, endOnTick: !1, minPadding: 0.1, maxPadding: 0.1, labels: { enabled: !1 }, crosshair: !1, title: { text: null }, tickWidth: 0 } } });Jb.prototype = { drawHandle: function drawHandle(a, b) {
      var c = this.chart.renderer,
          d = this.elementsToDestroy,
          e = this.handles,
          f = this.navigatorOptions.handles,
          f = { fill: f.backgroundColor, stroke: f.borderColor, "stroke-width": 1 },
          g;this.rendered || (e[b] = c.g("navigator-handle-" + ["left", "right"][b]).css({ cursor: "ew-resize" }).attr({ zIndex: 10 - b }).add(), g = c.rect(-4.5, 0, 9, 16, 0, 1).attr(f).add(e[b]), d.push(g), g = c.path(["M", -1.5, 4, "L", -1.5, 12, "M", 0.5, 4, "L", 0.5, 12]).attr(f).add(e[b]), d.push(g));e[b][this.rendered && !this.hasDragged ? "animate" : "attr"]({ translateX: this.scrollerLeft + this.scrollbarHeight + parseInt(a, 10), translateY: this.top + this.height / 2 - 8 });
    }, render: function render(a, b, c, d) {
      var e = this.chart,
          f = e.renderer,
          g,
          h,
          i,
          j,
          k = this.navigatorGroup;j = this.scrollbarHeight;var k = this.xAxis,
          l = this.navigatorOptions,
          m = this.height,
          n = this.top,
          p = this.navigatorEnabled,
          o = l.outlineWidth,
          s = o / 2,
          v = this.outlineHeight,
          u = n + s,
          w = this.rendered;if (z(a) && z(b) && (!this.hasDragged || t(c))) {
        this.navigatorLeft = g = q(k.left, e.plotLeft + j);this.navigatorWidth = h = q(k.len, e.plotWidth - 2 * j);this.scrollerLeft = i = g - j;this.scrollerWidth = j = j = h + 2 * j;c = q(c, k.translate(a));d = q(d, k.translate(b));if (!z(c) || T(c) === Infinity) c = 0, d = j;if (!(k.translate(d, !0) - k.translate(c, !0) < e.xAxis[0].minRange)) {
          this.zoomedMax = E(y(c, d, 0), h);this.zoomedMin = E(y(this.fixedWidth ? this.zoomedMax - this.fixedWidth : E(c, d), 0), h);this.range = this.zoomedMax - this.zoomedMin;b = A(this.zoomedMax);a = A(this.zoomedMin);if (!w && p) this.navigatorGroup = k = f.g("navigator").attr({ zIndex: 3 }).add(), this.leftShade = f.rect().attr({ fill: l.maskFill }).add(k), l.maskInside ? this.leftShade.css({ cursor: "ew-resize" }) : this.rightShade = f.rect().attr({ fill: l.maskFill }).add(k), this.outline = f.path().attr({ "stroke-width": o, stroke: l.outlineColor }).add(k);f = w && !this.hasDragged ? "animate" : "attr";if (p) {
            this.leftShade[f](l.maskInside ? { x: g + a, y: n, width: b - a, height: m } : { x: g, y: n, width: a, height: m });if (this.rightShade) this.rightShade[f]({ x: g + b, y: n, width: h - b, height: m });this.outline[f]({ d: [W, i, u, R, g + a - s, u, g + a - s, u + v, R, g + b - s, u + v, R, g + b - s, u, i + j, u].concat(l.maskInside ? [W, g + a + s, u, R, g + b - s, u] : []) });this.drawHandle(a + s, 0);this.drawHandle(b + s, 1);
          }if (this.scrollbar) this.scrollbar.hasDragged = this.hasDragged, this.scrollbar.position(this.scrollerLeft, this.top + (p ? this.height : -this.scrollbarHeight), this.scrollerWidth, this.scrollbarHeight), this.scrollbar.setRange(a / h, b / h);this.rendered = !0;
        }
      }
    }, addEvents: function addEvents() {
      var a = this.chart,
          b = a.container,
          c = this.mouseDownHandler,
          d = this.mouseMoveHandler,
          e = this.mouseUpHandler,
          f;f = [[b, "mousedown", c], [b, "mousemove", d], [C, "mouseup", e]];$a && f.push([b, "touchstart", c], [b, "touchmove", d], [C, "touchend", e]);o(f, function (a) {
        G.apply(null, a);
      });this._events = f;this.series && G(this.series.xAxis, "foundExtremes", function () {
        a.scroller.modifyNavigatorAxisExtremes();
      });G(a, "redraw", function () {
        var a = this.scroller,
            b = a && a.baseSeries && a.baseSeries.xAxis;
        b && a.render(b.min, b.max);
      });
    }, removeEvents: function removeEvents() {
      o(this._events, function (a) {
        U.apply(null, a);
      });this._events = x;this.removeBaseSeriesEvents();
    }, removeBaseSeriesEvents: function removeBaseSeriesEvents() {
      this.navigatorEnabled && this.baseSeries && this.baseSeries.xAxis && this.navigatorOptions.adaptToUpdatedData !== !1 && (U(this.baseSeries, "updatedData", this.updatedDataHandler), U(this.baseSeries.xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
    }, init: function init() {
      var a = this,
          b = a.chart,
          c,
          d,
          e = a.scrollbarHeight,
          f = a.navigatorOptions,
          g = a.height,
          h = a.top,
          i,
          j = a.baseSeries;a.mouseDownHandler = function (d) {
        var d = b.pointer.normalize(d),
            e = a.zoomedMin,
            f = a.zoomedMax,
            h = a.top,
            j = a.scrollerLeft,
            k = a.scrollerWidth,
            l = a.navigatorLeft,
            o = a.navigatorWidth,
            q = a.scrollbarPad || 0,
            t = a.range,
            v = d.chartX,
            x = d.chartY,
            d = b.xAxis[0],
            y,
            z = lb ? 10 : 7;if (x > h && x < h + g) if (aa.abs(v - e - l) < z) a.grabbedLeft = !0, a.otherHandlePos = f, a.fixedExtreme = d.max, b.fixedRange = null;else if (aa.abs(v - f - l) < z) a.grabbedRight = !0, a.otherHandlePos = e, a.fixedExtreme = d.min, b.fixedRange = null;else if (v > l + e - q && v < l + f + q) a.grabbedCenter = v, a.fixedWidth = t, i = v - e;else if (v > j && v < j + k) {
          f = v - l - t / 2;if (f < 0) f = 0;else if (f + t >= o) f = o - t, y = a.getUnionExtremes().dataMax;if (f !== e) a.fixedWidth = t, e = c.toFixedRange(f, f + t, null, y), d.setExtremes(e.min, e.max, !0, null, { trigger: "navigator" });
        }
      };a.mouseMoveHandler = function (c) {
        var d = a.scrollbarHeight,
            e = a.navigatorLeft,
            f = a.navigatorWidth,
            g = a.scrollerLeft,
            h = a.scrollerWidth,
            j = a.range,
            k;if (!c.touches || c.touches[0].pageX !== 0) {
          c = b.pointer.normalize(c);k = c.chartX;k < e ? k = e : k > g + h - d && (k = g + h - d);if (a.grabbedLeft) a.hasDragged = !0, a.render(0, 0, k - e, a.otherHandlePos);else if (a.grabbedRight) a.hasDragged = !0, a.render(0, 0, a.otherHandlePos, k - e);else if (a.grabbedCenter) a.hasDragged = !0, k < i ? k = i : k > f + i - j && (k = f + i - j), a.render(0, 0, k - i, k - i + j);if (a.hasDragged && a.scrollbar && a.scrollbar.options.liveRedraw) c.DOMType = c.type, setTimeout(function () {
            a.mouseUpHandler(c);
          }, 0);
        }
      };a.mouseUpHandler = function (d) {
        var e,
            f,
            g = d.DOMEvent || d;if (a.hasDragged || d.trigger === "scrollbar") {
          if (a.zoomedMin === a.otherHandlePos) e = a.fixedExtreme;else if (a.zoomedMax === a.otherHandlePos) f = a.fixedExtreme;if (a.zoomedMax === a.navigatorWidth) f = a.getUnionExtremes().dataMax;e = c.toFixedRange(a.zoomedMin, a.zoomedMax, e, f);t(e.min) && b.xAxis[0].setExtremes(e.min, e.max, !0, a.hasDragged ? !1 : null, { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: g });
        }if (d.DOMType !== "mousemove") a.grabbedLeft = a.grabbedRight = a.grabbedCenter = a.fixedWidth = a.fixedExtreme = a.otherHandlePos = a.hasDragged = i = null;
      };var k = b.xAxis.length,
          l = b.yAxis.length;b.extraBottomMargin = a.outlineHeight + f.margin;a.navigatorEnabled ? (a.xAxis = c = new J(b, D({ breaks: j && j.xAxis.options.breaks, ordinal: j && j.xAxis.options.ordinal }, f.xAxis, { id: "navigator-x-axis", isX: !0, type: "datetime", index: k, height: g, offset: 0, offsetLeft: e, offsetRight: -e, keepOrdinalPadding: !0, startOnTick: !1, endOnTick: !1, minPadding: 0, maxPadding: 0, zoomEnabled: !1 })), a.yAxis = d = new J(b, D(f.yAxis, { id: "navigator-y-axis", alignTicks: !1, height: g, offset: 0, index: l, zoomEnabled: !1 })), j || f.series.data ? a.addBaseSeries() : b.series.length === 0 && S(b, "redraw", function (c, d) {
        if (b.series.length > 0 && !a.series) a.setBaseSeries(), b.redraw = c;c.call(b, d);
      })) : a.xAxis = c = { translate: function translate(a, c) {
          var d = b.xAxis[0],
              f = d.getExtremes(),
              g = b.plotWidth - 2 * e,
              h = zb("min", d.options.min, f.dataMin),
              d = zb("max", d.options.max, f.dataMax) - h;return c ? a * d / g + h : g * (a - h) / d;
        }, toFixedRange: J.prototype.toFixedRange };if (b.options.scrollbar.enabled) a.scrollbar = new tb(b.renderer, D(b.options.scrollbar, { margin: a.navigatorEnabled ? 0 : 10 }), b), G(a.scrollbar, "changed", function (c) {
        var d = a.navigatorWidth,
            e = d * this.to;d *= this.from;a.hasDragged = a.scrollbar.hasDragged;a.render(0, 0, d, e);(b.options.scrollbar.liveRedraw || c.DOMType !== "mousemove") && setTimeout(function () {
          a.mouseUpHandler(c);
        });
      });a.addBaseSeriesEvents();S(b, "getMargins", function (b) {
        var e = this.legend,
            f = e.options;b.apply(this, [].slice.call(arguments, 1));a.top = h = a.navigatorOptions.top || this.chartHeight - a.height - a.scrollbarHeight - this.spacing[2] - (f.verticalAlign === "bottom" && f.enabled && !f.floating ? e.legendHeight + q(f.margin, 10) : 0);if (c && d) c.options.top = d.options.top = h, c.setAxisSize(), d.setAxisSize();
      });a.addEvents();
    }, getUnionExtremes: function getUnionExtremes(a) {
      var b = this.chart.xAxis[0],
          c = this.xAxis,
          d = c.options,
          e = b.options,
          f;if (!a || b.dataMin !== null) f = { dataMin: q(d && d.min, zb("min", e.min, b.dataMin, c.dataMin, c.min)), dataMax: q(d && d.max, zb("max", e.max, b.dataMax, c.dataMax, c.max)) };return f;
    }, setBaseSeries: function setBaseSeries(a) {
      var b = this.chart,
          a = a || b.options.navigator.baseSeries;this.series && (this.removeBaseSeriesEvents(), this.series.remove());this.baseSeries = b.series[a] || typeof a === "string" && b.get(a) || b.series[0];this.xAxis && this.addBaseSeries();
    }, addBaseSeries: function addBaseSeries() {
      var a = this.baseSeries,
          b = a ? a.options : {},
          a = b.data,
          c = this.navigatorOptions.series,
          d;d = c.data;this.hasNavigatorData = !!d;b = D(b, c, { enableMouseTracking: !1, group: "nav", padXAxis: !1, xAxis: "navigator-x-axis", yAxis: "navigator-y-axis", name: "Navigator", showInLegend: !1, stacking: !1, isInternal: !0, visible: !0 });b.data = d || a.slice(0);this.series = this.chart.initSeries(b);this.addBaseSeriesEvents();
    }, addBaseSeriesEvents: function addBaseSeriesEvents() {
      var a = this.baseSeries;if (a && a.xAxis && this.navigatorOptions.adaptToUpdatedData !== !1) G(a, "updatedData", this.updatedDataHandler), G(a.xAxis, "foundExtremes", this.modifyBaseAxisExtremes), a.userOptions.events = v(a.userOptions.event, { updatedData: this.updatedDataHandler });
    }, modifyNavigatorAxisExtremes: function modifyNavigatorAxisExtremes() {
      var a = this.xAxis,
          b;if (a.getExtremes && (b = this.getUnionExtremes(!0)) && (b.dataMin !== a.min || b.dataMax !== a.max)) a.min = b.dataMin, a.max = b.dataMax;
    }, modifyBaseAxisExtremes: function modifyBaseAxisExtremes() {
      if (this.chart.scroller.baseSeries && this.chart.scroller.baseSeries.xAxis) {
        var a = this.chart.scroller,
            b = this.getExtremes(),
            c = b.dataMin,
            d = b.dataMax,
            b = b.max - b.min,
            e = a.stickToMin,
            f = a.stickToMax,
            g,
            h,
            i = a.series,
            j = !!this.setExtremes;if (!(this.eventArgs && this.eventArgs.trigger === "rangeSelectorButton") && (e && (h = c, g = h + b), f && (g = d, e || (h = y(g - b, i && i.xData ? i.xData[0] : -Number.MAX_VALUE))), j && (e || f) && z(h))) this.min = this.userMin = h, this.max = this.userMax = g;a.stickToMin = a.stickToMax = null;
      }
    }, updatedDataHandler: function updatedDataHandler() {
      var a = this.chart.scroller,
          b = a.baseSeries,
          c = a.series;a.stickToMin = z(b.xAxis.min) && b.xAxis.min <= b.xData[0];a.stickToMax = Math.round(a.zoomedMax) >= Math.round(a.navigatorWidth);if (c && !a.hasNavigatorData) c.options.pointStart = b.xData[0], c.setData(b.options.data, !1, null, !1);
    }, destroy: function destroy() {
      this.removeEvents();o([this.scrollbar, this.xAxis, this.yAxis, this.leftShade, this.rightShade, this.outline], function (a) {
        a && a.destroy && a.destroy();
      });this.xAxis = this.yAxis = this.leftShade = this.rightShade = this.outline = null;o([this.handles, this.elementsToDestroy], function (a) {
        Oa(a);
      });
    } };B.Navigator = Jb;S(J.prototype, "zoom", function (a, b, c) {
    var d = this.chart,
        e = d.options,
        f = e.chart.zoomType,
        g = e.navigator,
        e = e.rangeSelector,
        h;if (this.isXAxis && (g && g.enabled || e && e.enabled)) if (f === "x") d.resetZoomButton = "blocked";else if (f === "y") h = !1;else if (f === "xy") d = this.previousZoom, t(b) ? this.previousZoom = [this.min, this.max] : d && (b = d[0], c = d[1], delete this.previousZoom);return h !== x ? h : a.call(this, b, c);
  });S(Da.prototype, "init", function (a, b, c) {
    G(this, "beforeRender", function () {
      var a = this.options;if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = new Jb(this);
    });a.call(this, b, c);
  });S(P.prototype, "addPoint", function (a, b, c, d, e) {
    var f = this.options.turboThreshold;f && this.xData.length > f && ha(b, !0) && this.chart.scroller && ja(20, !0);a.call(this, b, c, d, e);
  });v(Q, { rangeSelector: { buttonTheme: { width: 28, height: 18, fill: "#f7f7f7", padding: 2, r: 0, "stroke-width": 0, style: { color: "#444", cursor: "pointer", fontWeight: "normal" }, zIndex: 7, states: { hover: { fill: "#e7e7e7" }, select: { fill: "#e7f0f9", style: { color: "black", fontWeight: "bold" } } } }, height: 35, inputPosition: { align: "right" }, labelStyle: { color: "#666" } } });Q.lang = D(Q.lang, { rangeSelectorZoom: "Zoom",
    rangeSelectorFrom: "From", rangeSelectorTo: "To" });Kb.prototype = { clickButton: function clickButton(a, b) {
      var c = this,
          d = c.selected,
          e = c.chart,
          f = c.buttons,
          g = c.buttonOptions[a],
          h = e.xAxis[0],
          i = e.scroller && e.scroller.getUnionExtremes() || h || {},
          j = i.dataMin,
          k = i.dataMax,
          l,
          m = h && A(E(h.max, q(k, h.max))),
          n = g.type,
          p,
          i = g._range,
          r,
          s,
          t,
          u = g.dataGrouping;if (!(j === null || k === null || a === c.selected)) {
        e.fixedRange = i;if (u) this.forcedDataGrouping = !0, J.prototype.setDataGrouping.call(h || { chart: this.chart }, u, !1);if (n === "month" || n === "year") {
          if (h) {
            if (n = { range: g, max: m, dataMin: j, dataMax: k }, l = h.minFromRange.call(n), z(n.newMax)) m = n.newMax;
          } else i = g;
        } else if (i) l = y(m - i, j), m = E(l + i, k);else if (n === "ytd") {
          if (h) {
            if (k === x) j = Number.MAX_VALUE, k = Number.MIN_VALUE, o(e.series, function (a) {
              a = a.xData;j = E(a[0], j);k = y(a[a.length - 1], k);
            }), b = !1;m = new ea(k);l = m.getFullYear();l = r = y(j || 0, ea.UTC(l, 0, 1));m = m.getTime();m = E(k || m, m);
          } else {
            G(e, "beforeRender", function () {
              c.clickButton(a);
            });return;
          }
        } else n === "all" && h && (l = j, m = k);f[d] && f[d].setState(0);if (f[a]) f[a].setState(2), c.lastSelected = a;h ? (h.setExtremes(l, m, q(b, 1), null, { trigger: "rangeSelectorButton", rangeSelectorButton: g }), c.setSelected(a)) : (p = sa(e.options.xAxis)[0], t = p.range, p.range = i, s = p.min, p.min = r, c.setSelected(a), G(e, "load", function () {
          p.range = t;p.min = s;
        }));
      }
    }, setSelected: function setSelected(a) {
      this.selected = this.options.selected = a;
    }, defaultButtons: [{ type: "month", count: 1, text: "1m" }, { type: "month", count: 3, text: "3m" }, { type: "month", count: 6, text: "6m" }, { type: "ytd", text: "YTD" }, { type: "year", count: 1, text: "1y" }, { type: "all", text: "All" }], init: function init(a) {
      var b = this,
          c = a.options.rangeSelector,
          d = c.buttons || [].concat(b.defaultButtons),
          e = c.selected,
          f = b.blurInputs = function () {
        var a = b.minInput,
            c = b.maxInput;a && a.blur && K(a, "blur");c && c.blur && K(c, "blur");
      };b.chart = a;b.options = c;b.buttons = [];a.extraTopMargin = c.height;b.buttonOptions = d;G(a.container, "mousedown", f);G(a, "resize", f);o(d, b.computeButtonRange);e !== x && d[e] && this.clickButton(e, !1);G(a, "load", function () {
        G(a.xAxis[0], "setExtremes", function (c) {
          this.max - this.min !== a.fixedRange && c.trigger !== "rangeSelectorButton" && c.trigger !== "updatedData" && b.forcedDataGrouping && this.setDataGrouping(!1, !1);
        });G(a.xAxis[0], "afterSetExtremes", function () {
          b.updateButtonStates(!0);
        });
      });
    }, updateButtonStates: function updateButtonStates(a) {
      var b = this,
          c = this.chart,
          d = c.xAxis[0],
          e = c.scroller && c.scroller.getUnionExtremes() || d,
          f = e.dataMin,
          g = e.dataMax,
          h = b.selected,
          i = b.options.allButtonsEnabled,
          j = b.buttons;a && c.fixedRange !== A(d.max - d.min) && (j[h] && j[h].setState(0), b.setSelected(null));o(b.buttonOptions, function (a, e) {
        var m = A(d.max - d.min),
            n = a._range,
            o = a.type,
            q = a.count || 1,
            s = n > g - f,
            t = n < d.minRange,
            u = a.type === "all" && d.max - d.min >= g - f && j[e].state !== 2,
            w = a.type === "ytd" && pa("%Y", f) === pa("%Y", g),
            v = c.renderer.forExport && e === h,
            n = n === m,
            x = !d.hasVisibleSeries;if ((o === "month" || o === "year") && m >= { month: 28, year: 365 }[o] * 864E5 * q && m <= { month: 31, year: 366 }[o] * 864E5 * q) n = !0;v || n && e !== h && e === b.lastSelected ? (b.setSelected(e), j[e].setState(2)) : !i && (s || t || u || w || x) ? j[e].setState(3) : j[e].state === 3 && j[e].setState(0);
      });
    }, computeButtonRange: function computeButtonRange(a) {
      var b = a.type,
          c = a.count || 1,
          d = { millisecond: 1, second: 1E3,
        minute: 6E4, hour: 36E5, day: 864E5, week: 6048E5 };if (d[b]) a._range = d[b] * c;else if (b === "month" || b === "year") a._range = { month: 30, year: 365 }[b] * 864E5 * c;
    }, setInputValue: function setInputValue(a, b) {
      var c = this.chart.options.rangeSelector;if (t(b)) this[a + "Input"].HCTime = b;this[a + "Input"].value = pa(c.inputEditDateFormat || "%Y-%m-%d", this[a + "Input"].HCTime);this[a + "DateBox"].attr({ text: pa(c.inputDateFormat || "%b %e, %Y", this[a + "Input"].HCTime) });
    }, showInput: function showInput(a) {
      var b = this.inputGroup,
          c = this[a + "DateBox"];O(this[a + "Input"], { left: b.translateX + c.x + "px", top: b.translateY + "px", width: c.width - 2 + "px", height: c.height - 2 + "px", border: "2px solid silver" });
    }, hideInput: function hideInput(a) {
      O(this[a + "Input"], { border: 0, width: "1px", height: "1px" });this.setInputValue(a);
    }, drawInput: function drawInput(a) {
      function b() {
        var a = j.value,
            b = (g.inputDateParser || ea.parse)(a),
            e = d.xAxis[0],
            f = e.dataMin,
            h = e.dataMax;if (b !== j.previousValue) j.previousValue = b, z(b) || (b = a.split("-"), b = ea.UTC(H(b[0]), H(b[1]) - 1, H(b[2]))), z(b) && (Q.global.useUTC || (b += new ea().getTimezoneOffset() * 6E4), i ? b > c.maxInput.HCTime ? b = x : b < f && (b = f) : b < c.minInput.HCTime ? b = x : b > h && (b = h), b !== x && d.xAxis[0].setExtremes(i ? b : e.min, i ? e.max : b, x, x, { trigger: "rangeSelectorInput" }));
      }var c = this,
          d = c.chart,
          e = d.renderer.style,
          f = d.renderer,
          g = d.options.rangeSelector,
          h = c.div,
          i = a === "min",
          j,
          k,
          l = this.inputGroup;this[a + "Label"] = k = f.label(Q.lang[i ? "rangeSelectorFrom" : "rangeSelectorTo"], this.inputGroup.offset).attr({ padding: 2 }).css(D(e, g.labelStyle)).add(l);l.offset += k.width + 5;this[a + "DateBox"] = f = f.label("", l.offset).attr({ padding: 2, width: g.inputBoxWidth || 90, height: g.inputBoxHeight || 17, stroke: g.inputBoxBorderColor || "silver", "stroke-width": 1 }).css(D({ textAlign: "center", color: "#444" }, e, g.inputStyle)).on("click", function () {
        c.showInput(a);c[a + "Input"].focus();
      }).add(l);l.offset += f.width + (i ? 10 : 0);this[a + "Input"] = j = ia("input", { name: a, className: "highcharts-range-selector", type: "text" }, v({ position: "absolute", border: 0, width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: e.fontSize, fontFamily: e.fontFamily, left: "-9em", top: d.plotTop + "px" }, g.inputStyle), h);j.onfocus = function () {
        c.showInput(a);
      };j.onblur = function () {
        c.hideInput(a);
      };j.onchange = b;j.onkeypress = function (a) {
        a.keyCode === 13 && b();
      };
    }, getPosition: function getPosition() {
      var a = this.chart,
          b = a.options.rangeSelector,
          a = q((b.buttonPosition || {}).y, a.plotTop - a.axisOffset[0] - b.height);return { buttonTop: a, inputTop: a - 10 };
    }, render: function render(a, b) {
      var c = this,
          d = c.chart,
          e = d.renderer,
          f = d.container,
          g = d.options,
          h = g.exporting && g.exporting.enabled !== !1 && g.navigation && g.navigation.buttonOptions,
          i = g.rangeSelector,
          j = c.buttons,
          g = Q.lang,
          k = c.div,
          k = c.inputGroup,
          l = i.buttonTheme,
          m = i.buttonPosition || {},
          n = i.inputEnabled,
          p = l && l.states,
          r = d.plotLeft,
          s,
          x = this.getPosition(),
          u = c.group,
          w = c.rendered;if (!w && (c.group = u = e.g("range-selector-buttons").add(), c.zoomText = e.text(g.rangeSelectorZoom, q(m.x, r), 15).css(i.labelStyle).add(u), s = q(m.x, r) + c.zoomText.getBBox().width + 5, o(c.buttonOptions, function (a, b) {
        j[b] = e.button(a.text, s, 0, function () {
          c.clickButton(b);c.isActive = !0;
        }, l, p && p.hover, p && p.select, p && p.disabled).css({ textAlign: "center" }).add(u);s += j[b].width + q(i.buttonSpacing, 5);c.selected === b && j[b].setState(2);
      }), c.updateButtonStates(), n !== !1)) c.div = k = ia("div", null, { position: "relative", height: 0, zIndex: 1 }), f.parentNode.insertBefore(k, f), c.inputGroup = k = e.g("input-group").add(), k.offset = 0, c.drawInput("min"), c.drawInput("max");u[w ? "animate" : "attr"]({ translateY: x.buttonTop });n !== !1 && (k.align(v({ y: x.inputTop, width: k.offset, x: h && x.inputTop < (h.y || 0) + h.height - d.spacing[0] ? -40 : 0 }, i.inputPosition), !0, d.spacingBox), t(n) || (d = u.getBBox(), k[k.translateX < d.x + d.width + 10 ? "hide" : "show"]()), c.setInputValue("min", a), c.setInputValue("max", b));c.rendered = !0;
    }, destroy: function destroy() {
      var a = this.minInput,
          b = this.maxInput,
          c = this.chart,
          d = this.blurInputs,
          e;U(c.container, "mousedown", d);U(c, "resize", d);Oa(this.buttons);if (a) a.onfocus = a.onblur = a.onchange = null;if (b) b.onfocus = b.onblur = b.onchange = null;for (e in this) {
        this[e] && e !== "chart" && (this[e].destroy ? this[e].destroy() : this[e].nodeType && Wa(this[e])), this[e] = null;
      }
    } };J.prototype.toFixedRange = function (a, b, c, d) {
    var e = this.chart && this.chart.fixedRange,
        a = q(c, this.translate(a, !0)),
        b = q(d, this.translate(b, !0)),
        c = e && (b - a) / e;c > 0.7 && c < 1.3 && (d ? a = b - e : b = a + e);z(a) || (a = b = void 0);return { min: a, max: b };
  };J.prototype.minFromRange = function () {
    var a = this.range,
        b = { month: "Month", year: "FullYear" }[a.type],
        c,
        d = this.max,
        e,
        f,
        g = function g(a, c) {
      var d = new ea(a);d["set" + b](d["get" + b]() + c);return d.getTime() - a;
    };z(a) ? (c = this.max - a, f = a) : c = d + g(d, -a.count);e = q(this.dataMin, Number.MIN_VALUE);z(c) || (c = e);if (c <= e) c = e, f === void 0 && (f = g(c, a.count)), this.newMax = E(c + f, this.dataMax);z(d) || (c = void 0);return c;
  };S(Da.prototype, "init", function (a, b, c) {
    G(this, "init", function () {
      if (this.options.rangeSelector.enabled) this.rangeSelector = new Kb(this);
    });a.call(this, b, c);
  });B.RangeSelector = Kb;Da.prototype.callbacks.push(function (a) {
    function b() {
      d = a.xAxis[0].getExtremes();z(d.min) && f.render(d.min, d.max);
    }function c(a) {
      f.render(a.min, a.max);
    }var d,
        e = a.scroller,
        f = a.rangeSelector;e && (d = a.xAxis[0].getExtremes(), e.render(d.min, d.max));f && (G(a.xAxis[0], "afterSetExtremes", c), G(a, "resize", b), b());G(a, "destroy", function () {
      f && (U(a, "resize", b), U(a.xAxis[0], "afterSetExtremes", c));
    });
  });B.StockChart = B.stockChart = function (a, b, c) {
    var d = Ea(a) || a.nodeName,
        e = arguments[d ? 1 : 0],
        f = e.series,
        g,
        h = q(e.navigator && e.navigator.enabled, !0) ? { startOnTick: !1, endOnTick: !1 } : null,
        i = { marker: { enabled: !1, radius: 2 } },
        j = { shadow: !1, borderWidth: 0 };e.xAxis = wa(sa(e.xAxis || {}), function (a) {
      return D({ minPadding: 0, maxPadding: 0, ordinal: !0, title: { text: null }, labels: { overflow: "justify" }, showLastLabel: !0 }, a, { type: "datetime", categories: null }, h);
    });e.yAxis = wa(sa(e.yAxis || {}), function (a) {
      g = q(a.opposite, !0);return D({ labels: { y: -2 }, opposite: g, showLastLabel: !1, title: { text: null } }, a);
    });e.series = null;e = D({ chart: { panning: !0, pinchType: "x" }, navigator: { enabled: !0 }, scrollbar: { enabled: !0 }, rangeSelector: { enabled: !0 }, title: { text: null, style: { fontSize: "16px" } }, tooltip: { shared: !0, crosshairs: !0 }, legend: { enabled: !1 }, plotOptions: { line: i, spline: i, area: i, areaspline: i, arearange: i, areasplinerange: i, column: j, columnrange: j, candlestick: j, ohlc: j } }, e, { _stock: !0, chart: { inverted: !1 } });
    e.series = f;return d ? new Da(a, e, c) : new Da(e, b);
  };S(ab.prototype, "init", function (a, b, c) {
    var d = c.chart.pinchType || "";a.call(this, b, c);this.pinchX = this.pinchHor = d.indexOf("x") !== -1;this.pinchY = this.pinchVert = d.indexOf("y") !== -1;this.hasZoom = this.hasZoom || this.pinchHor || this.pinchVert;
  });S(J.prototype, "autoLabelAlign", function (a) {
    var b = this.chart,
        c = this.options,
        b = b._labelPanes = b._labelPanes || {},
        d = this.options.labels;if (this.chart.options._stock && this.coll === "yAxis" && (c = c.top + "," + c.height, !b[c] && d.enabled)) {
      if (d.x === 15) d.x = 0;if (d.align === void 0) d.align = "right";b[c] = 1;return "right";
    }return a.call(this, [].slice.call(arguments, 1));
  });S(J.prototype, "getPlotLinePath", function (a, b, c, d, e, f) {
    var g = this,
        h = this.isLinked && !this.series ? this.linkedParent.series : this.series,
        i = g.chart,
        j = i.renderer,
        k = g.left,
        l = g.top,
        m,
        n,
        p,
        r,
        s = [],
        v = [],
        u,
        w;if (g.coll === "colorAxis") return a.apply(this, [].slice.call(arguments, 1));v = g.isXAxis ? t(g.options.yAxis) ? [i.yAxis[g.options.yAxis]] : wa(h, function (a) {
      return a.yAxis;
    }) : t(g.options.xAxis) ? [i.xAxis[g.options.xAxis]] : wa(h, function (a) {
      return a.xAxis;
    });o(g.isXAxis ? i.yAxis : i.xAxis, function (a) {
      if (t(a.options.id) ? a.options.id.indexOf("navigator") === -1 : 1) {
        var b = a.isXAxis ? "yAxis" : "xAxis",
            b = t(a.options[b]) ? i[b][a.options[b]] : i[b][0];g === b && v.push(a);
      }
    });u = v.length ? [] : [g.isXAxis ? i.yAxis[0] : i.xAxis[0]];o(v, function (a) {
      qa(a, u) === -1 && u.push(a);
    });w = q(f, g.translate(b, null, null, d));z(w) && (g.horiz ? o(u, function (a) {
      var b;n = a.pos;r = n + a.len;m = p = A(w + g.transB);if (m < k || m > k + g.width) e ? m = p = E(y(k, m), k + g.width) : b = !0;b || s.push("M", m, n, "L", p, r);
    }) : o(u, function (a) {
      var b;m = a.pos;p = m + a.len;n = r = A(l + g.height - w);if (n < l || n > l + g.height) e ? n = r = E(y(l, n), g.top + g.height) : b = !0;b || s.push("M", m, n, "L", p, r);
    }));return s.length > 0 ? j.crispPolyLine(s, c || 1) : null;
  });J.prototype.getPlotBandPath = function (a, b) {
    var c = this.getPlotLinePath(b, null, null, !0),
        d = this.getPlotLinePath(a, null, null, !0),
        e = [],
        f;if (d && c && d.toString() !== c.toString()) for (f = 0; f < d.length; f += 6) {
      e.push("M", d[f + 1], d[f + 2], "L", d[f + 4], d[f + 5], c[f + 4], c[f + 5], c[f + 1], c[f + 2]);
    } else e = null;return e;
  };za.prototype.crispPolyLine = function (a, b) {
    var c;for (c = 0; c < a.length; c += 6) {
      a[c + 1] === a[c + 4] && (a[c + 1] = a[c + 4] = A(a[c + 1]) - b % 2 / 2), a[c + 2] === a[c + 5] && (a[c + 2] = a[c + 5] = A(a[c + 2]) + b % 2 / 2);
    }return a;
  };if (Za === B.VMLRenderer) nb.prototype.crispPolyLine = za.prototype.crispPolyLine;S(J.prototype, "hideCrosshair", function (a, b) {
    a.call(this, b);if (this.crossLabel) this.crossLabel = this.crossLabel.hide();
  });S(J.prototype, "drawCrosshair", function (a, b, c) {
    var d, e;a.call(this, b, c);if (t(this.crosshair.label) && this.crosshair.label.enabled && this.cross) {
      var a = this.chart,
          f = this.options.crosshair.label,
          g = this.horiz,
          h = this.opposite,
          i = this.left,
          j = this.top,
          k = this.crossLabel,
          l,
          m = f.format,
          n = "",
          o = this.options.tickPosition === "inside",
          r = this.crosshair.snap !== !1;b || (b = this.cross && this.cross.e);l = g ? "center" : h ? this.labelAlign === "right" ? "right" : "left" : this.labelAlign === "left" ? "left" : "center";if (!k) k = this.crossLabel = a.renderer.label(null, null, null, f.shape || "callout").attr({ align: f.align || l, zIndex: 12, fill: f.backgroundColor || this.series[0] && this.series[0].color || "gray", padding: q(f.padding, 8), stroke: f.borderColor || "", "stroke-width": f.borderWidth || 0, r: q(f.borderRadius, 3) }).css(v({ color: "white", fontWeight: "normal", fontSize: "11px", textAlign: "center" }, f.style)).add();g ? (l = r ? c.plotX + i : b.chartX, j += h ? 0 : this.height) : (l = h ? this.width + i : 0, j = r ? c.plotY + j : b.chartY);!m && !f.formatter && (this.isDatetimeAxis && (n = "%b %d, %Y"), m = "{value" + (n ? ":" + n : "") + "}");b = r ? c[this.isXAxis ? "x" : "y"] : this.toValue(g ? b.chartX : b.chartY);k.attr({ text: m ? Ma(m, { value: b }) : f.formatter.call(this, b), anchorX: g ? l : this.opposite ? 0 : a.chartWidth,
        anchorY: g ? this.opposite ? a.chartHeight : 0 : j, x: l, y: j, visibility: "visible" });b = k.getBBox();if (g) {
        if (o && !h || !o && h) j = k.y - b.height;
      } else j = k.y - b.height / 2;g ? (d = i - b.x, e = i + this.width - b.x) : (d = this.labelAlign === "left" ? i : 0, e = this.labelAlign === "right" ? i + this.width : a.chartWidth);k.translateX < d && (l += d - k.translateX);k.translateX + b.width >= e && (l -= k.translateX + b.width - e);k.attr({ x: l, y: j, visibility: "visible" });
    }
  });var jc = la.init,
      kc = la.processData,
      lc = Ja.prototype.tooltipFormatter;la.init = function () {
    jc.apply(this, arguments);
    this.setCompare(this.options.compare);
  };la.setCompare = function (a) {
    this.modifyValue = a === "value" || a === "percent" ? function (b, c) {
      var d = this.compareValue;if (b !== x && (b = a === "value" ? b - d : b = 100 * (b / d) - 100, c)) c.change = b;return b;
    } : null;this.userOptions.compare = a;if (this.chart.hasRendered) this.isDirty = !0;
  };la.processData = function () {
    var a,
        b = -1,
        c,
        d,
        e,
        f;kc.apply(this, arguments);if (this.xAxis && this.processedYData) {
      c = this.processedXData;d = this.processedYData;e = d.length;this.pointArrayMap && (b = qa(this.pointValKey || "y", this.pointArrayMap));
      for (a = 0; a < e - 1; a++) {
        if (f = b > -1 ? d[a][b] : d[a], z(f) && c[a + 1] >= this.xAxis.min && f !== 0) {
          this.compareValue = f;break;
        }
      }
    }
  };S(la, "getExtremes", function (a) {
    var b;a.apply(this, [].slice.call(arguments, 1));if (this.modifyValue) b = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)], this.dataMin = Na(b), this.dataMax = Fa(b);
  });J.prototype.setCompare = function (a, b) {
    this.isXAxis || (o(this.series, function (b) {
      b.setCompare(a);
    }), q(b, !0) && this.chart.redraw());
  };Ja.prototype.tooltipFormatter = function (a) {
    a = a.replace("{point.change}", (this.change > 0 ? "+" : "") + B.numberFormat(this.change, q(this.series.tooltipOptions.changeDecimals, 2)));return lc.apply(this, [a]);
  };S(P.prototype, "render", function (a) {
    if (this.chart.options._stock && this.xAxis) !this.clipBox && this.animate ? (this.clipBox = D(this.chart.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = this.yAxis.len) : this.chart[this.sharedClipKey] && (Qa(this.chart[this.sharedClipKey]), this.chart[this.sharedClipKey].attr({ width: this.xAxis.len, height: this.yAxis.len }));a.call(this);
  });
  v(B, { Color: xa, Point: Ja, Tick: eb, Renderer: Za, SVGElement: ba, SVGRenderer: za, arrayMin: Na, arrayMax: Fa, charts: ca, correctFloat: V, dateFormat: pa, error: ja, format: Ma, pathAnim: void 0, getOptions: function getOptions() {
      return Q;
    }, hasBidiBug: bc, isTouchDevice: lb, setOptions: function setOptions(a) {
      Q = D(!0, Q, a);Qb();return Q;
    }, addEvent: G, removeEvent: U, createElement: ia, discardElement: Wa, css: O, each: o, map: wa, merge: D, splat: sa, stableSort: pb, extendClass: oa, pInt: H, svg: ma, canvas: ua, vml: !ma && !ua, product: "Highstock", version: "4.2.6" });return B;
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highcharts JS v4.2.6 (2016-08-02)

 (c) 2009-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (m) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = m : m(Highcharts);
})(function (m) {
  function M(a, b, c) {
    this.init(a, b, c);
  }var R = m.arrayMin,
      S = m.arrayMax,
      t = m.each,
      H = m.extend,
      I = m.isNumber,
      u = m.merge,
      T = m.map,
      r = m.pick,
      B = m.pInt,
      G = m.correctFloat,
      p = m.getOptions().plotOptions,
      i = m.seriesTypes,
      v = m.extendClass,
      N = m.splat,
      w = m.wrap,
      O = m.Axis,
      z = m.Tick,
      J = m.Point,
      U = m.Pointer,
      V = m.CenteredSeriesMixin,
      C = m.TrackerMixin,
      x = m.Series,
      y = Math,
      F = y.round,
      D = y.floor,
      P = y.max,
      W = m.Color,
      n = function n() {};H(M.prototype, { init: function init(a, b, c) {
      var d = this,
          g = d.defaultOptions;d.chart = b;d.options = a = u(g, b.angular ? { background: {} } : void 0, a);(a = a.background) && t([].concat(N(a)).reverse(), function (a) {
        var b = a.backgroundColor,
            g = c.userOptions,
            a = u(d.defaultBackgroundOptions, a);if (b) a.backgroundColor = b;a.color = a.backgroundColor;c.options.plotBands.unshift(a);g.plotBands = g.plotBands || [];g.plotBands !== c.options.plotBands && g.plotBands.unshift(a);
      });
    }, defaultOptions: { center: ["50%", "50%"], size: "85%", startAngle: 0 }, defaultBackgroundOptions: { shape: "circle",
      borderWidth: 1, borderColor: "silver", backgroundColor: { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, "#FFF"], [1, "#DDD"]] }, from: -Number.MAX_VALUE, innerRadius: 0, to: Number.MAX_VALUE, outerRadius: "105%" } });var A = O.prototype,
      z = z.prototype,
      X = { getOffset: n, redraw: function redraw() {
      this.isDirty = !1;
    }, render: function render() {
      this.isDirty = !1;
    }, setScale: n, setCategories: n, setTitle: n },
      Q = { isRadial: !0, defaultRadialGaugeOptions: { labels: { align: "center", x: 0, y: null }, minorGridLineWidth: 0, minorTickInterval: "auto", minorTickLength: 10, minorTickPosition: "inside",
      minorTickWidth: 1, tickLength: 10, tickPosition: "inside", tickWidth: 2, title: { rotation: 0 }, zIndex: 2 }, defaultRadialXOptions: { gridLineWidth: 1, labels: { align: null, distance: 15, x: 0, y: null }, maxPadding: 0, minPadding: 0, showLastLabel: !1, tickLength: 0 }, defaultRadialYOptions: { gridLineInterpolation: "circle", labels: { align: "right", x: -3, y: -2 }, showLastLabel: !1, title: { x: 4, text: null, rotation: 90 } }, setOptions: function setOptions(a) {
      a = this.options = u(this.defaultOptions, this.defaultRadialOptions, a);if (!a.plotBands) a.plotBands = [];
    }, getOffset: function getOffset() {
      A.getOffset.call(this);
      this.chart.axisOffset[this.side] = 0;this.center = this.pane.center = V.getCenter.call(this.pane);
    }, getLinePath: function getLinePath(a, b) {
      var c = this.center,
          b = r(b, c[2] / 2 - this.offset);return this.chart.renderer.symbols.arc(this.left + c[0], this.top + c[1], b, b, { start: this.startAngleRad, end: this.endAngleRad, open: !0, innerR: 0 });
    }, setAxisTranslation: function setAxisTranslation() {
      A.setAxisTranslation.call(this);if (this.center) this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.center[2] / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0;
    }, beforeSetTickPositions: function beforeSetTickPositions() {
      this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);
    }, setAxisSize: function setAxisSize() {
      A.setAxisSize.call(this);if (this.isRadial) {
        this.center = this.pane.center = m.CenteredSeriesMixin.getCenter.call(this.pane);if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;this.len = this.width = this.height = this.center[2] * r(this.sector, 1) / 2;
      }
    }, getPosition: function getPosition(a, b) {
      return this.postTranslate(this.isCircular ? this.translate(a) : 0, r(this.isCircular ? b : this.translate(a), this.center[2] / 2) - this.offset);
    }, postTranslate: function postTranslate(a, b) {
      var c = this.chart,
          d = this.center,
          a = this.startAngleRad + a;return { x: c.plotLeft + d[0] + Math.cos(a) * b, y: c.plotTop + d[1] + Math.sin(a) * b };
    }, getPlotBandPath: function getPlotBandPath(a, b, c) {
      var d = this.center,
          g = this.startAngleRad,
          e = d[2] / 2,
          j = [r(c.outerRadius, "100%"), c.innerRadius, r(c.thickness, 10)],
          l = Math.min(this.offset, 0),
          h = /%$/,
          f,
          k = this.isCircular;this.options.gridLineInterpolation === "polygon" ? d = this.getPlotLinePath(a).concat(this.getPlotLinePath(b, !0)) : (a = Math.max(a, this.min), b = Math.min(b, this.max), k || (j[0] = this.translate(a), j[1] = this.translate(b)), j = T(j, function (a) {
        h.test(a) && (a = B(a, 10) * e / 100);return a;
      }), c.shape === "circle" || !k ? (a = -Math.PI / 2, b = Math.PI * 1.5, f = !0) : (a = g + this.translate(a), b = g + this.translate(b)), j[0] -= l, j[2] -= l, d = this.chart.renderer.symbols.arc(this.left + d[0], this.top + d[1], j[0], j[0], { start: Math.min(a, b), end: Math.max(a, b), innerR: r(j[1], j[0] - j[2]), open: f }));return d;
    },
    getPlotLinePath: function getPlotLinePath(a, b) {
      var c = this,
          d = c.center,
          g = c.chart,
          e = c.getPosition(a),
          j,
          l,
          h;c.isCircular ? h = ["M", d[0] + g.plotLeft, d[1] + g.plotTop, "L", e.x, e.y] : c.options.gridLineInterpolation === "circle" ? (a = c.translate(a)) && (h = c.getLinePath(0, a)) : (t(g.xAxis, function (a) {
        a.pane === c.pane && (j = a);
      }), h = [], a = c.translate(a), d = j.tickPositions, j.autoConnect && (d = d.concat([d[0]])), b && (d = [].concat(d).reverse()), t(d, function (e, b) {
        l = j.getPosition(e, a);h.push(b ? "L" : "M", l.x, l.y);
      }));return h;
    }, getTitlePosition: function getTitlePosition() {
      var a = this.center,
          b = this.chart,
          c = this.options.title;return { x: b.plotLeft + a[0] + (c.x || 0), y: b.plotTop + a[1] - { high: 0.5, middle: 0.25, low: 0 }[c.align] * a[2] + (c.y || 0) };
    } };w(A, "init", function (a, b, c) {
    var k;var d = b.angular,
        g = b.polar,
        e = c.isX,
        j = d && e,
        l,
        h;h = b.options;var f = c.pane || 0;if (d) {
      if (H(this, j ? X : Q), l = !e) this.defaultRadialOptions = this.defaultRadialGaugeOptions;
    } else if (g) H(this, Q), this.defaultRadialOptions = (l = e) ? this.defaultRadialXOptions : u(this.defaultYAxisOptions, this.defaultRadialYOptions);if (d || g) b.inverted = !1, h.chart.zoomType = null;a.call(this, b, c);if (!j && (d || g)) {
      a = this.options;if (!b.panes) b.panes = [];this.pane = (k = b.panes[f] = b.panes[f] || new M(N(h.pane)[f], b, this), b = k);h = b.options;this.startAngleRad = b = (h.startAngle - 90) * Math.PI / 180;this.endAngleRad = h = (r(h.endAngle, h.startAngle + 360) - 90) * Math.PI / 180;this.offset = a.offset || 0;if ((this.isCircular = l) && c.max === void 0 && h - b === 2 * Math.PI) this.autoConnect = !0;
    }
  });w(A, "autoLabelAlign", function (a) {
    if (!this.isRadial) return a.apply(this, [].slice.call(arguments, 1));
  });w(z, "getPosition", function (a, b, c, d, g) {
    var e = this.axis;return e.getPosition ? e.getPosition(c) : a.call(this, b, c, d, g);
  });w(z, "getLabelPosition", function (a, b, c, d, g, e, j, l, h) {
    var f = this.axis,
        k = e.y,
        o = 20,
        s = e.align,
        i = (f.translate(this.pos) + f.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360;f.isRadial ? (a = f.getPosition(this.pos, f.center[2] / 2 + r(e.distance, -25)), e.rotation === "auto" ? d.attr({ rotation: i }) : k === null && (k = f.chart.renderer.fontMetrics(d.styles.fontSize).b - d.getBBox().height / 2), s === null && (f.isCircular ? (this.label.getBBox().width > f.len * f.tickInterval / (f.max - f.min) && (o = 0), s = i > o && i < 180 - o ? "left" : i > 180 + o && i < 360 - o ? "right" : "center") : s = "center", d.attr({ align: s })), a.x += e.x, a.y += k) : a = a.call(this, b, c, d, g, e, j, l, h);return a;
  });w(z, "getMarkPath", function (a, b, c, d, g, e, j) {
    var l = this.axis;l.isRadial ? (a = l.getPosition(this.pos, l.center[2] / 2 + d), b = ["M", b, c, "L", a.x, a.y]) : b = a.call(this, b, c, d, g, e, j);return b;
  });p.arearange = u(p.area, { lineWidth: 1, marker: null, threshold: null, tooltip: { pointFormat: "<span style=\"color:{series.color}\">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>" },
    trackByArea: !0, dataLabels: { align: null, verticalAlign: null, xLow: 0, xHigh: 0, yLow: 0, yHigh: 0 }, states: { hover: { halo: !1 } } });i.arearange = v(i.area, { type: "arearange", pointArrayMap: ["low", "high"], dataLabelCollections: ["dataLabel", "dataLabelUpper"], toYData: function toYData(a) {
      return [a.low, a.high];
    }, pointValKey: "low", deferTranslatePolar: !0, highToXY: function highToXY(a) {
      var b = this.chart,
          c = this.xAxis.postTranslate(a.rectPlotX, this.yAxis.len - a.plotHigh);a.plotHighX = c.x - b.plotLeft;a.plotHigh = c.y - b.plotTop;
    }, translate: function translate() {
      var a = this,
          b = a.yAxis;i.area.prototype.translate.apply(a);t(a.points, function (a) {
        var d = a.low,
            g = a.high,
            e = a.plotY;g === null || d === null ? a.isNull = !0 : (a.plotLow = e, a.plotHigh = b.translate(g, 0, 1, 0, 1));
      });this.chart.polar && t(this.points, function (b) {
        a.highToXY(b);
      });
    }, getGraphPath: function getGraphPath() {
      var a = this.points,
          b = [],
          c = [],
          d = a.length,
          g = x.prototype.getGraphPath,
          e,
          j,
          l;l = this.options;for (var h = l.step, d = a.length; d--;) {
        e = a[d], !e.isNull && (!a[d + 1] || a[d + 1].isNull) && c.push({ plotX: e.plotX, plotY: e.plotLow }), j = { plotX: e.plotX, plotY: e.plotHigh,
          isNull: e.isNull }, c.push(j), b.push(j), !e.isNull && (!a[d - 1] || a[d - 1].isNull) && c.push({ plotX: e.plotX, plotY: e.plotLow });
      }a = g.call(this, a);if (h) h === !0 && (h = "left"), l.step = { left: "right", center: "center", right: "left" }[h];b = g.call(this, b);c = g.call(this, c);l.step = h;l = [].concat(a, b);!this.chart.polar && c[0] === "M" && (c[0] = "L");this.graphPath = l;this.areaPath = this.areaPath.concat(a, c);l.isArea = !0;l.xMap = a.xMap;this.areaPath.xMap = a.xMap;return l;
    }, drawDataLabels: function drawDataLabels() {
      var a = this.data,
          b = a.length,
          c,
          d = [],
          g = x.prototype,
          e = this.options.dataLabels,
          j = e.align,
          l = e.verticalAlign,
          h = e.inside,
          f,
          k,
          o = this.chart.inverted;if (e.enabled || this._hasPointLabels) {
        for (c = b; c--;) {
          if (f = a[c]) {
            k = h ? f.plotHigh < f.plotLow : f.plotHigh > f.plotLow;f.y = f.high;f._plotY = f.plotY;f.plotY = f.plotHigh;d[c] = f.dataLabel;f.dataLabel = f.dataLabelUpper;f.below = k;if (o) {
              if (!j) e.align = k ? "right" : "left";
            } else if (!l) e.verticalAlign = k ? "top" : "bottom";e.x = e.xHigh;e.y = e.yHigh;
          }
        }g.drawDataLabels && g.drawDataLabels.apply(this, arguments);for (c = b; c--;) {
          if (f = a[c]) {
            k = h ? f.plotHigh < f.plotLow : f.plotHigh > f.plotLow;f.dataLabelUpper = f.dataLabel;f.dataLabel = d[c];f.y = f.low;f.plotY = f._plotY;f.below = !k;if (o) {
              if (!j) e.align = k ? "left" : "right";
            } else if (!l) e.verticalAlign = k ? "bottom" : "top";e.x = e.xLow;e.y = e.yLow;
          }
        }g.drawDataLabels && g.drawDataLabels.apply(this, arguments);
      }e.align = j;e.verticalAlign = l;
    }, alignDataLabel: function alignDataLabel() {
      i.column.prototype.alignDataLabel.apply(this, arguments);
    }, setStackedPoints: n, getSymbol: n, drawPoints: n });p.areasplinerange = u(p.arearange);i.areasplinerange = v(i.arearange, { type: "areasplinerange",
    getPointSpline: i.spline.prototype.getPointSpline });(function () {
    var a = i.column.prototype;p.columnrange = u(p.column, p.arearange, { lineWidth: 1, pointRange: null });i.columnrange = v(i.arearange, { type: "columnrange", translate: function translate() {
        var b = this,
            c = b.yAxis,
            d = b.xAxis,
            g = d.startAngleRad,
            e,
            j = b.chart,
            l = b.xAxis.isRadial,
            h;a.translate.apply(b);t(b.points, function (a) {
          var k = a.shapeArgs,
              o = b.options.minPointLength,
              s,
              i;a.plotHigh = h = c.translate(a.high, 0, 1, 0, 1);a.plotLow = a.plotY;i = h;s = r(a.rectPlotY, a.plotY) - h;Math.abs(s) < o ? (o -= s, s += o, i -= o / 2) : s < 0 && (s *= -1, i -= s);l ? (e = a.barX + g, a.shapeType = "path", a.shapeArgs = { d: b.polarArc(i + s, i, e, e + a.pointWidth) }) : (k.height = s, k.y = i, a.tooltipPos = j.inverted ? [c.len + c.pos - j.plotLeft - i - s / 2, d.len + d.pos - j.plotTop - k.x - k.width / 2, s] : [d.left - j.plotLeft + k.x + k.width / 2, c.pos - j.plotTop + i + s / 2, s]);
        });
      }, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], drawGraph: n, crispCol: a.crispCol, pointAttrToOptions: a.pointAttrToOptions, drawPoints: a.drawPoints, drawTracker: a.drawTracker, getColumnMetrics: a.getColumnMetrics,
      animate: function animate() {
        return a.animate.apply(this, arguments);
      }, polarArc: function polarArc() {
        return a.polarArc.apply(this, arguments);
      } });
  })();p.gauge = u(p.line, { dataLabels: { enabled: !0, defer: !1, y: 15, borderWidth: 1, borderColor: "silver", borderRadius: 3, crop: !1, verticalAlign: "top", zIndex: 2 }, dial: {}, pivot: {}, tooltip: { headerFormat: "" }, showInLegend: !1 });C = { type: "gauge", pointClass: v(J, { setState: function setState(a) {
        this.state = a;
      } }), angular: !0, directTouch: !0, drawGraph: n, fixedBox: !0, forceDL: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], translate: function translate() {
      var a = this.yAxis,
          b = this.options,
          c = a.center;this.generatePoints();t(this.points, function (d) {
        var g = u(b.dial, d.dial),
            e = B(r(g.radius, 80)) * c[2] / 200,
            j = B(r(g.baseLength, 70)) * e / 100,
            l = B(r(g.rearLength, 10)) * e / 100,
            h = g.baseWidth || 3,
            f = g.topWidth || 1,
            k = b.overshoot,
            o = a.startAngleRad + a.translate(d.y, null, null, null, !0);I(k) ? (k = k / 180 * Math.PI, o = Math.max(a.startAngleRad - k, Math.min(a.endAngleRad + k, o))) : b.wrap === !1 && (o = Math.max(a.startAngleRad, Math.min(a.endAngleRad, o)));o = o * 180 / Math.PI;d.shapeType = "path";d.shapeArgs = { d: g.path || ["M", -l, -h / 2, "L", j, -h / 2, e, -f / 2, e, f / 2, j, h / 2, -l, h / 2, "z"], translateX: c[0], translateY: c[1], rotation: o };d.plotX = c[0];d.plotY = c[1];
      });
    }, drawPoints: function drawPoints() {
      var a = this,
          b = a.yAxis.center,
          c = a.pivot,
          d = a.options,
          g = d.pivot,
          e = a.chart.renderer;t(a.points, function (b) {
        var g = b.graphic,
            c = b.shapeArgs,
            f = c.d,
            k = u(d.dial, b.dial);g ? (g.animate(c), c.d = f) : b.graphic = e[b.shapeType](c).attr({ stroke: k.borderColor || "none", "stroke-width": k.borderWidth || 0, fill: k.backgroundColor || "black",
          rotation: c.rotation, zIndex: 1 }).add(a.group);
      });c ? c.animate({ translateX: b[0], translateY: b[1] }) : a.pivot = e.circle(0, 0, r(g.radius, 5)).attr({ "stroke-width": g.borderWidth || 0, stroke: g.borderColor || "silver", fill: g.backgroundColor || "black", zIndex: 2 }).translate(b[0], b[1]).add(a.group);
    }, animate: function animate(a) {
      var b = this;if (!a) t(b.points, function (a) {
        var d = a.graphic;d && (d.attr({ rotation: b.yAxis.startAngleRad * 180 / Math.PI }), d.animate({ rotation: a.shapeArgs.rotation }, b.options.animation));
      }), b.animate = null;
    }, render: function render() {
      this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup);x.prototype.render.call(this);this.group.clip(this.chart.clipRect);
    }, setData: function setData(a, b) {
      x.prototype.setData.call(this, a, !1);this.processData();this.generatePoints();r(b, !0) && this.chart.redraw();
    }, drawTracker: C && C.drawTrackerPoint };i.gauge = v(i.line, C);p.boxplot = u(p.column, { fillColor: "#FFFFFF", lineWidth: 1, medianWidth: 2, states: { hover: { brightness: -0.3 } }, threshold: null, tooltip: { pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>" },
    whiskerLength: "50%", whiskerWidth: 2 });i.boxplot = v(i.column, { type: "boxplot", pointArrayMap: ["low", "q1", "median", "q3", "high"], toYData: function toYData(a) {
      return [a.low, a.q1, a.median, a.q3, a.high];
    }, pointValKey: "high", pointAttrToOptions: { fill: "fillColor", stroke: "color", "stroke-width": "lineWidth" }, drawDataLabels: n, translate: function translate() {
      var a = this.yAxis,
          b = this.pointArrayMap;i.column.prototype.translate.apply(this);t(this.points, function (c) {
        t(b, function (b) {
          c[b] !== null && (c[b + "Plot"] = a.translate(c[b], 0, 1, 0, 1));
        });
      });
    }, drawPoints: function drawPoints() {
      var a = this,
          b = a.options,
          c = a.chart.renderer,
          d,
          g,
          e,
          j,
          l,
          h,
          f,
          k,
          o,
          i,
          m,
          K,
          L,
          p,
          u,
          n,
          w,
          v,
          x,
          y,
          C,
          B,
          z = a.doQuartiles !== !1,
          A,
          E = a.options.whiskerLength;t(a.points, function (q) {
        o = q.graphic;C = q.shapeArgs;m = {};p = {};n = {};B = q.color || a.color;if (q.plotY !== void 0) if (d = q.pointAttr[q.selected ? "selected" : ""], w = C.width, v = D(C.x), x = v + w, y = F(w / 2), g = D(z ? q.q1Plot : q.lowPlot), e = D(z ? q.q3Plot : q.lowPlot), j = D(q.highPlot), l = D(q.lowPlot), m.stroke = q.stemColor || b.stemColor || B, m["stroke-width"] = r(q.stemWidth, b.stemWidth, b.lineWidth), m.dashstyle = q.stemDashStyle || b.stemDashStyle, p.stroke = q.whiskerColor || b.whiskerColor || B, p["stroke-width"] = r(q.whiskerWidth, b.whiskerWidth, b.lineWidth), n.stroke = q.medianColor || b.medianColor || B, n["stroke-width"] = r(q.medianWidth, b.medianWidth, b.lineWidth), f = m["stroke-width"] % 2 / 2, k = v + y + f, i = ["M", k, e, "L", k, j, "M", k, g, "L", k, l], z && (f = d["stroke-width"] % 2 / 2, k = D(k) + f, g = D(g) + f, e = D(e) + f, v += f, x += f, K = ["M", v, e, "L", v, g, "L", x, g, "L", x, e, "L", v, e, "z"]), E && (f = p["stroke-width"] % 2 / 2, j += f, l += f, A = /%$/.test(E) ? y * parseFloat(E) / 100 : E / 2, L = ["M", k - A, j, "L", k + A, j, "M", k - A, l, "L", k + A, l]), f = n["stroke-width"] % 2 / 2, h = F(q.medianPlot) + f, u = ["M", v, h, "L", x, h], o) q.stem.animate({ d: i }), E && q.whiskers.animate({ d: L }), z && q.box.animate({ d: K }), q.medianShape.animate({ d: u });else {
          q.graphic = o = c.g().add(a.group);q.stem = c.path(i).attr(m).add(o);if (E) q.whiskers = c.path(L).attr(p).add(o);if (z) q.box = c.path(K).attr(d).add(o);q.medianShape = c.path(u).attr(n).add(o);
        }
      });
    }, setStackedPoints: n });p.errorbar = u(p.boxplot, { color: "#000000", grouping: !1, linkedTo: ":previous", tooltip: { pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>" },
    whiskerWidth: null });i.errorbar = v(i.boxplot, { type: "errorbar", pointArrayMap: ["low", "high"], toYData: function toYData(a) {
      return [a.low, a.high];
    }, pointValKey: "high", doQuartiles: !1, drawDataLabels: i.arearange ? i.arearange.prototype.drawDataLabels : n, getColumnMetrics: function getColumnMetrics() {
      return this.linkedParent && this.linkedParent.columnMetrics || i.column.prototype.getColumnMetrics.call(this);
    } });p.waterfall = u(p.column, { lineWidth: 1, lineColor: "#333", dashStyle: "dot", borderColor: "#333", dataLabels: { inside: !0 }, states: { hover: { lineWidthPlus: 0 } } });
  i.waterfall = v(i.column, { type: "waterfall", upColorProp: "fill", pointValKey: "y", translate: function translate() {
      var a = this.options,
          b = this.yAxis,
          c,
          d,
          g,
          e,
          j,
          l,
          h,
          f,
          k,
          o = r(a.minPointLength, 5),
          s = a.threshold,
          m = a.stacking;i.column.prototype.translate.apply(this);this.minPointLengthOffset = 0;h = f = s;d = this.points;for (c = 0, a = d.length; c < a; c++) {
        g = d[c];l = this.processedYData[c];e = g.shapeArgs;k = (j = m && b.stacks[(this.negStacks && l < s ? "-" : "") + this.stackKey]) ? j[g.x].points[this.index + "," + c] : [0, l];if (g.isSum) g.y = G(l);else if (g.isIntermediateSum) g.y = G(l - f);j = P(h, h + g.y) + k[0];e.y = b.translate(j, 0, 1);if (g.isSum) e.y = b.translate(k[1], 0, 1), e.height = Math.min(b.translate(k[0], 0, 1), b.len) - e.y + this.minPointLengthOffset;else if (g.isIntermediateSum) e.y = b.translate(k[1], 0, 1), e.height = Math.min(b.translate(f, 0, 1), b.len) - e.y + this.minPointLengthOffset, f = k[1];else {
          if (h !== 0) e.height = l > 0 ? b.translate(h, 0, 1) - e.y : b.translate(h, 0, 1) - b.translate(h - l, 0, 1);h += l;
        }e.height < 0 && (e.y += e.height, e.height *= -1);g.plotY = e.y = F(e.y) - this.borderWidth % 2 / 2;e.height = P(F(e.height), 0.001);
        g.yBottom = e.y + e.height;if (e.height <= o) e.height = o, this.minPointLengthOffset += o;e.y -= this.minPointLengthOffset;e = g.plotY + (g.negative ? e.height : 0) - this.minPointLengthOffset;this.chart.inverted ? g.tooltipPos[0] = b.len - e : g.tooltipPos[1] = e;
      }
    }, processData: function processData(a) {
      var b = this.yData,
          c = this.options.data,
          d,
          g = b.length,
          e,
          j,
          l,
          h,
          f,
          k;j = e = l = h = this.options.threshold || 0;for (k = 0; k < g; k++) {
        f = b[k], d = c && c[k] ? c[k] : {}, f === "sum" || d.isSum ? b[k] = G(j) : f === "intermediateSum" || d.isIntermediateSum ? b[k] = G(e) : (j += f, e += f), l = Math.min(j, l), h = Math.max(j, h);
      }x.prototype.processData.call(this, a);this.dataMin = l;this.dataMax = h;
    }, toYData: function toYData(a) {
      return a.isSum ? a.x === 0 ? null : "sum" : a.isIntermediateSum ? a.x === 0 ? null : "intermediateSum" : a.y;
    }, getAttribs: function getAttribs() {
      i.column.prototype.getAttribs.apply(this, arguments);var a = this,
          b = a.options,
          c = b.states,
          d = b.upColor || a.color,
          b = m.Color(d).brighten(b.states.hover.brightness).get(),
          g = u(a.pointAttr),
          e = a.upColorProp;g[""][e] = d;g.hover[e] = c.hover.upColor || b;g.select[e] = c.select.upColor || d;t(a.points, function (b) {
        if (!b.options.color) b.y > 0 ? (b.pointAttr = g, b.color = d) : b.pointAttr = a.pointAttr;
      });
    }, getGraphPath: function getGraphPath() {
      var a = this.data,
          b = a.length,
          c = F(this.options.lineWidth + this.borderWidth) % 2 / 2,
          d = [],
          g,
          e,
          j;for (j = 1; j < b; j++) {
        e = a[j].shapeArgs, g = a[j - 1].shapeArgs, e = ["M", g.x + g.width, g.y + c, "L", e.x, g.y + c], a[j - 1].y < 0 && (e[2] += g.height, e[5] += g.height), d = d.concat(e);
      }return d;
    }, getExtremes: n, drawGraph: x.prototype.drawGraph });p.polygon = u(p.scatter, { marker: { enabled: !1, states: { hover: { enabled: !1 } } }, stickyTracking: !1, tooltip: { followPointer: !0, pointFormat: "" },
    trackByArea: !0 });i.polygon = v(i.scatter, { type: "polygon", getGraphPath: function getGraphPath() {
      for (var a = x.prototype.getGraphPath.call(this), b = a.length + 1; b--;) {
        (b === a.length || a[b] === "M" && b > 0) && a.splice(b, 0, "z");
      }return this.areaPath = a;
    }, drawGraph: function drawGraph() {
      this.options.fillColor = this.color;i.area.prototype.drawGraph.call(this);
    }, drawLegendSymbol: m.LegendSymbolMixin.drawRectangle, drawTracker: x.prototype.drawTracker, setStackedPoints: n });p.bubble = u(p.scatter, { dataLabels: { formatter: function formatter() {
        return this.point.z;
      }, inside: !0,
      verticalAlign: "middle" }, marker: { lineColor: null, lineWidth: 1 }, minSize: 8, maxSize: "20%", softThreshold: !1, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z" });C = v(J, { haloPath: function haloPath() {
      return J.prototype.haloPath.call(this, this.shapeArgs.r + this.series.options.states.hover.halo.size);
    }, ttBelow: !1 });i.bubble = v(i.scatter, { type: "bubble", pointClass: C, pointArrayMap: ["y", "z"], parallelArrays: ["x", "y", "z"], trackerGroups: ["group", "dataLabelsGroup"], bubblePadding: !0, zoneAxis: "z", pointAttrToOptions: { stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor" }, applyOpacity: function applyOpacity(a) {
      var b = this.options.marker,
          c = r(b.fillOpacity, 0.5),
          a = a || b.fillColor || this.color;c !== 1 && (a = W(a).setOpacity(c).get("rgba"));return a;
    }, convertAttribs: function convertAttribs() {
      var a = x.prototype.convertAttribs.apply(this, arguments);a.fill = this.applyOpacity(a.fill);return a;
    }, getRadii: function getRadii(a, b, c, d) {
      var g,
          e,
          j,
          l = this.zData,
          h = [],
          f = this.options,
          k = f.sizeBy !== "width",
          o = f.zThreshold,
          i = b - a;for (e = 0, g = l.length; e < g; e++) {
        j = l[e], f.sizeByAbsoluteValue && j !== null && (j = Math.abs(j - o), b = Math.max(b - o, Math.abs(a - o)), a = 0), j === null ? j = null : j < a ? j = c / 2 - 1 : (j = i > 0 ? (j - a) / i : 0.5, k && j >= 0 && (j = Math.sqrt(j)), j = y.ceil(c + j * (d - c)) / 2), h.push(j);
      }this.radii = h;
    }, animate: function animate(a) {
      var b = this.options.animation;if (!a) t(this.points, function (a) {
        var d = a.graphic,
            a = a.shapeArgs;d && a && (d.attr("r", 1), d.animate({ r: a.r }, b));
      }), this.animate = null;
    }, translate: function translate() {
      var a,
          b = this.data,
          c,
          d,
          g = this.radii;i.scatter.prototype.translate.call(this);
      for (a = b.length; a--;) {
        c = b[a], d = g ? g[a] : 0, I(d) && d >= this.minPxSize / 2 ? (c.shapeType = "circle", c.shapeArgs = { x: c.plotX, y: c.plotY, r: d }, c.dlBox = { x: c.plotX - d, y: c.plotY - d, width: 2 * d, height: 2 * d }) : c.shapeArgs = c.plotY = c.dlBox = void 0;
      }
    }, drawLegendSymbol: function drawLegendSymbol(a, b) {
      var c = this.chart.renderer,
          d = c.fontMetrics(a.itemStyle.fontSize).f / 2;b.legendSymbol = c.circle(d, a.baseline - d, d).attr({ zIndex: 3 }).add(b.legendGroup);b.legendSymbol.isMarker = !0;
    }, drawPoints: i.column.prototype.drawPoints, alignDataLabel: i.column.prototype.alignDataLabel,
    buildKDTree: n, applyZones: n });O.prototype.beforePadding = function () {
    var a = this,
        b = this.len,
        c = this.chart,
        d = 0,
        g = b,
        e = this.isXAxis,
        j = e ? "xData" : "yData",
        l = this.min,
        h = {},
        f = y.min(c.plotWidth, c.plotHeight),
        k = Number.MAX_VALUE,
        i = -Number.MAX_VALUE,
        m = this.max - l,
        p = b / m,
        n = [];t(this.series, function (b) {
      var g = b.options;if (b.bubblePadding && (b.visible || !c.options.chart.ignoreHiddenSeries)) if (a.allowZoomOutside = !0, n.push(b), e) t(["minSize", "maxSize"], function (a) {
        var b = g[a],
            e = /%$/.test(b),
            b = B(b);h[a] = e ? f * b / 100 : b;
      }), b.minPxSize = h.minSize, b.maxPxSize = h.maxSize, b = b.zData, b.length && (k = r(g.zMin, y.min(k, y.max(R(b), g.displayNegative === !1 ? g.zThreshold : -Number.MAX_VALUE))), i = r(g.zMax, y.max(i, S(b))));
    });t(n, function (b) {
      var c = b[j],
          f = c.length,
          h;e && b.getRadii(k, i, b.minPxSize, b.maxPxSize);if (m > 0) for (; f--;) {
        I(c[f]) && a.dataMin <= c[f] && c[f] <= a.dataMax && (h = b.radii[f], d = Math.min((c[f] - l) * p - h, d), g = Math.max((c[f] - l) * p + h, g));
      }
    });n.length && m > 0 && !this.isLog && (g -= b, p *= (b + d - g) / b, t([["min", "userMin", d], ["max", "userMax", g]], function (b) {
      r(a.options[b[0]], a[b[1]]) === void 0 && (a[b[0]] += b[2] / p);
    }));
  };(function () {
    function a(a, b) {
      var c = this.chart,
          d = this.options.animation,
          h = this.group,
          f = this.markerGroup,
          k = this.xAxis.center,
          i = c.plotLeft,
          m = c.plotTop;if (c.polar) {
        if (c.renderer.isSVG) d === !0 && (d = {}), b ? (c = { translateX: k[0] + i, translateY: k[1] + m, scaleX: 0.001, scaleY: 0.001 }, h.attr(c), f && f.attr(c)) : (c = { translateX: i, translateY: m, scaleX: 1, scaleY: 1 }, h.animate(c, d), f && f.animate(c, d), this.animate = null);
      } else a.call(this, b);
    }var b = x.prototype,
        c = U.prototype,
        d;b.searchPointByAngle = function (a) {
      var b = this.chart,
          c = this.xAxis.pane.center;return this.searchKDTree({ clientX: 180 + Math.atan2(a.chartX - c[0] - b.plotLeft, a.chartY - c[1] - b.plotTop) * (-180 / Math.PI) });
    };w(b, "buildKDTree", function (a) {
      if (this.chart.polar) this.kdByAngle ? this.searchPoint = this.searchPointByAngle : this.kdDimensions = 2;a.apply(this);
    });b.toXY = function (a) {
      var b,
          c = this.chart,
          d = a.plotX;b = a.plotY;a.rectPlotX = d;a.rectPlotY = b;b = this.xAxis.postTranslate(a.plotX, this.yAxis.len - b);a.plotX = a.polarPlotX = b.x - c.plotLeft;a.plotY = a.polarPlotY = b.y - c.plotTop;this.kdByAngle ? (c = (d / Math.PI * 180 + this.xAxis.pane.options.startAngle) % 360, c < 0 && (c += 360), a.clientX = c) : a.clientX = a.plotX;
    };i.spline && w(i.spline.prototype, "getPointSpline", function (a, b, c, d) {
      var h, f, k, i, m, p, n;if (this.chart.polar) {
        h = c.plotX;f = c.plotY;a = b[d - 1];k = b[d + 1];this.connectEnds && (a || (a = b[b.length - 2]), k || (k = b[1]));if (a && k) i = a.plotX, m = a.plotY, b = k.plotX, p = k.plotY, i = (1.5 * h + i) / 2.5, m = (1.5 * f + m) / 2.5, k = (1.5 * h + b) / 2.5, n = (1.5 * f + p) / 2.5, b = Math.sqrt(Math.pow(i - h, 2) + Math.pow(m - f, 2)), p = Math.sqrt(Math.pow(k - h, 2) + Math.pow(n - f, 2)), i = Math.atan2(m - f, i - h), m = Math.atan2(n - f, k - h), n = Math.PI / 2 + (i + m) / 2, Math.abs(i - n) > Math.PI / 2 && (n -= Math.PI), i = h + Math.cos(n) * b, m = f + Math.sin(n) * b, k = h + Math.cos(Math.PI + n) * p, n = f + Math.sin(Math.PI + n) * p, c.rightContX = k, c.rightContY = n;d ? (c = ["C", a.rightContX || a.plotX, a.rightContY || a.plotY, i || h, m || f, h, f], a.rightContX = a.rightContY = null) : c = ["M", h, f];
      } else c = a.call(this, b, c, d);return c;
    });w(b, "translate", function (a) {
      var b = this.chart;a.call(this);if (b.polar && (this.kdByAngle = b.tooltip && b.tooltip.shared, !this.preventPostTranslate)) {
        a = this.points;for (b = a.length; b--;) {
          this.toXY(a[b]);
        }
      }
    });w(b, "getGraphPath", function (a, b) {
      var c = this,
          d,
          h;if (this.chart.polar) {
        b = b || this.points;for (d = 0; d < b.length; d++) {
          if (!b[d].isNull) {
            h = d;break;
          }
        }if (this.options.connectEnds !== !1 && h !== void 0) this.connectEnds = !0, b.splice(b.length, 0, b[h]);t(b, function (a) {
          a.polarPlotY === void 0 && c.toXY(a);
        });
      }return a.apply(this, [].slice.call(arguments, 1));
    });w(b, "animate", a);if (i.column) d = i.column.prototype, d.polarArc = function (a, b, c, d) {
      var h = this.xAxis.center,
          f = this.yAxis.len;return this.chart.renderer.symbols.arc(h[0], h[1], f - b, null, { start: c, end: d, innerR: f - r(a, f) });
    }, w(d, "animate", a), w(d, "translate", function (a) {
      var b = this.xAxis,
          c = b.startAngleRad,
          d,
          h,
          f;this.preventPostTranslate = !0;a.call(this);if (b.isRadial) {
        d = this.points;for (f = d.length; f--;) {
          h = d[f], a = h.barX + c, h.shapeType = "path", h.shapeArgs = { d: this.polarArc(h.yBottom, h.plotY, a, a + h.pointWidth) }, this.toXY(h), h.tooltipPos = [h.plotX, h.plotY], h.ttBelow = h.plotY > b.center[1];
        }
      }
    }), w(d, "alignDataLabel", function (a, c, d, i, h, f) {
      if (this.chart.polar) {
        a = c.rectPlotX / Math.PI * 180;if (i.align === null) i.align = a > 20 && a < 160 ? "left" : a > 200 && a < 340 ? "right" : "center";if (i.verticalAlign === null) i.verticalAlign = a < 45 || a > 315 ? "bottom" : a > 135 && a < 225 ? "top" : "middle";b.alignDataLabel.call(this, c, d, i, h, f);
      } else a.call(this, c, d, i, h, f);
    });w(c, "getCoordinates", function (a, b) {
      var c = this.chart,
          d = { xAxis: [], yAxis: [] };c.polar ? t(c.axes, function (a) {
        var f = a.isXAxis,
            g = a.center,
            i = b.chartX - g[0] - c.plotLeft,
            g = b.chartY - g[1] - c.plotTop;d[f ? "xAxis" : "yAxis"].push({ axis: a,
          value: a.translate(f ? Math.PI - Math.atan2(i, g) : Math.sqrt(Math.pow(i, 2) + Math.pow(g, 2)), !0) });
      }) : d = a.call(this, b);return d;
    });
  })();
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highcharts JS v4.2.6 (2016-08-02)

 3D features for Highcharts JS

 @license: www.highcharts.com/license
*/
(function (d) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = d : d(Highcharts);
})(function (d) {
  function C(c) {
    return c !== void 0 && c !== null;
  }function H(c) {
    var b = 0,
        a,
        f;for (a = 0; a < c.length; a++) {
      f = (a + 1) % c.length, b += c[a].x * c[f].y - c[f].x * c[a].y;
    }return b / 2;
  }function D(c) {
    var b = 0,
        a;for (a = 0; a < c.length; a++) {
      b += c[a].z;
    }return c.length ? b / c.length : 0;
  }function u(c, b, a, f, e, g, d, j) {
    var k = [];g > e && g - e > p / 2 + 1.0E-4 ? (k = k.concat(u(c, b, a, f, e, e + p / 2, d, j)), k = k.concat(u(c, b, a, f, e + p / 2, g, d, j))) : g < e && e - g > p / 2 + 1.0E-4 ? (k = k.concat(u(c, b, a, f, e, e - p / 2, d, j)), k = k.concat(u(c, b, a, f, e - p / 2, g, d, j))) : (k = g - e, k = ["C", c + a * l(e) - a * E * k * q(e) + d, b + f * q(e) + f * E * k * l(e) + j, c + a * l(g) + a * E * k * q(g) + d, b + f * q(g) - f * E * k * l(g) + j, c + a * l(g) + d, b + f * q(g) + j]);return k;
  }function L(c, b) {
    var a = c.plotLeft,
        f = c.plotWidth + a,
        e = c.plotTop,
        g = c.plotHeight + e,
        d = a + c.plotWidth / 2,
        j = e + c.plotHeight / 2,
        k = Number.MAX_VALUE,
        h = -Number.MAX_VALUE,
        m = Number.MAX_VALUE,
        t = -Number.MAX_VALUE,
        o,
        l = 1;o = [{ x: a, y: e, z: 0 }, { x: a, y: e, z: b }];r([0, 1], function (a) {
      o.push({ x: f, y: o[a].y, z: o[a].z });
    });r([0, 1, 2, 3], function (a) {
      o.push({ x: o[a].x,
        y: g, z: o[a].z });
    });o = s(o, c, !1);r(o, function (a) {
      k = Math.min(k, a.x);h = Math.max(h, a.x);m = Math.min(m, a.y);t = Math.max(t, a.y);
    });a > k && (l = Math.min(l, 1 - Math.abs((a + d) / (k + d)) % 1));f < h && (l = Math.min(l, (f - d) / (h - d)));e > m && (l = m < 0 ? Math.min(l, (e + j) / (-m + e + j)) : Math.min(l, 1 - (e + j) / (m + j) % 1));g < t && (l = Math.min(l, Math.abs((g - j) / (t - j))));return l;
  }function I(c) {
    if (this.chart.is3d()) {
      var b = this.chart.options.plotOptions.column.grouping;if (b !== void 0 && !b && this.group.zIndex !== void 0 && !this.zIndexSet) this.group.attr({ zIndex: this.group.zIndex * 10 }), this.zIndexSet = !0;var a = this.options,
          f = this.options.states;this.borderWidth = a.borderWidth = C(a.edgeWidth) ? a.edgeWidth : 1;d.each(this.data, function (b) {
        if (b.y !== null) b = b.pointAttr, this.borderColor = d.pick(a.edgeColor, b[""].fill), b[""].stroke = this.borderColor, b.hover.stroke = d.pick(f.hover.edgeColor, this.borderColor), b.select.stroke = d.pick(f.select.edgeColor, this.borderColor);
      });
    }c.apply(this, [].slice.call(arguments, 1));
  }var M = d.animObject,
      r = d.each,
      N = d.extend,
      O = d.inArray,
      F = d.merge,
      A = d.pick,
      J = d.wrap,
      p = Math.PI,
      B = p / 180,
      q = Math.sin,
      l = Math.cos,
      K = Math.round,
      s = d.perspective = function (c, b, a) {
    var f = b.options.chart.options3d,
        e = a ? b.inverted : !1,
        g = b.plotWidth / 2,
        i = b.plotHeight / 2,
        j = f.depth / 2,
        k = A(f.depth, 1) * A(f.viewDistance, 0),
        h = b.scale3d || 1,
        m = B * f.beta * (e ? -1 : 1),
        f = B * f.alpha * (e ? -1 : 1),
        t = l(f),
        o = l(-m),
        p = q(f),
        n = q(-m);a || (g += b.plotLeft, i += b.plotTop);return d.map(c, function (a) {
      var b;b = -p * n * ((e ? a.y : a.x) - g) + t * ((e ? a.x : a.y) - i) - o * p * ((a.z || 0) - j);var c = t * n * ((e ? a.y : a.x) - g) + p * ((e ? a.x : a.y) - i) + t * o * ((a.z || 0) - j),
          f = k > 0 && k < Number.POSITIVE_INFINITY ? k / (c + j + k) : 1;a = (o * ((e ? a.y : a.x) - g) - n * ((a.z || 0) - j)) * f;b *= f;a = a * h + g;b = b * h + i;return { x: e ? b : a, y: e ? a : b, z: c * h + j };
    });
  },
      E = 4 * (Math.sqrt(2) - 1) / 3 / (p / 2);d.SVGRenderer.prototype.toLinePath = function (c, b) {
    var a = [];d.each(c, function (b) {
      a.push("L", b.x, b.y);
    });c.length && (a[0] = "M", b && a.push("Z"));return a;
  };d.SVGRenderer.prototype.cuboid = function (c) {
    var b = this.g(),
        c = this.cuboidPath(c);b.front = this.path(c[0]).attr({ zIndex: c[3], "stroke-linejoin": "round" }).add(b);b.top = this.path(c[1]).attr({ zIndex: c[4], "stroke-linejoin": "round" }).add(b);
    b.side = this.path(c[2]).attr({ zIndex: c[5], "stroke-linejoin": "round" }).add(b);b.fillSetter = function (a) {
      var b = d.Color(a).brighten(0.1).get(),
          c = d.Color(a).brighten(-0.1).get();this.front.attr({ fill: a });this.top.attr({ fill: b });this.side.attr({ fill: c });this.color = a;return this;
    };b.opacitySetter = function (a) {
      this.front.attr({ opacity: a });this.top.attr({ opacity: a });this.side.attr({ opacity: a });return this;
    };b.attr = function (a) {
      if (a.shapeArgs || C(a.x)) a = this.renderer.cuboidPath(a.shapeArgs || a), this.front.attr({ d: a[0],
        zIndex: a[3] }), this.top.attr({ d: a[1], zIndex: a[4] }), this.side.attr({ d: a[2], zIndex: a[5] });else return d.SVGElement.prototype.attr.call(this, a);return this;
    };b.animate = function (a, b, c) {
      C(a.x) && C(a.y) ? (a = this.renderer.cuboidPath(a), this.front.attr({ zIndex: a[3] }).animate({ d: a[0] }, b, c), this.top.attr({ zIndex: a[4] }).animate({ d: a[1] }, b, c), this.side.attr({ zIndex: a[5] }).animate({ d: a[2] }, b, c), this.attr({ zIndex: -a[6] })) : a.opacity ? (this.front.animate(a, b, c), this.top.animate(a, b, c), this.side.animate(a, b, c)) : d.SVGElement.prototype.animate.call(this, a, b, c);return this;
    };b.destroy = function () {
      this.front.destroy();this.top.destroy();this.side.destroy();return null;
    };b.attr({ zIndex: -c[6] });return b;
  };d.SVGRenderer.prototype.cuboidPath = function (c) {
    function b(a) {
      return h[a];
    }var a = c.x,
        f = c.y,
        e = c.z,
        g = c.height,
        i = c.width,
        j = c.depth,
        k = d.map,
        h = [{ x: a, y: f, z: e }, { x: a + i, y: f, z: e }, { x: a + i, y: f + g, z: e }, { x: a, y: f + g, z: e }, { x: a, y: f + g, z: e + j }, { x: a + i, y: f + g, z: e + j }, { x: a + i, y: f, z: e + j }, { x: a, y: f, z: e + j }],
        h = s(h, d.charts[this.chartIndex], c.insidePlotArea),
        e = function e(a, c) {
      var f = [],
          a = k(a, b),
          c = k(c, b);H(a) < 0 ? f = a : H(c) < 0 && (f = c);return f;
    },
        c = e([3, 2, 1, 0], [7, 6, 5, 4]),
        a = [4, 5, 2, 3],
        f = e([1, 6, 7, 0], a),
        e = e([1, 2, 5, 6], [0, 7, 4, 3]);return [this.toLinePath(c, !0), this.toLinePath(f, !0), this.toLinePath(e, !0), D(c), D(f), D(e), D(k(a, b)) * 9E9];
  };d.SVGRenderer.prototype.arc3d = function (c) {
    function b(a) {
      var b = !1,
          c = {},
          f;for (f in a) {
        O(f, e) !== -1 && (c[f] = a[f], delete a[f], b = !0);
      }return b ? c : !1;
    }var a = this.g(),
        f = a.renderer,
        e = "x,y,r,innerR,start,end".split(","),
        c = F(c);c.alpha *= B;c.beta *= B;a.top = f.path();a.side1 = f.path();a.side2 = f.path();a.inn = f.path();a.out = f.path();a.onAdd = function () {
      var b = a.parentGroup;a.top.add(a);a.out.add(b);a.inn.add(b);a.side1.add(b);a.side2.add(b);
    };a.setPaths = function (b) {
      var c = a.renderer.arc3dPath(b),
          f = c.zTop * 100;a.attribs = b;a.top.attr({ d: c.top, zIndex: c.zTop });a.inn.attr({ d: c.inn, zIndex: c.zInn });a.out.attr({ d: c.out, zIndex: c.zOut });a.side1.attr({ d: c.side1, zIndex: c.zSide1 });a.side2.attr({ d: c.side2, zIndex: c.zSide2 });a.zIndex = f;a.attr({ zIndex: f });b.center && (a.top.setRadialReference(b.center), delete b.center);
    };
    a.setPaths(c);a.fillSetter = function (a) {
      var b = d.Color(a).brighten(-0.1).get();this.fill = a;this.side1.attr({ fill: b });this.side2.attr({ fill: b });this.inn.attr({ fill: b });this.out.attr({ fill: b });this.top.attr({ fill: a });return this;
    };r(["opacity", "translateX", "translateY", "visibility"], function (b) {
      a[b + "Setter"] = function (b, c) {
        a[c] = b;r(["out", "inn", "side1", "side2", "top"], function (f) {
          a[f].attr(c, b);
        });
      };
    });J(a, "attr", function (c, f, e) {
      var d;if ((typeof f === "undefined" ? "undefined" : _typeof(f)) === "object" && (d = b(f))) N(a.attribs, d), a.setPaths(a.attribs);return c.call(this, f, e);
    });J(a, "animate", function (a, c, f, e) {
      var d,
          m = this.attribs,
          l,
          o;delete c.center;delete c.z;delete c.depth;delete c.alpha;delete c.beta;o = M(A(f, this.renderer.globalAnimation));if (o.duration && (c = F(c), d = b(c))) l = d, o.step = function (a, b) {
        function c(a) {
          return m[a] + (A(l[a], m[a]) - m[a]) * b.pos;
        }b.elem.setPaths(F(m, { x: c("x"), y: c("y"), r: c("r"), innerR: c("innerR"), start: c("start"), end: c("end") }));
      };return a.call(this, c, f, e);
    });a.destroy = function () {
      this.top.destroy();this.out.destroy();this.inn.destroy();this.side1.destroy();
      this.side2.destroy();d.SVGElement.prototype.destroy.call(this);
    };a.hide = function () {
      this.top.hide();this.out.hide();this.inn.hide();this.side1.hide();this.side2.hide();
    };a.show = function () {
      this.top.show();this.out.show();this.inn.show();this.side1.show();this.side2.show();
    };return a;
  };d.SVGRenderer.prototype.arc3dPath = function (c) {
    function b(a) {
      a %= 2 * p;a > p && (a = 2 * p - a);return a;
    }var a = c.x,
        f = c.y,
        e = c.start,
        d = c.end - 1.0E-5,
        i = c.r,
        j = c.innerR,
        k = c.depth,
        h = c.alpha,
        m = c.beta,
        t = l(e),
        o = q(e),
        c = l(d),
        r = q(d),
        n = i * l(m);i *= l(h);
    var x = j * l(m),
        y = j * l(h),
        j = k * q(m),
        v = k * q(h),
        k = ["M", a + n * t, f + i * o],
        k = k.concat(u(a, f, n, i, e, d, 0, 0)),
        k = k.concat(["L", a + x * c, f + y * r]),
        k = k.concat(u(a, f, x, y, d, e, 0, 0)),
        k = k.concat(["Z"]),
        s = m > 0 ? p / 2 : 0,
        m = h > 0 ? 0 : p / 2,
        s = e > -s ? e : d > -s ? -s : e,
        w = d < p - m ? d : e < p - m ? p - m : d,
        z = 2 * p - m,
        h = ["M", a + n * l(s), f + i * q(s)],
        h = h.concat(u(a, f, n, i, s, w, 0, 0));d > z && e < z ? (h = h.concat(["L", a + n * l(w) + j, f + i * q(w) + v]), h = h.concat(u(a, f, n, i, w, z, j, v)), h = h.concat(["L", a + n * l(z), f + i * q(z)]), h = h.concat(u(a, f, n, i, z, d, 0, 0)), h = h.concat(["L", a + n * l(d) + j, f + i * q(d) + v]), h = h.concat(u(a, f, n, i, d, z, j, v)), h = h.concat(["L", a + n * l(z), f + i * q(z)]), h = h.concat(u(a, f, n, i, z, w, 0, 0))) : d > p - m && e < p - m && (h = h.concat(["L", a + n * l(w) + j, f + i * q(w) + v]), h = h.concat(u(a, f, n, i, w, d, j, v)), h = h.concat(["L", a + n * l(d), f + i * q(d)]), h = h.concat(u(a, f, n, i, d, w, 0, 0)));h = h.concat(["L", a + n * l(w) + j, f + i * q(w) + v]);h = h.concat(u(a, f, n, i, w, s, j, v));h = h.concat(["Z"]);m = ["M", a + x * t, f + y * o];m = m.concat(u(a, f, x, y, e, d, 0, 0));m = m.concat(["L", a + x * l(d) + j, f + y * q(d) + v]);m = m.concat(u(a, f, x, y, d, e, j, v));m = m.concat(["Z"]);t = ["M", a + n * t, f + i * o, "L", a + n * t + j, f + i * o + v, "L", a + x * t + j, f + y * o + v, "L", a + x * t, f + y * o, "Z"];a = ["M", a + n * c, f + i * r, "L", a + n * c + j, f + i * r + v, "L", a + x * c + j, f + y * r + v, "L", a + x * c, f + y * r, "Z"];r = Math.atan2(v, -j);f = Math.abs(d + r);c = Math.abs(e + r);e = Math.abs((e + d) / 2 + r);f = b(f);c = b(c);e = b(e);e *= 1E5;d = c * 1E5;f *= 1E5;return { top: k, zTop: p * 1E5 + 1, out: h, zOut: Math.max(e, d, f), inn: m, zInn: Math.max(e, d, f), side1: t, zSide1: f * 0.99, side2: a, zSide2: d * 0.99 };
  };d.Chart.prototype.is3d = function () {
    return this.options.chart.options3d && this.options.chart.options3d.enabled;
  };d.wrap(d.Chart.prototype, "isInsidePlot", function (c) {
    return this.is3d() || c.apply(this, [].slice.call(arguments, 1));
  });d.getOptions().chart.options3d = { enabled: !1, alpha: 0, beta: 0, depth: 100, fitToPlot: !0, viewDistance: 25, frame: { bottom: { size: 1, color: "rgba(255,255,255,0)" }, side: { size: 1, color: "rgba(255,255,255,0)" }, back: { size: 1, color: "rgba(255,255,255,0)" } } };d.wrap(d.Chart.prototype, "init", function (c) {
    var b = [].slice.call(arguments, 1),
        a;if (b[0].chart && b[0].chart.options3d && b[0].chart.options3d.enabled) b[0].chart.options3d.alpha = (b[0].chart.options3d.alpha || 0) % 360, b[0].chart.options3d.beta = (b[0].chart.options3d.beta || 0) % 360, a = b[0].plotOptions || {}, a = a.pie || {}, a.borderColor = d.pick(a.borderColor, void 0);c.apply(this, b);
  });d.wrap(d.Chart.prototype, "setChartSize", function (c) {
    var b = this.options.chart.options3d;c.apply(this, [].slice.call(arguments, 1));if (this.is3d()) {
      var a = this.inverted,
          f = this.clipBox,
          d = this.margin;f[a ? "y" : "x"] = -(d[3] || 0);f[a ? "x" : "y"] = -(d[0] || 0);f[a ? "height" : "width"] = this.chartWidth + (d[3] || 0) + (d[1] || 0);f[a ? "width" : "height"] = this.chartHeight + (d[0] || 0) + (d[2] || 0);this.scale3d = 1;if (b.fitToPlot === !0) this.scale3d = L(this, b.depth);
    }
  });d.wrap(d.Chart.prototype, "redraw", function (c) {
    if (this.is3d()) this.isDirtyBox = !0;c.apply(this, [].slice.call(arguments, 1));
  });d.wrap(d.Chart.prototype, "renderSeries", function (c) {
    var b = this.series.length;if (this.is3d()) for (; b--;) {
      c = this.series[b], c.translate(), c.render();
    } else c.call(this);
  });d.Chart.prototype.retrieveStacks = function (c) {
    var b = this.series,
        a = {},
        f,
        e = 1;d.each(this.series, function (d) {
      f = A(d.options.stack, c ? 0 : b.length - 1 - d.index);a[f] ? a[f].series.push(d) : (a[f] = { series: [d], position: e }, e++);
    });a.totalStacks = e + 1;return a;
  };d.wrap(d.Axis.prototype, "setOptions", function (c, b) {
    var a;c.call(this, b);if (this.chart.is3d()) a = this.options, a.tickWidth = d.pick(a.tickWidth, 0), a.gridLineWidth = d.pick(a.gridLineWidth, 1);
  });d.wrap(d.Axis.prototype, "render", function (c) {
    c.apply(this, [].slice.call(arguments, 1));if (this.chart.is3d()) {
      var b = this.chart,
          a = b.renderer,
          d = b.options.chart.options3d,
          e = d.frame,
          g = e.bottom,
          i = e.back,
          e = e.side,
          j = d.depth,
          k = this.height,
          h = this.width,
          m = this.left,
          l = this.top;if (!this.isZAxis) this.horiz ? (i = { x: m, y: l + (b.xAxis[0].opposite ? -g.size : k), z: 0, width: h, height: g.size, depth: j, insidePlotArea: !1 }, this.bottomFrame ? this.bottomFrame.animate(i) : this.bottomFrame = a.cuboid(i).attr({ fill: g.color, zIndex: b.yAxis[0].reversed && d.alpha > 0 ? 4 : -1 }).css({ stroke: g.color }).add()) : (d = { x: m + (b.yAxis[0].opposite ? 0 : -e.size), y: l + (b.xAxis[0].opposite ? -g.size : 0), z: j, width: h + e.size, height: k + g.size, depth: i.size, insidePlotArea: !1 }, this.backFrame ? this.backFrame.animate(d) : this.backFrame = a.cuboid(d).attr({ fill: i.color, zIndex: -3 }).css({ stroke: i.color }).add(), b = { x: m + (b.yAxis[0].opposite ? h : -e.size), y: l + (b.xAxis[0].opposite ? -g.size : 0), z: 0, width: e.size, height: k + g.size, depth: j, insidePlotArea: !1 }, this.sideFrame ? this.sideFrame.animate(b) : this.sideFrame = a.cuboid(b).attr({ fill: e.color, zIndex: -2 }).css({ stroke: e.color }).add());
    }
  });d.wrap(d.Axis.prototype, "getPlotLinePath", function (c) {
    var b = c.apply(this, [].slice.call(arguments, 1));if (!this.chart.is3d()) return b;
    if (b === null) return b;var a = this.chart,
        d = a.options.chart.options3d,
        a = this.isZAxis ? a.plotWidth : d.depth,
        d = this.opposite;this.horiz && (d = !d);b = [this.swapZ({ x: b[1], y: b[2], z: d ? a : 0 }), this.swapZ({ x: b[1], y: b[2], z: a }), this.swapZ({ x: b[4], y: b[5], z: a }), this.swapZ({ x: b[4], y: b[5], z: d ? 0 : a })];b = s(b, this.chart, !1);return b = this.chart.renderer.toLinePath(b, !1);
  });d.wrap(d.Axis.prototype, "getLinePath", function (c) {
    return this.chart.is3d() ? [] : c.apply(this, [].slice.call(arguments, 1));
  });d.wrap(d.Axis.prototype, "getPlotBandPath", function (c) {
    if (!this.chart.is3d()) return c.apply(this, [].slice.call(arguments, 1));var b = arguments,
        a = b[1],
        b = this.getPlotLinePath(b[2]);(a = this.getPlotLinePath(a)) && b ? a.push("L", b[10], b[11], "L", b[7], b[8], "L", b[4], b[5], "L", b[1], b[2]) : a = null;return a;
  });d.wrap(d.Tick.prototype, "getMarkPath", function (c) {
    var b = c.apply(this, [].slice.call(arguments, 1));if (!this.axis.chart.is3d()) return b;b = [this.axis.swapZ({ x: b[1], y: b[2], z: 0 }), this.axis.swapZ({ x: b[4], y: b[5], z: 0 })];b = s(b, this.axis.chart, !1);return b = ["M", b[0].x, b[0].y, "L", b[1].x, b[1].y];
  });d.wrap(d.Tick.prototype, "getLabelPosition", function (c) {
    var b = c.apply(this, [].slice.call(arguments, 1));this.axis.chart.is3d() && (b = s([this.axis.swapZ({ x: b.x, y: b.y, z: 0 })], this.axis.chart, !1)[0]);return b;
  });d.wrap(d.Axis.prototype, "getTitlePosition", function (c) {
    var b = this.chart.is3d(),
        a,
        d;if (b) d = this.axisTitleMargin, this.axisTitleMargin = 0;a = c.apply(this, [].slice.call(arguments, 1));if (b) a = s([this.swapZ({ x: a.x, y: a.y, z: 0 })], this.chart, !1)[0], a[this.horiz ? "y" : "x"] += (this.horiz ? 1 : -1) * (this.opposite ? -1 : 1) * d, this.axisTitleMargin = d;return a;
  });d.wrap(d.Axis.prototype, "drawCrosshair", function (c) {
    var b = arguments;this.chart.is3d() && b[2] && (b[2] = { plotX: b[2].plotXold || b[2].plotX, plotY: b[2].plotYold || b[2].plotY });c.apply(this, [].slice.call(b, 1));
  });d.Axis.prototype.swapZ = function (c, b) {
    if (this.isZAxis) {
      var a = b ? 0 : this.chart.plotLeft,
          d = this.chart;return { x: a + (d.yAxis[0].opposite ? c.z : d.xAxis[0].width - c.z), y: c.y, z: c.x - a };
    }return c;
  };var G = d.ZAxis = function () {
    this.isZAxis = !0;this.init.apply(this, arguments);
  };d.extend(G.prototype, d.Axis.prototype);d.extend(G.prototype, { setOptions: function setOptions(c) {
      c = d.merge({ offset: 0, lineWidth: 0 }, c);d.Axis.prototype.setOptions.call(this, c);this.coll = "zAxis";
    }, setAxisSize: function setAxisSize() {
      d.Axis.prototype.setAxisSize.call(this);this.width = this.len = this.chart.options.chart.options3d.depth;this.right = this.chart.chartWidth - this.width - this.left;
    }, getSeriesExtremes: function getSeriesExtremes() {
      var c = this,
          b = c.chart;c.hasVisibleSeries = !1;c.dataMin = c.dataMax = c.ignoreMinPadding = c.ignoreMaxPadding = null;c.buildStacks && c.buildStacks();d.each(c.series, function (a) {
        if (a.visible || !b.options.chart.ignoreHiddenSeries) if (c.hasVisibleSeries = !0, a = a.zData, a.length) c.dataMin = Math.min(A(c.dataMin, a[0]), Math.min.apply(null, a)), c.dataMax = Math.max(A(c.dataMax, a[0]), Math.max.apply(null, a));
      });
    } });d.wrap(d.Chart.prototype, "getAxes", function (c) {
    var b = this,
        a = this.options,
        a = a.zAxis = d.splat(a.zAxis || {});c.call(this);if (b.is3d()) this.zAxis = [], d.each(a, function (a, c) {
      a.index = c;a.isX = !0;new G(b, a).setScale();
    });
  });d.wrap(d.seriesTypes.column.prototype, "translate", function (c) {
    c.apply(this, [].slice.call(arguments, 1));if (this.chart.is3d()) {
      var b = this.chart,
          a = this.options,
          f = a.depth || 25,
          e = (a.stacking ? a.stack || 0 : this._i) * (f + (a.groupZPadding || 1));a.grouping !== !1 && (e = 0);e += a.groupZPadding || 1;d.each(this.data, function (a) {
        if (a.y !== null) {
          var c = a.shapeArgs,
              d = a.tooltipPos;a.shapeType = "cuboid";c.z = e;c.depth = f;c.insidePlotArea = !0;d = s([{ x: d[0], y: d[1], z: e }], b, !0)[0];a.tooltipPos = [d.x, d.y];
        }
      });this.z = e;
    }
  });d.wrap(d.seriesTypes.column.prototype, "animate", function (c) {
    if (this.chart.is3d()) {
      var b = arguments[1],
          a = this.yAxis,
          f = this,
          e = this.yAxis.reversed;if (d.svg) b ? d.each(f.data, function (b) {
        if (b.y !== null && (b.height = b.shapeArgs.height, b.shapey = b.shapeArgs.y, b.shapeArgs.height = 1, !e)) b.shapeArgs.y = b.stackY ? b.plotY + a.translate(b.stackY) : b.plotY + (b.negative ? -b.height : b.height);
      }) : (d.each(f.data, function (a) {
        if (a.y !== null) a.shapeArgs.height = a.height, a.shapeArgs.y = a.shapey, a.graphic && a.graphic.animate(a.shapeArgs, f.options.animation);
      }), this.drawDataLabels(), f.animate = null);
    } else c.apply(this, [].slice.call(arguments, 1));
  });d.wrap(d.seriesTypes.column.prototype, "init", function (c) {
    c.apply(this, [].slice.call(arguments, 1));if (this.chart.is3d()) {
      var b = this.options,
          a = b.grouping,
          d = b.stacking,
          e = A(this.yAxis.options.reversedStacks, !0),
          g = 0;if (a === void 0 || a) {
        a = this.chart.retrieveStacks(d);g = b.stack || 0;for (d = 0; d < a[g].series.length; d++) {
          if (a[g].series[d] === this) break;
        }g = 10 * (a.totalStacks - a[g].position) + (e ? d : -d);this.xAxis.reversed || (g = a.totalStacks * 10 - g);
      }b.zIndex = g;
    }
  });d.wrap(d.Series.prototype, "alignDataLabel", function (c) {
    if (this.chart.is3d() && (this.type === "column" || this.type === "columnrange")) {
      var b = arguments[4],
          a = { x: b.x, y: b.y, z: this.z },
          a = s([a], this.chart, !0)[0];b.x = a.x;b.y = a.y;
    }c.apply(this, [].slice.call(arguments, 1));
  });d.seriesTypes.columnrange && d.wrap(d.seriesTypes.columnrange.prototype, "drawPoints", I);d.wrap(d.seriesTypes.column.prototype, "drawPoints", I);d.wrap(d.seriesTypes.pie.prototype, "translate", function (c) {
    c.apply(this, [].slice.call(arguments, 1));if (this.chart.is3d()) {
      var b = this,
          a = b.options,
          d = a.depth || 0,
          e = b.chart.options.chart.options3d,
          g = e.alpha,
          i = e.beta,
          j = a.stacking ? (a.stack || 0) * d : b._i * d;j += d / 2;a.grouping !== !1 && (j = 0);r(b.data, function (c) {
        var e = c.shapeArgs;c.shapeType = "arc3d";e.z = j;e.depth = d * 0.75;e.alpha = g;e.beta = i;e.center = b.center;e = (e.end + e.start) / 2;c.slicedTranslation = { translateX: K(l(e) * a.slicedOffset * l(g * B)), translateY: K(q(e) * a.slicedOffset * l(g * B)) };
      });
    }
  });d.wrap(d.seriesTypes.pie.prototype.pointClass.prototype, "haloPath", function (c) {
    var b = arguments;return this.series.chart.is3d() ? [] : c.call(this, b[1]);
  });d.wrap(d.seriesTypes.pie.prototype, "drawPoints", function (c) {
    var b = this.options,
        a = b.states;if (this.chart.is3d()) this.borderWidth = b.borderWidth = b.edgeWidth || 1, this.borderColor = b.edgeColor = d.pick(b.edgeColor, b.borderColor, void 0), a.hover.borderColor = d.pick(a.hover.edgeColor, this.borderColor), a.hover.borderWidth = d.pick(a.hover.edgeWidth, this.borderWidth), a.select.borderColor = d.pick(a.select.edgeColor, this.borderColor), a.select.borderWidth = d.pick(a.select.edgeWidth, this.borderWidth), r(this.data, function (b) {
      var c = b.pointAttr;c[""].stroke = b.series.borderColor || b.color;c[""]["stroke-width"] = b.series.borderWidth;c.hover.stroke = a.hover.borderColor;c.hover["stroke-width"] = a.hover.borderWidth;c.select.stroke = a.select.borderColor;c.select["stroke-width"] = a.select.borderWidth;
    });c.apply(this, [].slice.call(arguments, 1));this.chart.is3d() && r(this.points, function (a) {
      var b = a.graphic;if (b) b[a.y && a.visible ? "show" : "hide"]();
    });
  });d.wrap(d.seriesTypes.pie.prototype, "drawDataLabels", function (c) {
    if (this.chart.is3d()) {
      var b = this.chart.options.chart.options3d;
      r(this.data, function (a) {
        var c = a.shapeArgs,
            d = c.r,
            g = (c.beta || b.beta) * B,
            i = (c.start + c.end) / 2,
            j = a.labelPos,
            k = -d * (1 - l((c.alpha || b.alpha) * B)) * q(i),
            h = d * (l(g) - 1) * l(i);r([0, 2, 4], function (a) {
          j[a] += h;j[a + 1] += k;
        });
      });
    }c.apply(this, [].slice.call(arguments, 1));
  });d.wrap(d.seriesTypes.pie.prototype, "addPoint", function (c) {
    c.apply(this, [].slice.call(arguments, 1));this.chart.is3d() && this.update(this.userOptions, !0);
  });d.wrap(d.seriesTypes.pie.prototype, "animate", function (c) {
    if (this.chart.is3d()) {
      var b = arguments[1],
          a = this.options.animation,
          f = this.center,
          e = this.group,
          g = this.markerGroup;if (d.svg) if (a === !0 && (a = {}), b) {
        if (e.oldtranslateX = e.translateX, e.oldtranslateY = e.translateY, b = { translateX: f[0], translateY: f[1], scaleX: 0.001, scaleY: 0.001 }, e.attr(b), g) g.attrSetters = e.attrSetters, g.attr(b);
      } else b = { translateX: e.oldtranslateX, translateY: e.oldtranslateY, scaleX: 1, scaleY: 1 }, e.animate(b, a), g && g.animate(b, a), this.animate = null;
    } else c.apply(this, [].slice.call(arguments, 1));
  });d.wrap(d.seriesTypes.scatter.prototype, "translate", function (c) {
    c.apply(this, [].slice.call(arguments, 1));if (this.chart.is3d()) {
      var b = this.chart,
          a = d.pick(this.zAxis, b.options.zAxis[0]),
          f = [],
          e,
          g,
          i;for (i = 0; i < this.data.length; i++) {
        e = this.data[i], g = a.isLog && a.val2lin ? a.val2lin(e.z) : e.z, e.plotZ = a.translate(g), e.isInside = e.isInside ? g >= a.min && g <= a.max : !1, f.push({ x: e.plotX, y: e.plotY, z: e.plotZ });
      }b = s(f, b, !0);for (i = 0; i < this.data.length; i++) {
        e = this.data[i], a = b[i], e.plotXold = e.plotX, e.plotYold = e.plotY, e.plotZold = e.plotZ, e.plotX = a.x, e.plotY = a.y, e.plotZ = a.z;
      }
    }
  });d.wrap(d.seriesTypes.scatter.prototype, "init", function (c, b, a) {
    if (b.is3d()) this.axisTypes = ["xAxis", "yAxis", "zAxis"], this.pointArrayMap = ["x", "y", "z"], this.parallelArrays = ["x", "y", "z"], this.directTouch = !0;c = c.apply(this, [b, a]);if (this.chart.is3d()) this.tooltipOptions.pointFormat = this.userOptions.tooltip ? this.userOptions.tooltip.pointFormat || "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>" : "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>";return c;
  });if (d.VMLRenderer) d.setOptions({ animate: !1 }), d.VMLRenderer.prototype.cuboid = d.SVGRenderer.prototype.cuboid, d.VMLRenderer.prototype.cuboidPath = d.SVGRenderer.prototype.cuboidPath, d.VMLRenderer.prototype.toLinePath = d.SVGRenderer.prototype.toLinePath, d.VMLRenderer.prototype.createElement3D = d.SVGRenderer.prototype.createElement3D, d.VMLRenderer.prototype.arc3d = function (c) {
    c = d.SVGRenderer.prototype.arc3d.call(this, c);c.css({ zIndex: c.zIndex });return c;
  }, d.VMLRenderer.prototype.arc3dPath = d.SVGRenderer.prototype.arc3dPath, d.wrap(d.Axis.prototype, "render", function (c) {
    c.apply(this, [].slice.call(arguments, 1));this.sideFrame && (this.sideFrame.css({ zIndex: 0 }), this.sideFrame.front.attr({ fill: this.sideFrame.color }));this.bottomFrame && (this.bottomFrame.css({ zIndex: 1 }), this.bottomFrame.front.attr({ fill: this.bottomFrame.color }));this.backFrame && (this.backFrame.css({ zIndex: 0 }), this.backFrame.front.attr({ fill: this.backFrame.color }));
  });
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highcharts JS v4.2.6 (2016-08-02)

 (c) 2011-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (d) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = d : d(Highcharts);
})(function (d) {
  var m = d.Axis,
      q = d.Chart,
      i = d.Color,
      x = d.Legend,
      s = d.LegendSymbolMixin,
      t = d.Series,
      y = d.Point,
      u = d.getOptions(),
      h = d.each,
      r = d.extend,
      v = d.extendClass,
      z = d.isNumber,
      j = d.merge,
      k = d.pick,
      o = d.seriesTypes,
      w = d.wrap,
      n = function n() {},
      p = d.ColorAxis = function () {
    this.isColorAxis = !0;this.init.apply(this, arguments);
  };r(p.prototype, m.prototype);r(p.prototype, { defaultColorAxisOptions: { lineWidth: 0, minPadding: 0, maxPadding: 0, gridLineWidth: 1,
      tickPixelInterval: 72, startOnTick: !0, endOnTick: !0, offset: 0, marker: { animation: { duration: 50 }, color: "gray", width: 0.01 }, labels: { overflow: "justify" }, minColor: "#EFEFFF", maxColor: "#003875", tickLength: 5 }, init: function init(a, b) {
      var c = a.options.legend.layout !== "vertical",
          f;f = j(this.defaultColorAxisOptions, { side: c ? 2 : 1, reversed: !c }, b, { opposite: !c, showEmpty: !1, title: null, isColor: !0 });m.prototype.init.call(this, a, f);b.dataClasses && this.initDataClasses(b);this.initStops(b);this.horiz = c;this.zoomEnabled = !1;
    }, tweenColors: function tweenColors(a, b, c) {
      var f;!b.rgba.length || !a.rgba.length ? a = b.input || "none" : (a = a.rgba, b = b.rgba, f = b[3] !== 1 || a[3] !== 1, a = (f ? "rgba(" : "rgb(") + Math.round(b[0] + (a[0] - b[0]) * (1 - c)) + "," + Math.round(b[1] + (a[1] - b[1]) * (1 - c)) + "," + Math.round(b[2] + (a[2] - b[2]) * (1 - c)) + (f ? "," + (b[3] + (a[3] - b[3]) * (1 - c)) : "") + ")");return a;
    }, initDataClasses: function initDataClasses(a) {
      var b = this,
          c = this.chart,
          f,
          e = 0,
          l = this.options,
          g = a.dataClasses.length;this.dataClasses = f = [];this.legendItems = [];h(a.dataClasses, function (a, d) {
        var h,
            a = j(a);f.push(a);if (!a.color) l.dataClassColor === "category" ? (h = c.options.colors, a.color = h[e++], e === h.length && (e = 0)) : a.color = b.tweenColors(i(l.minColor), i(l.maxColor), g < 2 ? 0.5 : d / (g - 1));
      });
    }, initStops: function initStops(a) {
      this.stops = a.stops || [[0, this.options.minColor], [1, this.options.maxColor]];h(this.stops, function (a) {
        a.color = i(a[1]);
      });
    }, setOptions: function setOptions(a) {
      m.prototype.setOptions.call(this, a);this.options.crosshair = this.options.marker;this.coll = "colorAxis";
    }, setAxisSize: function setAxisSize() {
      var a = this.legendSymbol,
          b = this.chart,
          c,
          f,
          e;if (a) this.left = c = a.attr("x"), this.top = f = a.attr("y"), this.width = e = a.attr("width"), this.height = a = a.attr("height"), this.right = b.chartWidth - c - e, this.bottom = b.chartHeight - f - a, this.len = this.horiz ? e : a, this.pos = this.horiz ? c : f;
    }, toColor: function toColor(a, b) {
      var c,
          f = this.stops,
          e,
          l = this.dataClasses,
          g,
          d;if (l) for (d = l.length; d--;) {
        if (g = l[d], e = g.from, f = g.to, (e === void 0 || a >= e) && (f === void 0 || a <= f)) {
          c = g.color;if (b) b.dataClass = d;break;
        }
      } else {
        this.isLog && (a = this.val2lin(a));c = 1 - (this.max - a) / (this.max - this.min || 1);for (d = f.length; d--;) {
          if (c > f[d][0]) break;
        }e = f[d] || f[d + 1];f = f[d + 1] || e;c = 1 - (f[0] - c) / (f[0] - e[0] || 1);c = this.tweenColors(e.color, f.color, c);
      }return c;
    }, getOffset: function getOffset() {
      var a = this.legendGroup,
          b = this.chart.axisOffset[this.side];if (a) {
        this.axisParent = a;m.prototype.getOffset.call(this);if (!this.added) this.added = !0, this.labelLeft = 0, this.labelRight = this.width;this.chart.axisOffset[this.side] = b;
      }
    }, setLegendColor: function setLegendColor() {
      var a,
          b = this.options,
          c = this.reversed;a = c ? 1 : 0;c = c ? 0 : 1;a = this.horiz ? [a, 0, c, 0] : [0, c, 0, a];this.legendColor = { linearGradient: { x1: a[0], y1: a[1], x2: a[2],
          y2: a[3] }, stops: b.stops || [[0, b.minColor], [1, b.maxColor]] };
    }, drawLegendSymbol: function drawLegendSymbol(a, b) {
      var c = a.padding,
          f = a.options,
          e = this.horiz,
          d = k(f.symbolWidth, e ? 200 : 12),
          g = k(f.symbolHeight, e ? 12 : 200),
          h = k(f.labelPadding, e ? 16 : 30),
          f = k(f.itemDistance, 10);this.setLegendColor();b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, d, g).attr({ zIndex: 1 }).add(b.legendGroup);this.legendItemWidth = d + c + (e ? f : h);this.legendItemHeight = g + c + (e ? h : 0);
    }, setState: n, visible: !0, setVisible: n, getSeriesExtremes: function getSeriesExtremes() {
      var a;if (this.series.length) a = this.series[0], this.dataMin = a.valueMin, this.dataMax = a.valueMax;
    }, drawCrosshair: function drawCrosshair(a, b) {
      var c = b && b.plotX,
          f = b && b.plotY,
          e,
          d = this.pos,
          g = this.len;if (b) e = this.toPixels(b[b.series.colorKey]), e < d ? e = d - 2 : e > d + g && (e = d + g + 2), b.plotX = e, b.plotY = this.len - e, m.prototype.drawCrosshair.call(this, a, b), b.plotX = c, b.plotY = f, this.cross && this.cross.attr({ fill: this.crosshair.color }).add(this.legendGroup);
    }, getPlotLinePath: function getPlotLinePath(a, b, c, f, e) {
      return z(e) ? this.horiz ? ["M", e - 4, this.top - 6, "L", e + 4, this.top - 6, e, this.top, "Z"] : ["M", this.left, e, "L", this.left - 6, e + 6, this.left - 6, e - 6, "Z"] : m.prototype.getPlotLinePath.call(this, a, b, c, f);
    }, update: function update(a, b) {
      var c = this.chart,
          f = c.legend;h(this.series, function (a) {
        a.isDirtyData = !0;
      });if (a.dataClasses && f.allItems) h(f.allItems, function (a) {
        a.isDataClass && a.legendGroup.destroy();
      }), c.isDirtyLegend = !0;c.options[this.coll] = j(this.userOptions, a);m.prototype.update.call(this, a, b);this.legendItem && (this.setLegendColor(), f.colorizeItem(this, !0));
    }, getDataClassLegendSymbols: function getDataClassLegendSymbols() {
      var a = this,
          b = this.chart,
          c = this.legendItems,
          f = b.options.legend,
          e = f.valueDecimals,
          l = f.valueSuffix || "",
          g;c.length || h(this.dataClasses, function (f, m) {
        var i = !0,
            j = f.from,
            k = f.to;g = "";j === void 0 ? g = "< " : k === void 0 && (g = "> ");j !== void 0 && (g += d.numberFormat(j, e) + l);j !== void 0 && k !== void 0 && (g += " - ");k !== void 0 && (g += d.numberFormat(k, e) + l);c.push(r({ chart: b, name: g, options: {}, drawLegendSymbol: s.drawRectangle, visible: !0, setState: n, isDataClass: !0, setVisible: function setVisible() {
            i = this.visible = !i;h(a.series, function (a) {
              h(a.points, function (a) {
                a.dataClass === m && a.setVisible(i);
              });
            });b.legend.colorizeItem(this, i);
          } }, f));
      });return c;
    }, name: "" });h(["fill", "stroke"], function (a) {
    d.Fx.prototype[a + "Setter"] = function () {
      this.elem.attr(a, p.prototype.tweenColors(i(this.start), i(this.end), this.pos));
    };
  });w(q.prototype, "getAxes", function (a) {
    var b = this.options.colorAxis;a.call(this);this.colorAxis = [];b && new p(this, b);
  });w(x.prototype, "getAllItems", function (a) {
    var b = [],
        c = this.chart.colorAxis[0];c && (c.options.dataClasses ? b = b.concat(c.getDataClassLegendSymbols()) : b.push(c), h(c.series, function (a) {
      a.options.showInLegend = !1;
    }));return b.concat(a.call(this));
  });q = { pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color", dashstyle: "dashStyle" }, pointArrayMap: ["value"], axisTypes: ["xAxis", "yAxis", "colorAxis"], optionalAxis: "colorAxis", trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], getSymbol: n, parallelArrays: ["x", "y", "value"], colorKey: "value", translateColors: function translateColors() {
      var a = this,
          b = this.options.nullColor,
          c = this.colorAxis,
          f = this.colorKey;h(this.data, function (e) {
        var d = e[f];if (d = e.options.color || (d === null ? b : c && d !== void 0 ? c.toColor(d, e) : e.color || a.color)) e.color = d;
      });
    } };u.plotOptions.heatmap = j(u.plotOptions.scatter, { animation: !1, borderWidth: 0, nullColor: "#F8F8F8", dataLabels: { formatter: function formatter() {
        return this.point.value;
      }, inside: !0, verticalAlign: "middle", crop: !1, overflow: !1, padding: 0 }, marker: null, pointRange: null, tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" }, states: { normal: { animation: !0 }, hover: { halo: !1, brightness: 0.2 } } });o.heatmap = v(o.scatter, j(q, { type: "heatmap",
    pointArrayMap: ["y", "value"], hasPointSpecificOptions: !0, pointClass: v(y, { setVisible: function setVisible(a) {
        var b = this,
            c = a ? "show" : "hide";h(["graphic", "dataLabel"], function (a) {
          if (b[a]) b[a][c]();
        });
      } }), supportsDrilldown: !0, getExtremesFromAll: !0, directTouch: !0, init: function init() {
      var a;o.scatter.prototype.init.apply(this, arguments);a = this.options;a.pointRange = k(a.pointRange, a.colsize || 1);this.yAxis.axisPointRange = a.rowsize || 1;
    }, translate: function translate() {
      var a = this.options,
          b = this.xAxis,
          c = this.yAxis,
          f = function f(a, b, c) {
        return Math.min(Math.max(b, a), c);
      };this.generatePoints();h(this.points, function (e) {
        var d = (a.colsize || 1) / 2,
            g = (a.rowsize || 1) / 2,
            h = f(Math.round(b.len - b.translate(e.x - d, 0, 1, 0, 1)), -b.len, 2 * b.len),
            d = f(Math.round(b.len - b.translate(e.x + d, 0, 1, 0, 1)), -b.len, 2 * b.len),
            i = f(Math.round(c.translate(e.y - g, 0, 1, 0, 1)), -c.len, 2 * c.len),
            g = f(Math.round(c.translate(e.y + g, 0, 1, 0, 1)), -c.len, 2 * c.len);e.plotX = e.clientX = (h + d) / 2;e.plotY = (i + g) / 2;e.shapeType = "rect";e.shapeArgs = { x: Math.min(h, d), y: Math.min(i, g), width: Math.abs(d - h), height: Math.abs(g - i) };
      });this.translateColors();
      this.chart.hasRendered && h(this.points, function (a) {
        a.shapeArgs.fill = a.options.color || a.color;
      });
    }, drawPoints: o.column.prototype.drawPoints, animate: n, getBox: n, drawLegendSymbol: s.drawRectangle, alignDataLabel: o.column.prototype.alignDataLabel, getExtremes: function getExtremes() {
      t.prototype.getExtremes.call(this, this.valueData);this.valueMin = this.dataMin;this.valueMax = this.dataMax;t.prototype.getExtremes.call(this);
    } }));
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highcharts JS v4.2.6 (2016-08-02)

 (c) 2014 Highsoft AS
 Authors: Jon Arild Nygard / Oystein Moseng

 License: www.highcharts.com/license
*/
(function (f) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = f : f(Highcharts);
})(function (f) {
  var i = f.seriesTypes,
      B = f.map,
      m = f.merge,
      t = f.extend,
      u = f.extendClass,
      v = f.getOptions().plotOptions,
      w = function w() {},
      k = f.each,
      r = f.grep,
      j = f.pick,
      n = f.Series,
      C = f.stableSort,
      x = f.Color,
      D = function D(a, b, c) {
    var d,
        c = c || this;for (d in a) {
      a.hasOwnProperty(d) && b.call(c, a[d], d, a);
    }
  },
      y = function y(a, b, c, d) {
    d = d || this;a = a || [];k(a, function (e, h) {
      c = b.call(d, c, e, h, a);
    });return c;
  },
      q = function q(a, b, c) {
    c = c || this;a = b.call(c, a);a !== !1 && q(a, b, c);
  };v.treemap = m(v.scatter, { showInLegend: !1, marker: !1, borderColor: "#E0E0E0", borderWidth: 1, dataLabels: { enabled: !0, defer: !1, verticalAlign: "middle", formatter: function formatter() {
        return this.point.name || this.point.id;
      }, inside: !0 }, tooltip: { headerFormat: "", pointFormat: "<b>{point.name}</b>: {point.value}</b><br/>" }, layoutAlgorithm: "sliceAndDice", layoutStartingDirection: "vertical", alternateStartingDirection: !1, levelIsConstant: !0, opacity: 0.15, states: { hover: { borderColor: "#A0A0A0", brightness: i.heatmap ? 0 : 0.1, opacity: 0.75,
        shadow: !1 } }, drillUpButton: { position: { align: "right", x: -10, y: 10 } } });i.treemap = u(i.scatter, m({ pointAttrToOptions: {}, pointArrayMap: ["value"], axisTypes: i.heatmap ? ["xAxis", "yAxis", "colorAxis"] : ["xAxis", "yAxis"], optionalAxis: "colorAxis", getSymbol: w, parallelArrays: ["x", "y", "value", "colorValue"], colorKey: "colorValue", translateColors: i.heatmap && i.heatmap.prototype.translateColors }, { type: "treemap", trackerGroups: ["group", "dataLabelsGroup"], pointClass: u(f.Point, { setVisible: i.pie.prototype.pointClass.prototype.setVisible }),
    getListOfParents: function getListOfParents(a, b) {
      var c = y(a, function (a, c, b) {
        c = j(c.parent, "");a[c] === void 0 && (a[c] = []);a[c].push(b);return a;
      }, {});D(c, function (a, c, h) {
        c !== "" && f.inArray(c, b) === -1 && (k(a, function (a) {
          h[""].push(a);
        }), delete h[c]);
      });return c;
    }, getTree: function getTree() {
      var a,
          b = this;a = B(this.data, function (a) {
        return a.id;
      });a = b.getListOfParents(this.data, a);b.nodeMap = [];a = b.buildNode("", -1, 0, a, null);q(this.nodeMap[this.rootNode], function (a) {
        var d = !1,
            e = a.parent;a.visible = !0;if (e || e === "") d = b.nodeMap[e];return d;
      });q(this.nodeMap[this.rootNode].children, function (a) {
        var b = !1;k(a, function (a) {
          a.visible = !0;a.children.length && (b = (b || []).concat(a.children));
        });return b;
      });this.setTreeValues(a);return a;
    }, init: function init(a, b) {
      n.prototype.init.call(this, a, b);this.options.allowDrillToNode && this.drillTo();
    }, buildNode: function buildNode(a, b, c, d, e) {
      var h = this,
          g = [],
          z = h.points[b],
          A;k(d[a] || [], function (b) {
        A = h.buildNode(h.points[b].id, b, c + 1, d, a);g.push(A);
      });b = { id: a, i: b, children: g, level: c, parent: e, visible: !1 };h.nodeMap[b.id] = b;if (z) z.node = b;return b;
    }, setTreeValues: function setTreeValues(a) {
      var b = this,
          c = b.options,
          d = 0,
          e = [],
          h,
          g = b.points[a.i];k(a.children, function (a) {
        a = b.setTreeValues(a);e.push(a);a.ignore ? q(a.children, function (a) {
          var c = !1;k(a, function (a) {
            t(a, { ignore: !0, isLeaf: !1, visible: !1 });a.children.length && (c = (c || []).concat(a.children));
          });return c;
        }) : d += a.val;
      });C(e, function (a, c) {
        return a.sortIndex - c.sortIndex;
      });h = j(g && g.options.value, d);if (g) g.value = h;t(a, { children: e, childrenTotal: d, ignore: !(j(g && g.visible, !0) && h > 0), isLeaf: a.visible && !d, levelDynamic: c.levelIsConstant ? a.level : a.level - b.nodeMap[b.rootNode].level,
        name: j(g && g.name, ""), sortIndex: j(g && g.sortIndex, -h), val: h });return a;
    }, calculateChildrenAreas: function calculateChildrenAreas(a, b) {
      var c = this,
          d = c.options,
          e = this.levelMap[a.levelDynamic + 1],
          h = j(c[e && e.layoutAlgorithm] && e.layoutAlgorithm, d.layoutAlgorithm),
          g = d.alternateStartingDirection,
          f = [],
          d = r(a.children, function (a) {
        return !a.ignore;
      });if (e && e.layoutStartingDirection) b.direction = e.layoutStartingDirection === "vertical" ? 0 : 1;f = c[h](b, d);k(d, function (a, d) {
        var e = f[d];a.values = m(e, { val: a.childrenTotal, direction: g ? 1 - b.direction : b.direction });
        a.pointValues = m(e, { x: e.x / c.axisRatio, width: e.width / c.axisRatio });a.children.length && c.calculateChildrenAreas(a, a.values);
      });
    }, setPointValues: function setPointValues() {
      var a = this.xAxis,
          b = this.yAxis;k(this.points, function (c) {
        var d = c.node,
            e = d.pointValues,
            h,
            g;e && d.visible ? (d = Math.round(a.translate(e.x, 0, 0, 0, 1)), h = Math.round(a.translate(e.x + e.width, 0, 0, 0, 1)), g = Math.round(b.translate(e.y, 0, 0, 0, 1)), e = Math.round(b.translate(e.y + e.height, 0, 0, 0, 1)), c.shapeType = "rect", c.shapeArgs = { x: Math.min(d, h), y: Math.min(g, e), width: Math.abs(h - d), height: Math.abs(e - g) }, c.plotX = c.shapeArgs.x + c.shapeArgs.width / 2, c.plotY = c.shapeArgs.y + c.shapeArgs.height / 2) : (delete c.plotX, delete c.plotY);
      });
    }, setColorRecursive: function setColorRecursive(a, b) {
      var c = this,
          d,
          e;if (a) {
        d = c.points[a.i];e = c.levelMap[a.levelDynamic];b = j(d && d.options.color, e && e.color, b);if (d) d.color = b;a.children.length && k(a.children, function (a) {
          c.setColorRecursive(a, b);
        });
      }
    }, algorithmGroup: function algorithmGroup(a, b, c, d) {
      this.height = a;this.width = b;this.plot = d;this.startDirection = this.direction = c;this.lH = this.nH = this.lW = this.nW = this.total = 0;this.elArr = [];this.lP = { total: 0, lH: 0, nH: 0, lW: 0, nW: 0, nR: 0, lR: 0, aspectRatio: function aspectRatio(a, c) {
          return Math.max(a / c, c / a);
        } };this.addElement = function (a) {
        this.lP.total = this.elArr[this.elArr.length - 1];this.total += a;this.direction === 0 ? (this.lW = this.nW, this.lP.lH = this.lP.total / this.lW, this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH), this.nW = this.total / this.height, this.lP.nH = this.lP.total / this.nW, this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH)) : (this.lH = this.nH, this.lP.lW = this.lP.total / this.lH, this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH), this.nH = this.total / this.width, this.lP.nW = this.lP.total / this.nH, this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH));this.elArr.push(a);
      };this.reset = function () {
        this.lW = this.nW = 0;this.elArr = [];this.total = 0;
      };
    }, algorithmCalcPoints: function algorithmCalcPoints(a, b, c, d) {
      var e,
          h,
          g,
          f,
          j = c.lW,
          s = c.lH,
          l = c.plot,
          i,
          o = 0,
          p = c.elArr.length - 1;b ? (j = c.nW, s = c.nH) : i = c.elArr[c.elArr.length - 1];k(c.elArr, function (a) {
        if (b || o < p) c.direction === 0 ? (e = l.x, h = l.y, g = j, f = a / g) : (e = l.x, h = l.y, f = s, g = a / f), d.push({ x: e, y: h, width: g, height: f }), c.direction === 0 ? l.y += f : l.x += g;o += 1;
      });c.reset();c.direction === 0 ? c.width -= j : c.height -= s;l.y = l.parent.y + (l.parent.height - c.height);l.x = l.parent.x + (l.parent.width - c.width);if (a) c.direction = 1 - c.direction;b || c.addElement(i);
    }, algorithmLowAspectRatio: function algorithmLowAspectRatio(a, b, c) {
      var d = [],
          e = this,
          h,
          g = { x: b.x, y: b.y, parent: b },
          f = 0,
          j = c.length - 1,
          i = new this.algorithmGroup(b.height, b.width, b.direction, g);k(c, function (c) {
        h = b.width * b.height * (c.val / b.val);i.addElement(h);i.lP.nR > i.lP.lR && e.algorithmCalcPoints(a, !1, i, d, g);f === j && e.algorithmCalcPoints(a, !0, i, d, g);f += 1;
      });return d;
    }, algorithmFill: function algorithmFill(a, b, c) {
      var d = [],
          e,
          f = b.direction,
          g = b.x,
          i = b.y,
          j = b.width,
          m = b.height,
          l,
          n,
          o,
          p;k(c, function (c) {
        e = b.width * b.height * (c.val / b.val);l = g;n = i;f === 0 ? (p = m, o = e / p, j -= o, g += o) : (o = j, p = e / o, m -= p, i += p);d.push({ x: l, y: n, width: o, height: p });a && (f = 1 - f);
      });return d;
    }, strip: function strip(a, b) {
      return this.algorithmLowAspectRatio(!1, a, b);
    }, squarified: function squarified(a, b) {
      return this.algorithmLowAspectRatio(!0, a, b);
    }, sliceAndDice: function sliceAndDice(a, b) {
      return this.algorithmFill(!0, a, b);
    }, stripes: function stripes(a, b) {
      return this.algorithmFill(!1, a, b);
    }, translate: function translate() {
      var a, b;n.prototype.translate.call(this);this.rootNode = j(this.options.rootId, "");this.levelMap = y(this.options.levels, function (a, b) {
        a[b.level] = b;return a;
      }, {});b = this.tree = this.getTree();this.axisRatio = this.xAxis.len / this.yAxis.len;this.nodeMap[""].pointValues = a = { x: 0, y: 0, width: 100, height: 100 };this.nodeMap[""].values = a = m(a, { width: a.width * this.axisRatio, direction: this.options.layoutStartingDirection === "vertical" ? 0 : 1, val: b.val });
      this.calculateChildrenAreas(b, a);this.colorAxis ? this.translateColors() : this.options.colorByPoint || this.setColorRecursive(this.tree, void 0);if (this.options.allowDrillToNode) b = this.nodeMap[this.rootNode].pointValues, this.xAxis.setExtremes(b.x, b.x + b.width, !1), this.yAxis.setExtremes(b.y, b.y + b.height, !1), this.xAxis.setScale(), this.yAxis.setScale();this.setPointValues();
    }, drawDataLabels: function drawDataLabels() {
      var a = this,
          b = r(a.points, function (a) {
        return a.node.visible;
      }),
          c,
          d;k(b, function (b) {
        d = a.levelMap[b.node.levelDynamic];
        c = { style: {} };if (!b.node.isLeaf) c.enabled = !1;if (d && d.dataLabels) c = m(c, d.dataLabels), a._hasPointLabels = !0;if (b.shapeArgs) c.style.width = b.shapeArgs.width, b.dataLabel && b.dataLabel.css({ width: b.shapeArgs.width + "px" });b.dlOptions = m(c, b.options.dataLabels);
      });n.prototype.drawDataLabels.call(this);
    }, alignDataLabel: i.column.prototype.alignDataLabel, pointAttribs: function pointAttribs(a, b) {
      var c = this.levelMap[a.node.levelDynamic] || {},
          d = this.options,
          e = b && d.states[b] || {},
          c = { stroke: a.borderColor || c.borderColor || e.borderColor || d.borderColor, "stroke-width": j(a.borderWidth, c.borderWidth, e.borderWidth, d.borderWidth), dashstyle: a.borderDashStyle || c.borderDashStyle || e.borderDashStyle || d.borderDashStyle, fill: a.color || this.color, zIndex: b === "hover" ? 1 : 0 };if (a.node.level <= this.nodeMap[this.rootNode].level) c.fill = "none", c["stroke-width"] = 0;else if (a.node.isLeaf) {
        if (b) c.fill = x(c.fill).brighten(e.brightness).get();
      } else j(d.interactByLeaf, !d.allowDrillToNode) ? c.fill = "none" : (d = j(e.opacity, d.opacity), c.fill = x(c.fill).setOpacity(d).get());
      return c;
    }, drawPoints: function drawPoints() {
      var a = this,
          b = r(a.points, function (a) {
        return a.node.visible;
      });k(b, function (c) {
        var b = "levelGroup-" + c.node.levelDynamic;a[b] || (a[b] = a.chart.renderer.g(b).attr({ zIndex: 1E3 - c.node.levelDynamic }).add(a.group));c.group = a[b];b = a.pointAttribs(c);c.pointAttr = { "": b, hover: a.pointAttribs(c, "hover"), select: {} };b = parseInt(b["stroke-width"], 10) % 2 / 2;c.shapeArgs.x -= b;c.shapeArgs.y -= b;
      });i.column.prototype.drawPoints.call(this);a.options.allowDrillToNode && k(b, function (b) {
        var d;if (b.graphic) d = b.drillId = a.options.interactByLeaf ? a.drillToByLeaf(b) : a.drillToByGroup(b), b.graphic.css({ cursor: d ? "pointer" : "default" });
      });
    }, drillTo: function drillTo() {
      var a = this;f.addEvent(a, "click", function (b) {
        var b = b.point,
            c = b.drillId,
            d;c && (d = a.nodeMap[a.rootNode].name || a.rootNode, b.setState(""), a.drillToNode(c), a.showDrillUpButton(d));
      });
    }, drillToByGroup: function drillToByGroup(a) {
      var b = !1;if (a.node.level - this.nodeMap[this.rootNode].level === 1 && !a.node.isLeaf) b = a.id;return b;
    }, drillToByLeaf: function drillToByLeaf(a) {
      var b = !1;if (a.node.parent !== this.rootNode && a.node.isLeaf) for (a = a.node; !b;) {
        if (a = this.nodeMap[a.parent], a.parent === this.rootNode) b = a.id;
      }return b;
    }, drillUp: function drillUp() {
      var a = null;this.rootNode && (a = this.nodeMap[this.rootNode], a = a.parent !== null ? this.nodeMap[a.parent] : this.nodeMap[""]);if (a !== null) this.drillToNode(a.id), a.id === "" ? this.drillUpButton = this.drillUpButton.destroy() : (a = this.nodeMap[a.parent], this.showDrillUpButton(a.name || a.id));
    }, drillToNode: function drillToNode(a) {
      this.options.rootId = a;this.isDirty = !0;this.chart.redraw();
    }, showDrillUpButton: function showDrillUpButton(a) {
      var b = this,
          a = a || "< Back",
          c = b.options.drillUpButton,
          d,
          e;if (c.text) a = c.text;this.drillUpButton ? this.drillUpButton.attr({ text: a }).align() : (e = (d = c.theme) && d.states, this.drillUpButton = this.chart.renderer.button(a, null, null, function () {
        b.drillUp();
      }, d, e && e.hover, e && e.select).attr({ align: c.position.align, zIndex: 9 }).add().align(c.position, !1, c.relativeTo || "plotBox"));
    }, buildKDTree: w, drawLegendSymbol: f.LegendSymbolMixin.drawRectangle, getExtremes: function getExtremes() {
      n.prototype.getExtremes.call(this, this.colorValueData);this.valueMin = this.dataMin;this.valueMax = this.dataMax;n.prototype.getExtremes.call(this);
    }, getExtremesFromAll: !0, bindAxes: function bindAxes() {
      var a = { endOnTick: !1, gridLineWidth: 0, lineWidth: 0, min: 0, dataMin: 0, minPadding: 0, max: 100, dataMax: 100, maxPadding: 0, startOnTick: !1, title: null, tickPositions: [] };n.prototype.bindAxes.call(this);f.extend(this.yAxis.options, a);f.extend(this.xAxis.options, a);
    } }));
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (e) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = e : e(Highcharts);
})(function (e) {
  function A(b, a, d) {
    var c;!a.rgba.length || !b.rgba.length ? b = a.input || "none" : (b = b.rgba, a = a.rgba, c = a[3] !== 1 || b[3] !== 1, b = (c ? "rgba(" : "rgb(") + Math.round(a[0] + (b[0] - a[0]) * (1 - d)) + "," + Math.round(a[1] + (b[1] - a[1]) * (1 - d)) + "," + Math.round(a[2] + (b[2] - a[2]) * (1 - d)) + (c ? "," + (a[3] + (b[3] - a[3]) * (1 - d)) : "") + ")");return b;
  }var u = function u() {},
      q = e.getOptions(),
      i = e.each,
      o = e.extend,
      B = e.format,
      C = e.merge,
      v = e.pick,
      r = e.wrap,
      l = e.Chart,
      p = e.seriesTypes,
      w = p.pie,
      m = p.column,
      x = e.Tick,
      s = e.fireEvent,
      y = e.inArray,
      z = 1;i(["fill", "stroke"], function (b) {
    e.Fx.prototype[b + "Setter"] = function () {
      this.elem.attr(b, A(e.Color(this.start), e.Color(this.end), this.pos));
    };
  });o(q.lang, { drillUpText: "\u25C1 Back to {series.name}" });q.drilldown = { activeAxisLabelStyle: { cursor: "pointer", color: "#0d233a", fontWeight: "bold", textDecoration: "underline" }, activeDataLabelStyle: { cursor: "pointer", color: "#0d233a", fontWeight: "bold", textDecoration: "underline" }, animation: { duration: 500 },
    drillUpButton: { position: { align: "right", x: -10, y: 10 } } };e.SVGRenderer.prototype.Element.prototype.fadeIn = function (b) {
    this.attr({ opacity: 0.1, visibility: "inherit" }).animate({ opacity: v(this.newOpacity, 1) }, b || { duration: 250 });
  };l.prototype.addSeriesAsDrilldown = function (b, a) {
    this.addSingleSeriesAsDrilldown(b, a);this.applyDrilldown();
  };l.prototype.addSingleSeriesAsDrilldown = function (b, a) {
    var d = b.series,
        c = d.xAxis,
        g = d.yAxis,
        f;f = b.color || d.color;var h,
        e = [],
        j = [],
        k,
        n;if (!this.drilldownLevels) this.drilldownLevels = [];k = d.options._levelNumber || 0;(n = this.drilldownLevels[this.drilldownLevels.length - 1]) && n.levelNumber !== k && (n = void 0);if (!a.color) a.color = f;a._ddSeriesId = z++;h = y(b, d.points);i(d.chart.series, function (a) {
      if (a.xAxis === c && !a.isDrilling) a.options._ddSeriesId = a.options._ddSeriesId || z++, a.options._colorIndex = a.userOptions._colorIndex, a.options._levelNumber = a.options._levelNumber || k, n ? (e = n.levelSeries, j = n.levelSeriesOptions) : (e.push(a), j.push(a.options));
    });f = { levelNumber: k, seriesOptions: d.options, levelSeriesOptions: j,
      levelSeries: e, shapeArgs: b.shapeArgs, bBox: b.graphic ? b.graphic.getBBox() : {}, color: f, lowerSeriesOptions: a, pointOptions: d.options.data[h], pointIndex: h, oldExtremes: { xMin: c && c.userMin, xMax: c && c.userMax, yMin: g && g.userMin, yMax: g && g.userMax } };this.drilldownLevels.push(f);f = f.lowerSeries = this.addSeries(a, !1);f.options._levelNumber = k + 1;if (c) c.oldPos = c.pos, c.userMin = c.userMax = null, g.userMin = g.userMax = null;if (d.type === f.type) f.animate = f.animateDrilldown || u, f.options.animation = !0;
  };l.prototype.applyDrilldown = function () {
    var b = this.drilldownLevels,
        a;if (b && b.length > 0) a = b[b.length - 1].levelNumber, i(this.drilldownLevels, function (b) {
      b.levelNumber === a && i(b.levelSeries, function (b) {
        b.options && b.options._levelNumber === a && b.remove(!1);
      });
    });this.redraw();this.showDrillUpButton();
  };l.prototype.getDrilldownBackText = function () {
    var b = this.drilldownLevels;if (b && b.length > 0) return b = b[b.length - 1], b.series = b.seriesOptions, B(this.options.lang.drillUpText, b);
  };l.prototype.showDrillUpButton = function () {
    var b = this,
        a = this.getDrilldownBackText(),
        d = b.options.drilldown.drillUpButton,
        c,
        g;this.drillUpButton ? this.drillUpButton.attr({ text: a }).align() : (g = (c = d.theme) && c.states, this.drillUpButton = this.renderer.button(a, null, null, function () {
      b.drillUp();
    }, c, g && g.hover, g && g.select).attr({ align: d.position.align, zIndex: 9 }).add().align(d.position, !1, d.relativeTo || "plotBox"));
  };l.prototype.drillUp = function () {
    for (var b = this, a = b.drilldownLevels, d = a[a.length - 1].levelNumber, c = a.length, g = b.series, f, h, e, j, k = function k(a) {
      var c;i(g, function (b) {
        b.options._ddSeriesId === a._ddSeriesId && (c = b);
      });c = c || b.addSeries(a, !1);if (c.type === e.type && c.animateDrillupTo) c.animate = c.animateDrillupTo;a === h.seriesOptions && (j = c);
    }; c--;) {
      if (h = a[c], h.levelNumber === d) {
        a.pop();e = h.lowerSeries;if (!e.chart) for (f = g.length; f--;) {
          if (g[f].options.id === h.lowerSeriesOptions.id && g[f].options._levelNumber === d + 1) {
            e = g[f];break;
          }
        }e.xData = [];i(h.levelSeriesOptions, k);s(b, "drillup", { seriesOptions: h.seriesOptions });if (j.type === e.type) j.drilldownLevel = h, j.options.animation = b.options.drilldown.animation, e.animateDrillupFrom && e.chart && e.animateDrillupFrom(h);j.options._levelNumber = d;e.remove(!1);if (j.xAxis) f = h.oldExtremes, j.xAxis.setExtremes(f.xMin, f.xMax, !1), j.yAxis.setExtremes(f.yMin, f.yMax, !1);
      }
    }s(b, "drillupall");this.redraw();this.drilldownLevels.length === 0 ? this.drillUpButton = this.drillUpButton.destroy() : this.drillUpButton.attr({ text: this.getDrilldownBackText() }).align();this.ddDupes.length = [];
  };m.prototype.supportsDrilldown = !0;m.prototype.animateDrillupTo = function (b) {
    if (!b) {
      var a = this,
          d = a.drilldownLevel;i(this.points, function (a) {
        a.graphic && a.graphic.hide();a.dataLabel && a.dataLabel.hide();a.connector && a.connector.hide();
      });setTimeout(function () {
        a.points && i(a.points, function (a, b) {
          var f = b === (d && d.pointIndex) ? "show" : "fadeIn",
              e = f === "show" ? !0 : void 0;if (a.graphic) a.graphic[f](e);if (a.dataLabel) a.dataLabel[f](e);if (a.connector) a.connector[f](e);
        });
      }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0));this.animate = u;
    }
  };m.prototype.animateDrilldown = function (b) {
    var a = this,
        d = this.chart.drilldownLevels,
        c,
        g = this.chart.options.drilldown.animation,
        f = this.xAxis;if (!b) i(d, function (b) {
      if (a.options._ddSeriesId === b.lowerSeriesOptions._ddSeriesId) c = b.shapeArgs, c.fill = b.color;
    }), c.x += v(f.oldPos, f.pos) - f.pos, i(this.points, function (b) {
      b.graphic && b.graphic.attr(c).animate(o(b.shapeArgs, { fill: b.color || a.color }), g);b.dataLabel && b.dataLabel.fadeIn(g);
    }), this.animate = null;
  };m.prototype.animateDrillupFrom = function (b) {
    var a = this.chart.options.drilldown.animation,
        d = this.group,
        c = this;i(c.trackerGroups, function (a) {
      if (c[a]) c[a].on("mouseover");
    });delete this.group;
    i(this.points, function (c) {
      var f = c.graphic,
          h = function h() {
        f.destroy();d && (d = d.destroy());
      };f && (delete c.graphic, a ? f.animate(o(b.shapeArgs, { fill: b.color }), e.merge(a, { complete: h })) : (f.attr(b.shapeArgs), h()));
    });
  };w && o(w.prototype, { supportsDrilldown: !0, animateDrillupTo: m.prototype.animateDrillupTo, animateDrillupFrom: m.prototype.animateDrillupFrom, animateDrilldown: function animateDrilldown(b) {
      var a = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],
          d = this.chart.options.drilldown.animation,
          c = a.shapeArgs,
          g = c.start,
          f = (c.end - g) / this.points.length;if (!b) i(this.points, function (b, i) {
        b.graphic.attr(e.merge(c, { start: g + i * f, end: g + (i + 1) * f, fill: a.color }))[d ? "animate" : "attr"](o(b.shapeArgs, { fill: b.color }), d);
      }), this.animate = null;
    } });e.Point.prototype.doDrilldown = function (b, a, d) {
    var c = this.series.chart,
        e = c.options.drilldown,
        f = (e.series || []).length,
        h;if (!c.ddDupes) c.ddDupes = [];for (; f-- && !h;) {
      e.series[f].id === this.drilldown && y(this.drilldown, c.ddDupes) === -1 && (h = e.series[f], c.ddDupes.push(this.drilldown));
    }s(c, "drilldown", { point: this,
      seriesOptions: h, category: a, originalEvent: d, points: a !== void 0 && this.series.xAxis.ddPoints[a].slice(0) }, function (a) {
      var c = a.point.series && a.point.series.chart,
          d = a.seriesOptions;c && d && (b ? c.addSingleSeriesAsDrilldown(a.point, d) : c.addSeriesAsDrilldown(a.point, d));
    });
  };e.Axis.prototype.drilldownCategory = function (b, a) {
    var d,
        c,
        e = this.ddPoints[b];for (d in e) {
      (c = e[d]) && c.series && c.series.visible && c.doDrilldown && c.doDrilldown(!0, b, a);
    }this.chart.applyDrilldown();
  };e.Axis.prototype.getDDPoints = function (b, a) {
    var d = this.ddPoints;if (!d) this.ddPoints = d = {};d[b] || (d[b] = []);if (d[b].levelNumber !== a) d[b].length = 0;return d[b];
  };x.prototype.drillable = function () {
    var b = this.pos,
        a = this.label,
        d = this.axis,
        c = d.ddPoints && d.ddPoints[b];if (a && c && c.length) {
      if (!a.basicStyles) a.basicStyles = e.merge(a.styles);a.addClass("highcharts-drilldown-axis-label").css(d.chart.options.drilldown.activeAxisLabelStyle).on("click", function (a) {
        d.drilldownCategory(b, a);
      });
    } else if (a && a.basicStyles) a.styles = {}, a.css(a.basicStyles), a.on("click", null);
  };
  r(x.prototype, "addLabel", function (b) {
    b.call(this);this.drillable();
  });r(e.Point.prototype, "init", function (b, a, d, c) {
    var g = b.call(this, a, d, c),
        b = (d = a.xAxis) && d.ticks[c],
        d = d && d.getDDPoints(c, a.options._levelNumber);if (g.drilldown && (e.addEvent(g, "click", function (b) {
      a.xAxis && a.chart.options.drilldown.allowPointDrilldown === !1 ? a.xAxis.drilldownCategory(c, b) : g.doDrilldown(void 0, void 0, b);
    }), d)) d.push(g), d.levelNumber = a.options._levelNumber;b && b.drillable();return g;
  });r(e.Series.prototype, "drawDataLabels", function (b) {
    var a = this,
        d = a.chart.options.drilldown.activeDataLabelStyle,
        c = a.chart.renderer;b.call(a);i(a.points, function (b) {
      var e = {};if (b.drilldown && b.dataLabel) {
        if (d.color === "contrast") e.color = c.getContrast(b.color || a.color);b.dataLabel.attr({ "class": "highcharts-drilldown-data-label" }).css(C(d, e));
      }
    });
  });var t,
      q = function q(b) {
    b.call(this);i(this.points, function (a) {
      a.drilldown && a.graphic && a.graphic.attr({ "class": "highcharts-drilldown-point" }).css({ cursor: "pointer" });
    });
  };for (t in p) {
    p[t].prototype.supportsDrilldown && r(p[t].prototype, "drawTracker", q);
  }
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highcharts JS v4.2.6 (2016-08-02)
 Data module

 (c) 2012-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (g) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = g : g(Highcharts);
})(function (g) {
  var v = g.win.document,
      k = g.each,
      w = g.pick,
      s = g.inArray,
      t = g.isNumber,
      x = g.splat,
      l,
      p = function p(b, a) {
    this.init(b, a);
  };g.extend(p.prototype, { init: function init(b, a) {
      this.options = b;this.chartOptions = a;this.columns = b.columns || this.rowsToColumns(b.rows) || [];this.firstRowAsNames = w(b.firstRowAsNames, !0);this.decimalRegex = b.decimalPoint && RegExp("^(-?[0-9]+)" + b.decimalPoint + "([0-9]+)$");this.rawColumns = [];this.columns.length ? this.dataFound() : (this.parseCSV(), this.parseTable(), this.parseGoogleSpreadsheet());
    }, getColumnDistribution: function getColumnDistribution() {
      var b = this.chartOptions,
          a = this.options,
          e = [],
          f = function f(b) {
        return (g.seriesTypes[b || "line"].prototype.pointArrayMap || [0]).length;
      },
          d = b && b.chart && b.chart.type,
          c = [],
          h = [],
          r = 0,
          i;k(b && b.series || [], function (b) {
        c.push(f(b.type || d));
      });k(a && a.seriesMapping || [], function (b) {
        e.push(b.x || 0);
      });e.length === 0 && e.push(0);k(a && a.seriesMapping || [], function (a) {
        var e = new l(),
            o,
            n = c[r] || f(d),
            m = g.seriesTypes[((b && b.series || [])[r] || {}).type || d || "line"].prototype.pointArrayMap || ["y"];e.addColumnReader(a.x, "x");for (o in a) {
          a.hasOwnProperty(o) && o !== "x" && e.addColumnReader(a[o], o);
        }for (i = 0; i < n; i++) {
          e.hasReader(m[i]) || e.addColumnReader(void 0, m[i]);
        }h.push(e);r++;
      });a = g.seriesTypes[d || "line"].prototype.pointArrayMap;a === void 0 && (a = ["y"]);this.valueCount = { global: f(d), xColumns: e, individual: c, seriesBuilders: h, globalPointArrayMap: a };
    }, dataFound: function dataFound() {
      if (this.options.switchRowsAndColumns) this.columns = this.rowsToColumns(this.columns);
      this.getColumnDistribution();this.parseTypes();this.parsed() !== !1 && this.complete();
    }, parseCSV: function parseCSV() {
      var b = this,
          a = this.options,
          e = a.csv,
          f = this.columns,
          d = a.startRow || 0,
          c = a.endRow || Number.MAX_VALUE,
          h = a.startColumn || 0,
          r = a.endColumn || Number.MAX_VALUE,
          i,
          g,
          u = 0;e && (g = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split(a.lineDelimiter || "\n"), i = a.itemDelimiter || (e.indexOf("\t") !== -1 ? "\t" : ","), k(g, function (a, e) {
        var g = b.trim(a),
            q = g.indexOf("#") === 0;e >= d && e <= c && !q && g !== "" && (g = a.split(i), k(g, function (b, a) {
          a >= h && a <= r && (f[a - h] || (f[a - h] = []), f[a - h][u] = b);
        }), u += 1);
      }), this.dataFound());
    }, parseTable: function parseTable() {
      var b = this.options,
          a = b.table,
          e = this.columns,
          f = b.startRow || 0,
          d = b.endRow || Number.MAX_VALUE,
          c = b.startColumn || 0,
          h = b.endColumn || Number.MAX_VALUE;a && (typeof a === "string" && (a = v.getElementById(a)), k(a.getElementsByTagName("tr"), function (b, a) {
        a >= f && a <= d && k(b.children, function (b, d) {
          if ((b.tagName === "TD" || b.tagName === "TH") && d >= c && d <= h) e[d - c] || (e[d - c] = []), e[d - c][a - f] = b.innerHTML;
        });
      }), this.dataFound());
    }, parseGoogleSpreadsheet: function parseGoogleSpreadsheet() {
      var b = this,
          a = this.options,
          e = a.googleSpreadsheetKey,
          f = this.columns,
          d = a.startRow || 0,
          c = a.endRow || Number.MAX_VALUE,
          h = a.startColumn || 0,
          g = a.endColumn || Number.MAX_VALUE,
          i,
          q;e && jQuery.ajax({ dataType: "json", url: "https://spreadsheets.google.com/feeds/cells/" + e + "/" + (a.googleSpreadsheetWorksheet || "od6") + "/public/values?alt=json-in-script&callback=?", error: a.error, success: function success(a) {
          var a = a.feed.entry,
              e,
              n = a.length,
              m = 0,
              l = 0,
              j;for (j = 0; j < n; j++) {
            e = a[j], m = Math.max(m, e.gs$cell.col), l = Math.max(l, e.gs$cell.row);
          }for (j = 0; j < m; j++) {
            if (j >= h && j <= g) f[j - h] = [], f[j - h].length = Math.min(l, c - d);
          }for (j = 0; j < n; j++) {
            if (e = a[j], i = e.gs$cell.row - 1, q = e.gs$cell.col - 1, q >= h && q <= g && i >= d && i <= c) f[q - h][i - d] = e.content.$t;
          }k(f, function (a) {
            for (j = 0; j < a.length; j++) {
              a[j] === void 0 && (a[j] = null);
            }
          });b.dataFound();
        } });
    }, trim: function trim(b, a) {
      typeof b === "string" && (b = b.replace(/^\s+|\s+$/g, ""), a && /^[0-9\s]+$/.test(b) && (b = b.replace(/\s/g, "")), this.decimalRegex && (b = b.replace(this.decimalRegex, "$1.$2")));return b;
    }, parseTypes: function parseTypes() {
      for (var b = this.columns, a = b.length; a--;) {
        this.parseColumn(b[a], a);
      }
    }, parseColumn: function parseColumn(b, a) {
      var e = this.rawColumns,
          f = this.columns,
          d = b.length,
          c,
          h,
          g,
          i,
          l = this.firstRowAsNames,
          k = s(a, this.valueCount.xColumns) !== -1,
          o = [],
          n = this.chartOptions,
          m,
          p = (this.options.columnTypes || [])[a],
          n = k && (n && n.xAxis && x(n.xAxis)[0].type === "category" || p === "string");for (e[a] || (e[a] = []); d--;) {
        if (c = o[d] || b[d], g = this.trim(c), i = this.trim(c, !0), h = parseFloat(i), e[a][d] === void 0 && (e[a][d] = g), n || d === 0 && l) b[d] = g;else if (+i === h) b[d] = h, h > 31536E6 && p !== "float" ? b.isDatetime = !0 : b.isNumeric = !0, b[d + 1] !== void 0 && (m = h > b[d + 1]);else if (h = this.parseDate(c), k && t(h) && p !== "float") {
          if (o[d] = c, b[d] = h, b.isDatetime = !0, b[d + 1] !== void 0) {
            c = h > b[d + 1];if (c !== m && m !== void 0) this.alternativeFormat ? (this.dateFormat = this.alternativeFormat, d = b.length, this.alternativeFormat = this.dateFormats[this.dateFormat].alternative) : b.unsorted = !0;m = c;
          }
        } else if (b[d] = g === "" ? null : g, d !== 0 && (b.isDatetime || b.isNumeric)) b.mixed = !0;
      }k && b.mixed && (f[a] = e[a]);if (k && m && this.options.sort) for (a = 0; a < f.length; a++) {
        f[a].reverse(), l && f[a].unshift(f[a].pop());
      }
    }, dateFormats: { "YYYY-mm-dd": { regex: /^([0-9]{4})[\-\/\.]([0-9]{2})[\-\/\.]([0-9]{2})$/,
        parser: function parser(b) {
          return Date.UTC(+b[1], b[2] - 1, +b[3]);
        } }, "dd/mm/YYYY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/, parser: function parser(b) {
          return Date.UTC(+b[3], b[2] - 1, +b[1]);
        }, alternative: "mm/dd/YYYY" }, "mm/dd/YYYY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/, parser: function parser(b) {
          return Date.UTC(+b[3], b[1] - 1, +b[2]);
        } }, "dd/mm/YY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/, parser: function parser(b) {
          return Date.UTC(+b[3] + 2E3, b[2] - 1, +b[1]);
        }, alternative: "mm/dd/YY" },
      "mm/dd/YY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/, parser: function parser(b) {
          return Date.UTC(+b[3] + 2E3, b[1] - 1, +b[2]);
        } } }, parseDate: function parseDate(b) {
      var a = this.options.parseDate,
          e,
          f,
          d = this.options.dateFormat || this.dateFormat,
          c;if (a) e = a(b);else if (typeof b === "string") {
        if (d) a = this.dateFormats[d], (c = b.match(a.regex)) && (e = a.parser(c));else for (f in this.dateFormats) {
          if (a = this.dateFormats[f], c = b.match(a.regex)) {
            this.dateFormat = f;this.alternativeFormat = a.alternative;e = a.parser(c);break;
          }
        }c || (c = Date.parse(b), (typeof c === "undefined" ? "undefined" : _typeof(c)) === "object" && c !== null && c.getTime ? e = c.getTime() - c.getTimezoneOffset() * 6E4 : t(c) && (e = c - new Date(c).getTimezoneOffset() * 6E4));
      }return e;
    }, rowsToColumns: function rowsToColumns(b) {
      var a, e, f, d, c;if (b) {
        c = [];e = b.length;for (a = 0; a < e; a++) {
          d = b[a].length;for (f = 0; f < d; f++) {
            c[f] || (c[f] = []), c[f][a] = b[a][f];
          }
        }
      }return c;
    }, parsed: function parsed() {
      if (this.options.parsed) return this.options.parsed.call(this, this.columns);
    }, getFreeIndexes: function getFreeIndexes(b, a) {
      var e,
          f,
          d = [],
          c = [],
          h;for (f = 0; f < b; f += 1) {
        d.push(!0);
      }for (e = 0; e < a.length; e += 1) {
        h = a[e].getReferencedColumnIndexes();
        for (f = 0; f < h.length; f += 1) {
          d[h[f]] = !1;
        }
      }for (f = 0; f < d.length; f += 1) {
        d[f] && c.push(f);
      }return c;
    }, complete: function complete() {
      var b = this.columns,
          a,
          e = this.options,
          f,
          d,
          c,
          h,
          g = [],
          i;if (e.complete || e.afterComplete) {
        for (c = 0; c < b.length; c++) {
          if (this.firstRowAsNames) b[c].name = b[c].shift();
        }f = [];d = this.getFreeIndexes(b.length, this.valueCount.seriesBuilders);for (c = 0; c < this.valueCount.seriesBuilders.length; c++) {
          i = this.valueCount.seriesBuilders[c], i.populateColumns(d) && g.push(i);
        }for (; d.length > 0;) {
          i = new l();i.addColumnReader(0, "x");c = s(0, d);c !== -1 && d.splice(c, 1);for (c = 0; c < this.valueCount.global; c++) {
            i.addColumnReader(void 0, this.valueCount.globalPointArrayMap[c]);
          }i.populateColumns(d) && g.push(i);
        }g.length > 0 && g[0].readers.length > 0 && (i = b[g[0].readers[0].columnIndex], i !== void 0 && (i.isDatetime ? a = "datetime" : i.isNumeric || (a = "category")));if (a === "category") for (c = 0; c < g.length; c++) {
          i = g[c];for (d = 0; d < i.readers.length; d++) {
            if (i.readers[d].configName === "x") i.readers[d].configName = "name";
          }
        }for (c = 0; c < g.length; c++) {
          i = g[c];d = [];for (h = 0; h < b[0].length; h++) {
            d[h] = i.read(b, h);
          }f[c] = { data: d };if (i.name) f[c].name = i.name;if (a === "category") f[c].turboThreshold = 0;
        }b = { series: f };if (a) b.xAxis = { type: a };e.complete && e.complete(b);e.afterComplete && e.afterComplete(b);
      }
    } });g.Data = p;g.data = function (b, a) {
    return new p(b, a);
  };g.wrap(g.Chart.prototype, "init", function (b, a, e) {
    var f = this;a && a.data ? g.data(g.extend(a.data, { afterComplete: function afterComplete(d) {
        var c, h;if (a.hasOwnProperty("series")) if (_typeof(a.series) === "object") for (c = Math.max(a.series.length, d.series.length); c--;) {
          h = a.series[c] || {}, a.series[c] = g.merge(h, d.series[c]);
        } else delete a.series;a = g.merge(d, a);b.call(f, a, e);
      } }), a) : b.call(f, a, e);
  });l = function l() {
    this.readers = [];this.pointIsArray = !0;
  };l.prototype.populateColumns = function (b) {
    var a = !0;k(this.readers, function (a) {
      if (a.columnIndex === void 0) a.columnIndex = b.shift();
    });k(this.readers, function (b) {
      b.columnIndex === void 0 && (a = !1);
    });return a;
  };l.prototype.read = function (b, a) {
    var e = this.pointIsArray,
        f = e ? [] : {},
        d;k(this.readers, function (c) {
      var d = b[c.columnIndex][a];e ? f.push(d) : f[c.configName] = d;
    });if (this.name === void 0 && this.readers.length >= 2 && (d = this.getReferencedColumnIndexes(), d.length >= 2)) d.shift(), d.sort(), this.name = b[d.shift()].name;return f;
  };l.prototype.addColumnReader = function (b, a) {
    this.readers.push({ columnIndex: b, configName: a });if (!(a === "x" || a === "y" || a === void 0)) this.pointIsArray = !1;
  };l.prototype.getReferencedColumnIndexes = function () {
    var b,
        a = [],
        e;for (b = 0; b < this.readers.length; b += 1) {
      e = this.readers[b], e.columnIndex !== void 0 && a.push(e.columnIndex);
    }return a;
  };l.prototype.hasReader = function (b) {
    var a, e;for (a = 0; a < this.readers.length; a += 1) {
      if (e = this.readers[a], e.configName === b) return !0;
    }
  };
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highcharts JS v4.2.6 (2016-08-02)
 Exporting module

 (c) 2010-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (f) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = f : f(Highcharts);
})(function (f) {
  var s = f.win,
      j = s.document,
      B = f.Chart,
      u = f.addEvent,
      C = f.removeEvent,
      D = f.fireEvent,
      r = f.createElement,
      t = f.discardElement,
      w = f.css,
      l = f.merge,
      m = f.each,
      q = f.extend,
      F = f.splat,
      G = Math.max,
      H = f.isTouchDevice,
      I = f.Renderer.prototype.symbols,
      z = f.getOptions(),
      A;q(z.lang, { printChart: "Print chart", downloadPNG: "Download PNG image", downloadJPEG: "Download JPEG image", downloadPDF: "Download PDF document", downloadSVG: "Download SVG vector image",
    contextButtonTitle: "Chart context menu" });z.navigation = { menuStyle: { border: "1px solid #A0A0A0", background: "#FFFFFF", padding: "5px 0" }, menuItemStyle: { padding: "0 10px", background: "none", color: "#303030", fontSize: H ? "14px" : "11px" }, menuItemHoverStyle: { background: "#4572A5", color: "#FFFFFF" }, buttonOptions: { symbolFill: "#E0E0E0", symbolSize: 14, symbolStroke: "#666", symbolStrokeWidth: 3, symbolX: 12.5, symbolY: 10.5, align: "right", buttonSpacing: 3, height: 22, theme: { fill: "white", stroke: "none" }, verticalAlign: "top", width: 24 } };
  z.exporting = { type: "image/png", url: "https://export.highcharts.com/", printMaxWidth: 780, scale: 2, buttons: { contextButton: { menuClassName: "highcharts-contextmenu", symbol: "menu", _titleKey: "contextButtonTitle", menuItems: [{ textKey: "printChart", onclick: function onclick() {
            this.print();
          } }, { separator: !0 }, { textKey: "downloadPNG", onclick: function onclick() {
            this.exportChart();
          } }, { textKey: "downloadJPEG", onclick: function onclick() {
            this.exportChart({ type: "image/jpeg" });
          } }, { textKey: "downloadPDF", onclick: function onclick() {
            this.exportChart({ type: "application/pdf" });
          } }, { textKey: "downloadSVG", onclick: function onclick() {
            this.exportChart({ type: "image/svg+xml" });
          } }] } } };f.post = function (a, b, e) {
    var c,
        a = r("form", l({ method: "post", action: a, enctype: "multipart/form-data" }, e), { display: "none" }, j.body);for (c in b) {
      r("input", { type: "hidden", name: c, value: b[c] }, null, a);
    }a.submit();t(a);
  };q(B.prototype, { sanitizeSVG: function sanitizeSVG(a) {
      return a.replace(/zIndex="[^"]+"/g, "").replace(/isShadow="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (NS[0-9]+\:)?href=/g, " xlink:href=").replace(/\n/, " ").replace(/<\/svg>.*?$/, "</svg>").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, "\xA0").replace(/&shy;/g, "\xAD").replace(/<IMG /g, "<image ").replace(/<(\/?)TITLE>/g, "<$1title>").replace(/height=([^" ]+)/g, 'height="$1"').replace(/width=([^" ]+)/g, 'width="$1"').replace(/hc-svg-href="([^"]+)">/g, 'xlink:href="$1"/>').replace(/ id=([^" >]+)/g, ' id="$1"').replace(/class=([^" >]+)/g, 'class="$1"').replace(/ transform /g, " ").replace(/:(path|rect)/g, "$1").replace(/style="([^"]+)"/g, function (a) {
        return a.toLowerCase();
      });
    }, getChartHTML: function getChartHTML() {
      return this.container.innerHTML;
    }, getSVG: function getSVG(a) {
      var b = this,
          e,
          c,
          g,
          k,
          h,
          d = l(b.options, a),
          n = d.exporting.allowHTML;if (!j.createElementNS) j.createElementNS = function (a, b) {
        return j.createElement(b);
      };c = r("div", null, { position: "absolute", top: "-9999em", width: b.chartWidth + "px", height: b.chartHeight + "px" }, j.body);
      g = b.renderTo.style.width;h = b.renderTo.style.height;g = d.exporting.sourceWidth || d.chart.width || /px$/.test(g) && parseInt(g, 10) || 600;h = d.exporting.sourceHeight || d.chart.height || /px$/.test(h) && parseInt(h, 10) || 400;q(d.chart, { animation: !1, renderTo: c, forExport: !0, renderer: "SVGRenderer", width: g, height: h });d.exporting.enabled = !1;delete d.data;d.series = [];m(b.series, function (a) {
        k = l(a.userOptions, { animation: !1, enableMouseTracking: !1, showCheckbox: !1, visible: a.visible });k.isInternal || d.series.push(k);
      });a && m(["xAxis", "yAxis"], function (b) {
        m(F(a[b]), function (a, c) {
          d[b][c] = l(d[b][c], a);
        });
      });e = new f.Chart(d, b.callback);m(["xAxis", "yAxis"], function (a) {
        m(b[a], function (b, c) {
          var d = e[a][c],
              f = b.getExtremes(),
              g = f.userMin,
              f = f.userMax;d && (g !== void 0 || f !== void 0) && d.setExtremes(g, f, !0, !1);
        });
      });g = e.getChartHTML();d = null;e.destroy();t(c);if (n && (c = g.match(/<\/svg>(.*?$)/))) c = '<foreignObject x="0" y="0" width="200" height="200"><body xmlns="http://www.w3.org/1999/xhtml">' + c[1] + "</body></foreignObject>", g = g.replace("</svg>", c + "</svg>");
      g = this.sanitizeSVG(g);return g = g.replace(/(url\(#highcharts-[0-9]+)&quot;/g, "$1").replace(/&quot;/g, "'");
    }, getSVGForExport: function getSVGForExport(a, b) {
      var e = this.options.exporting;return this.getSVG(l({ chart: { borderRadius: 0 } }, e.chartOptions, b, { exporting: { sourceWidth: a && a.sourceWidth || e.sourceWidth, sourceHeight: a && a.sourceHeight || e.sourceHeight } }));
    }, exportChart: function exportChart(a, b) {
      var e = this.getSVGForExport(a, b),
          a = l(this.options.exporting, a);f.post(a.url, { filename: a.filename || "chart", type: a.type, width: a.width || 0, scale: a.scale,
        svg: e }, a.formAttributes);
    }, print: function print() {
      var a = this,
          b = a.container,
          e = [],
          c = b.parentNode,
          f = j.body,
          k = f.childNodes,
          h = a.options.exporting.printMaxWidth,
          d,
          n;if (!a.isPrinting) {
        a.isPrinting = !0;a.pointer.reset(null, 0);D(a, "beforePrint");if (n = h && a.chartWidth > h) d = [a.options.chart.width, void 0, !1], a.setSize(h, void 0, !1);m(k, function (a, b) {
          if (a.nodeType === 1) e[b] = a.style.display, a.style.display = "none";
        });f.appendChild(b);s.focus();s.print();setTimeout(function () {
          c.appendChild(b);m(k, function (a, b) {
            if (a.nodeType === 1) a.style.display = e[b];
          });a.isPrinting = !1;n && a.setSize.apply(a, d);D(a, "afterPrint");
        }, 1E3);
      }
    }, contextMenu: function contextMenu(a, b, e, c, f, k, h) {
      var d = this,
          n = d.options.navigation,
          l = n.menuItemStyle,
          o = d.chartWidth,
          p = d.chartHeight,
          E = "cache-" + a,
          i = d[E],
          v = G(f, k),
          x,
          y,
          s,
          t = function t(b) {
        d.pointer.inClass(b.target, a) || y();
      };if (!i) d[E] = i = r("div", { className: a }, { position: "absolute", zIndex: 1E3, padding: v + "px" }, d.container), x = r("div", null, q({ MozBoxShadow: "3px 3px 10px #888", WebkitBoxShadow: "3px 3px 10px #888", boxShadow: "3px 3px 10px #888" }, n.menuStyle), i), y = function y() {
        w(i, { display: "none" });h && h.setState(0);d.openMenu = !1;
      }, u(i, "mouseleave", function () {
        s = setTimeout(y, 500);
      }), u(i, "mouseenter", function () {
        clearTimeout(s);
      }), u(j, "mouseup", t), u(d, "destroy", function () {
        C(j, "mouseup", t);
      }), m(b, function (a) {
        if (a) {
          var b = a.separator ? r("hr", null, null, x) : r("div", { onmouseover: function onmouseover() {
              w(this, n.menuItemHoverStyle);
            }, onmouseout: function onmouseout() {
              w(this, l);
            }, onclick: function onclick(b) {
              b && b.stopPropagation();y();a.onclick && a.onclick.apply(d, arguments);
            }, innerHTML: a.text || d.options.lang[a.textKey] }, q({ cursor: "pointer" }, l), x);d.exportDivElements.push(b);
        }
      }), d.exportDivElements.push(x, i), d.exportMenuWidth = i.offsetWidth, d.exportMenuHeight = i.offsetHeight;b = { display: "block" };e + d.exportMenuWidth > o ? b.right = o - e - f - v + "px" : b.left = e - v + "px";c + k + d.exportMenuHeight > p && h.alignOptions.verticalAlign !== "top" ? b.bottom = p - c - v + "px" : b.top = c + k - v + "px";w(i, b);d.openMenu = !0;
    }, addButton: function addButton(a) {
      var b = this,
          e = b.renderer,
          c = l(b.options.navigation.buttonOptions, a),
          g = c.onclick,
          k = c.menuItems,
          h,
          d,
          n = { stroke: c.symbolStroke, fill: c.symbolFill },
          j = c.symbolSize || 12;if (!b.btnCount) b.btnCount = 0;if (!b.exportDivElements) b.exportDivElements = [], b.exportSVGElements = [];if (c.enabled !== !1) {
        var o = c.theme,
            p = o.states,
            m = p && p.hover,
            p = p && p.select,
            i;delete o.states;g ? i = function i(a) {
          a.stopPropagation();g.call(b, a);
        } : k && (i = function i() {
          b.contextMenu(d.menuClassName, k, d.translateX, d.translateY, d.width, d.height, d);d.setState(2);
        });c.text && c.symbol ? o.paddingLeft = f.pick(o.paddingLeft, 25) : c.text || q(o, { width: c.width, height: c.height,
          padding: 0 });d = e.button(c.text, 0, 0, i, o, m, p).attr({ title: b.options.lang[c._titleKey], "stroke-linecap": "round", zIndex: 3 });d.menuClassName = a.menuClassName || "highcharts-menu-" + b.btnCount++;c.symbol && (h = e.symbol(c.symbol, c.symbolX - j / 2, c.symbolY - j / 2, j, j).attr(q(n, { "stroke-width": c.symbolStrokeWidth || 1, zIndex: 1 })).add(d));d.add().align(q(c, { width: d.width, x: f.pick(c.x, A) }), !0, "spacingBox");A += (d.width + c.buttonSpacing) * (c.align === "right" ? -1 : 1);b.exportSVGElements.push(d, h);
      }
    }, destroyExport: function destroyExport(a) {
      var a = a.target,
          b,
          e;for (b = 0; b < a.exportSVGElements.length; b++) {
        if (e = a.exportSVGElements[b]) e.onclick = e.ontouchstart = null, a.exportSVGElements[b] = e.destroy();
      }for (b = 0; b < a.exportDivElements.length; b++) {
        e = a.exportDivElements[b], C(e, "mouseleave"), a.exportDivElements[b] = e.onmouseout = e.onmouseover = e.ontouchstart = e.onclick = null, t(e);
      }
    } });I.menu = function (a, b, e, c) {
    return ["M", a, b + 2.5, "L", a + e, b + 2.5, "M", a, b + c / 2 + 0.5, "L", a + e, b + c / 2 + 0.5, "M", a, b + c - 1.5, "L", a + e, b + c - 1.5];
  };B.prototype.callbacks.push(function (a) {
    var b,
        e = a.options.exporting,
        c = e.buttons;A = 0;if (e.enabled !== !1) {
      for (b in c) {
        a.addButton(c[b]);
      }u(a, "destroy", a.destroyExport);
    }
  });
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 
 Highcharts funnel module

 (c) 2010-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (b) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = b : b(Highcharts);
})(function (b) {
  var r = b.getOptions(),
      x = r.plotOptions,
      s = b.seriesTypes,
      F = b.merge,
      E = function E() {},
      B = b.each;x.funnel = F(x.pie, { animation: !1, center: ["50%", "50%"], width: "90%", neckWidth: "30%", height: "100%", neckHeight: "25%", reversed: !1, dataLabels: { connectorWidth: 1, connectorColor: "#606060" }, size: !0, states: { select: { color: "#C0C0C0", borderColor: "#000000", shadow: !1 } } });s.funnel = b.extendClass(s.pie, { type: "funnel", animate: E, translate: function translate() {
      var a = function a(i, _a) {
        return (/%$/.test(i) ? _a * parseInt(i, 10) / 100 : parseInt(i, 10)
        );
      },
          b = 0,
          d = this.chart,
          c = this.options,
          e = c.reversed,
          f = c.ignoreHiddenPoint,
          p = d.plotWidth,
          d = d.plotHeight,
          n = 0,
          r = c.center,
          g = a(r[0], p),
          o = a(r[1], d),
          s = a(c.width, p),
          j,
          t,
          k = a(c.height, d),
          u = a(c.neckWidth, p),
          C = a(c.neckHeight, d),
          v = o - k / 2 + k - C,
          a = this.data,
          y,
          z,
          x = c.dataLabels.position === "left" ? 1 : 0,
          A,
          l,
          D,
          q,
          h,
          w,
          m;this.getWidthAt = t = function t(i) {
        var a = o - k / 2;return i > v || k === C ? u : u + (s - u) * (1 - (i - a) / (k - C));
      };this.getX = function (i, a) {
        return g + (a ? -1 : 1) * (t(e ? 2 * o - i : i) / 2 + c.dataLabels.distance);
      };this.center = [g, o, k];this.centerX = g;B(a, function (a) {
        if (!f || a.visible !== !1) b += a.y;
      });B(a, function (a) {
        m = null;z = b ? a.y / b : 0;l = o - k / 2 + n * k;h = l + z * k;j = t(l);A = g - j / 2;D = A + j;j = t(h);q = g - j / 2;w = q + j;l > v ? (A = q = g - u / 2, D = w = g + u / 2) : h > v && (m = h, j = t(v), q = g - j / 2, w = q + j, h = v);e && (l = 2 * o - l, h = 2 * o - h, m = m ? 2 * o - m : null);y = ["M", A, l, "L", D, l, w, h];m && y.push(w, m, q, m);y.push(q, h, "Z");a.shapeType = "path";a.shapeArgs = { d: y };a.percentage = z * 100;a.plotX = g;a.plotY = (l + (m || h)) / 2;a.tooltipPos = [g, a.plotY];a.slice = E;a.half = x;if (!f || a.visible !== !1) n += z;
      });
    }, drawPoints: function drawPoints() {
      var a = this,
          b = a.chart.renderer,
          d,
          c,
          e;B(a.data, function (f) {
        e = f.graphic;c = f.shapeArgs;d = f.pointAttr[f.selected ? "select" : ""];e ? e.attr(d).animate(c) : f.graphic = b.path(c).attr(d).add(a.group);
      });
    }, sortByAngle: function sortByAngle(a) {
      a.sort(function (a, b) {
        return a.plotY - b.plotY;
      });
    }, drawDataLabels: function drawDataLabels() {
      var a = this.data,
          b = this.options.dataLabels.distance,
          d,
          c,
          e,
          f = a.length,
          p,
          n;for (this.center[2] -= 2 * b; f--;) {
        e = a[f], c = (d = e.half) ? 1 : -1, n = e.plotY, p = this.getX(n, d), e.labelPos = [0, n, p + (b - 5) * c, n, p + b * c, n, d ? "right" : "left", 0];
      }s.pie.prototype.drawDataLabels.call(this);
    } });r.plotOptions.pyramid = b.merge(r.plotOptions.funnel, { neckWidth: "0%", neckHeight: "0%", reversed: !0 });b.seriesTypes.pyramid = b.extendClass(b.seriesTypes.funnel, { type: "pyramid" });
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
  Highcharts JS v4.2.6 (2016-08-02)
 Solid angular gauge module

 (c) 2010-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (a) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = a : a(Highcharts);
})(function (a) {
  var q = a.getOptions().plotOptions,
      r = a.pInt,
      s = a.pick,
      k = a.each,
      t = a.isNumber,
      l;q.solidgauge = a.merge(q.gauge, { colorByPoint: !0 });l = { initDataClasses: function initDataClasses(b) {
      var e = this,
          i = this.chart,
          c,
          g = 0,
          d = this.options;this.dataClasses = c = [];k(b.dataClasses, function (f, h) {
        var p,
            f = a.merge(f);c.push(f);if (!f.color) d.dataClassColor === "category" ? (p = i.options.colors, f.color = p[g++], g === p.length && (g = 0)) : f.color = e.tweenColors(a.Color(d.minColor), a.Color(d.maxColor), h / (b.dataClasses.length - 1));
      });
    }, initStops: function initStops(b) {
      this.stops = b.stops || [[0, this.options.minColor], [1, this.options.maxColor]];k(this.stops, function (b) {
        b.color = a.Color(b[1]);
      });
    }, toColor: function toColor(b, e) {
      var a,
          c = this.stops,
          g,
          d = this.dataClasses,
          f,
          h;if (d) for (h = d.length; h--;) {
        if (f = d[h], g = f.from, c = f.to, (g === void 0 || b >= g) && (c === void 0 || b <= c)) {
          a = f.color;if (e) e.dataClass = h;break;
        }
      } else {
        this.isLog && (b = this.val2lin(b));a = 1 - (this.max - b) / (this.max - this.min);for (h = c.length; h--;) {
          if (a > c[h][0]) break;
        }g = c[h] || c[h + 1];c = c[h + 1] || g;a = 1 - (c[0] - a) / (c[0] - g[0] || 1);a = this.tweenColors(g.color, c.color, a);
      }return a;
    }, tweenColors: function tweenColors(b, a, i) {
      var c;!a.rgba.length || !b.rgba.length ? b = a.input || "none" : (b = b.rgba, a = a.rgba, c = a[3] !== 1 || b[3] !== 1, b = (c ? "rgba(" : "rgb(") + Math.round(a[0] + (b[0] - a[0]) * (1 - i)) + "," + Math.round(a[1] + (b[1] - a[1]) * (1 - i)) + "," + Math.round(a[2] + (b[2] - a[2]) * (1 - i)) + (c ? "," + (a[3] + (b[3] - a[3]) * (1 - i)) : "") + ")");return b;
    } };k(["fill", "stroke"], function (b) {
    a.Fx.prototype[b + "Setter"] = function () {
      this.elem.attr(b, l.tweenColors(a.Color(this.start), a.Color(this.end), this.pos));
    };
  });a.seriesTypes.solidgauge = a.extendClass(a.seriesTypes.gauge, { type: "solidgauge", pointAttrToOptions: {}, bindAxes: function bindAxes() {
      var b;a.seriesTypes.gauge.prototype.bindAxes.call(this);b = this.yAxis;a.extend(b, l);b.options.dataClasses && b.initDataClasses(b.options);b.initStops(b.options);
    }, drawPoints: function drawPoints() {
      var b = this,
          e = b.yAxis,
          i = e.center,
          c = b.options,
          g = b.chart.renderer,
          d = c.overshoot,
          f = t(d) ? d / 180 * Math.PI : 0;a.each(b.points, function (a) {
        var d = a.graphic,
            j = e.startAngleRad + e.translate(a.y, null, null, null, !0),
            k = r(s(a.options.radius, c.radius, 100)) * i[2] / 200,
            m = r(s(a.options.innerRadius, c.innerRadius, 60)) * i[2] / 200,
            n = e.toColor(a.y, a),
            o = Math.min(e.startAngleRad, e.endAngleRad),
            l = Math.max(e.startAngleRad, e.endAngleRad);n === "none" && (n = a.color || b.color || "none");if (n !== "none") a.color = n;j = Math.max(o - f, Math.min(l + f, j));c.wrap === !1 && (j = Math.max(o, Math.min(l, j)));o = Math.min(j, e.startAngleRad);j = Math.max(j, e.startAngleRad);j - o > 2 * Math.PI && (j = o + 2 * Math.PI);a.shapeArgs = m = { x: i[0], y: i[1], r: k, innerR: m, start: o,
          end: j, fill: n };a.startR = k;if (d) {
          if (a = m.d, d.animate(m), a) m.d = a;
        } else d = { stroke: c.borderColor || "none", "stroke-width": c.borderWidth || 0, fill: n, "sweep-flag": 0 }, c.linecap !== "square" && (d["stroke-linecap"] = d["stroke-linejoin"] = "round"), a.graphic = g.arc(m).attr(d).add(b.group);
      });
    }, animate: function animate(b) {
      if (!b) this.startAngleRad = this.yAxis.startAngleRad, a.seriesTypes.pie.prototype.animate.call(this, b);
    } });
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Highcharts JS v4.2.6 (2016-08-02)
 Data module

 (c) 2012-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (g) {
  (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports ? module.exports = g : g(Highcharts);
})(function (g) {
  var v = g.win.document,
      k = g.each,
      w = g.pick,
      s = g.inArray,
      t = g.isNumber,
      x = g.splat,
      l,
      p = function p(b, a) {
    this.init(b, a);
  };g.extend(p.prototype, { init: function init(b, a) {
      this.options = b;this.chartOptions = a;this.columns = b.columns || this.rowsToColumns(b.rows) || [];this.firstRowAsNames = w(b.firstRowAsNames, !0);this.decimalRegex = b.decimalPoint && RegExp("^(-?[0-9]+)" + b.decimalPoint + "([0-9]+)$");this.rawColumns = [];this.columns.length ? this.dataFound() : (this.parseCSV(), this.parseTable(), this.parseGoogleSpreadsheet());
    }, getColumnDistribution: function getColumnDistribution() {
      var b = this.chartOptions,
          a = this.options,
          e = [],
          f = function f(b) {
        return (g.seriesTypes[b || "line"].prototype.pointArrayMap || [0]).length;
      },
          d = b && b.chart && b.chart.type,
          c = [],
          h = [],
          r = 0,
          i;k(b && b.series || [], function (b) {
        c.push(f(b.type || d));
      });k(a && a.seriesMapping || [], function (b) {
        e.push(b.x || 0);
      });e.length === 0 && e.push(0);k(a && a.seriesMapping || [], function (a) {
        var e = new l(),
            o,
            n = c[r] || f(d),
            m = g.seriesTypes[((b && b.series || [])[r] || {}).type || d || "line"].prototype.pointArrayMap || ["y"];e.addColumnReader(a.x, "x");for (o in a) {
          a.hasOwnProperty(o) && o !== "x" && e.addColumnReader(a[o], o);
        }for (i = 0; i < n; i++) {
          e.hasReader(m[i]) || e.addColumnReader(void 0, m[i]);
        }h.push(e);r++;
      });a = g.seriesTypes[d || "line"].prototype.pointArrayMap;a === void 0 && (a = ["y"]);this.valueCount = { global: f(d), xColumns: e, individual: c, seriesBuilders: h, globalPointArrayMap: a };
    }, dataFound: function dataFound() {
      if (this.options.switchRowsAndColumns) this.columns = this.rowsToColumns(this.columns);
      this.getColumnDistribution();this.parseTypes();this.parsed() !== !1 && this.complete();
    }, parseCSV: function parseCSV() {
      var b = this,
          a = this.options,
          e = a.csv,
          f = this.columns,
          d = a.startRow || 0,
          c = a.endRow || Number.MAX_VALUE,
          h = a.startColumn || 0,
          r = a.endColumn || Number.MAX_VALUE,
          i,
          g,
          u = 0;e && (g = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split(a.lineDelimiter || "\n"), i = a.itemDelimiter || (e.indexOf("\t") !== -1 ? "\t" : ","), k(g, function (a, e) {
        var g = b.trim(a),
            q = g.indexOf("#") === 0;e >= d && e <= c && !q && g !== "" && (g = a.split(i), k(g, function (b, a) {
          a >= h && a <= r && (f[a - h] || (f[a - h] = []), f[a - h][u] = b);
        }), u += 1);
      }), this.dataFound());
    }, parseTable: function parseTable() {
      var b = this.options,
          a = b.table,
          e = this.columns,
          f = b.startRow || 0,
          d = b.endRow || Number.MAX_VALUE,
          c = b.startColumn || 0,
          h = b.endColumn || Number.MAX_VALUE;a && (typeof a === "string" && (a = v.getElementById(a)), k(a.getElementsByTagName("tr"), function (b, a) {
        a >= f && a <= d && k(b.children, function (b, d) {
          if ((b.tagName === "TD" || b.tagName === "TH") && d >= c && d <= h) e[d - c] || (e[d - c] = []), e[d - c][a - f] = b.innerHTML;
        });
      }), this.dataFound());
    }, parseGoogleSpreadsheet: function parseGoogleSpreadsheet() {
      var b = this,
          a = this.options,
          e = a.googleSpreadsheetKey,
          f = this.columns,
          d = a.startRow || 0,
          c = a.endRow || Number.MAX_VALUE,
          h = a.startColumn || 0,
          g = a.endColumn || Number.MAX_VALUE,
          i,
          q;e && jQuery.ajax({ dataType: "json", url: "https://spreadsheets.google.com/feeds/cells/" + e + "/" + (a.googleSpreadsheetWorksheet || "od6") + "/public/values?alt=json-in-script&callback=?", error: a.error, success: function success(a) {
          var a = a.feed.entry,
              e,
              n = a.length,
              m = 0,
              l = 0,
              j;for (j = 0; j < n; j++) {
            e = a[j], m = Math.max(m, e.gs$cell.col), l = Math.max(l, e.gs$cell.row);
          }for (j = 0; j < m; j++) {
            if (j >= h && j <= g) f[j - h] = [], f[j - h].length = Math.min(l, c - d);
          }for (j = 0; j < n; j++) {
            if (e = a[j], i = e.gs$cell.row - 1, q = e.gs$cell.col - 1, q >= h && q <= g && i >= d && i <= c) f[q - h][i - d] = e.content.$t;
          }k(f, function (a) {
            for (j = 0; j < a.length; j++) {
              a[j] === void 0 && (a[j] = null);
            }
          });b.dataFound();
        } });
    }, trim: function trim(b, a) {
      typeof b === "string" && (b = b.replace(/^\s+|\s+$/g, ""), a && /^[0-9\s]+$/.test(b) && (b = b.replace(/\s/g, "")), this.decimalRegex && (b = b.replace(this.decimalRegex, "$1.$2")));return b;
    }, parseTypes: function parseTypes() {
      for (var b = this.columns, a = b.length; a--;) {
        this.parseColumn(b[a], a);
      }
    }, parseColumn: function parseColumn(b, a) {
      var e = this.rawColumns,
          f = this.columns,
          d = b.length,
          c,
          h,
          g,
          i,
          l = this.firstRowAsNames,
          k = s(a, this.valueCount.xColumns) !== -1,
          o = [],
          n = this.chartOptions,
          m,
          p = (this.options.columnTypes || [])[a],
          n = k && (n && n.xAxis && x(n.xAxis)[0].type === "category" || p === "string");for (e[a] || (e[a] = []); d--;) {
        if (c = o[d] || b[d], g = this.trim(c), i = this.trim(c, !0), h = parseFloat(i), e[a][d] === void 0 && (e[a][d] = g), n || d === 0 && l) b[d] = g;else if (+i === h) b[d] = h, h > 31536E6 && p !== "float" ? b.isDatetime = !0 : b.isNumeric = !0, b[d + 1] !== void 0 && (m = h > b[d + 1]);else if (h = this.parseDate(c), k && t(h) && p !== "float") {
          if (o[d] = c, b[d] = h, b.isDatetime = !0, b[d + 1] !== void 0) {
            c = h > b[d + 1];if (c !== m && m !== void 0) this.alternativeFormat ? (this.dateFormat = this.alternativeFormat, d = b.length, this.alternativeFormat = this.dateFormats[this.dateFormat].alternative) : b.unsorted = !0;m = c;
          }
        } else if (b[d] = g === "" ? null : g, d !== 0 && (b.isDatetime || b.isNumeric)) b.mixed = !0;
      }k && b.mixed && (f[a] = e[a]);if (k && m && this.options.sort) for (a = 0; a < f.length; a++) {
        f[a].reverse(), l && f[a].unshift(f[a].pop());
      }
    }, dateFormats: { "YYYY-mm-dd": { regex: /^([0-9]{4})[\-\/\.]([0-9]{2})[\-\/\.]([0-9]{2})$/,
        parser: function parser(b) {
          return Date.UTC(+b[1], b[2] - 1, +b[3]);
        } }, "dd/mm/YYYY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/, parser: function parser(b) {
          return Date.UTC(+b[3], b[2] - 1, +b[1]);
        }, alternative: "mm/dd/YYYY" }, "mm/dd/YYYY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/, parser: function parser(b) {
          return Date.UTC(+b[3], b[1] - 1, +b[2]);
        } }, "dd/mm/YY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/, parser: function parser(b) {
          return Date.UTC(+b[3] + 2E3, b[2] - 1, +b[1]);
        }, alternative: "mm/dd/YY" },
      "mm/dd/YY": { regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/, parser: function parser(b) {
          return Date.UTC(+b[3] + 2E3, b[1] - 1, +b[2]);
        } } }, parseDate: function parseDate(b) {
      var a = this.options.parseDate,
          e,
          f,
          d = this.options.dateFormat || this.dateFormat,
          c;if (a) e = a(b);else if (typeof b === "string") {
        if (d) a = this.dateFormats[d], (c = b.match(a.regex)) && (e = a.parser(c));else for (f in this.dateFormats) {
          if (a = this.dateFormats[f], c = b.match(a.regex)) {
            this.dateFormat = f;this.alternativeFormat = a.alternative;e = a.parser(c);break;
          }
        }c || (c = Date.parse(b), (typeof c === "undefined" ? "undefined" : _typeof(c)) === "object" && c !== null && c.getTime ? e = c.getTime() - c.getTimezoneOffset() * 6E4 : t(c) && (e = c - new Date(c).getTimezoneOffset() * 6E4));
      }return e;
    }, rowsToColumns: function rowsToColumns(b) {
      var a, e, f, d, c;if (b) {
        c = [];e = b.length;for (a = 0; a < e; a++) {
          d = b[a].length;for (f = 0; f < d; f++) {
            c[f] || (c[f] = []), c[f][a] = b[a][f];
          }
        }
      }return c;
    }, parsed: function parsed() {
      if (this.options.parsed) return this.options.parsed.call(this, this.columns);
    }, getFreeIndexes: function getFreeIndexes(b, a) {
      var e,
          f,
          d = [],
          c = [],
          h;for (f = 0; f < b; f += 1) {
        d.push(!0);
      }for (e = 0; e < a.length; e += 1) {
        h = a[e].getReferencedColumnIndexes();
        for (f = 0; f < h.length; f += 1) {
          d[h[f]] = !1;
        }
      }for (f = 0; f < d.length; f += 1) {
        d[f] && c.push(f);
      }return c;
    }, complete: function complete() {
      var b = this.columns,
          a,
          e = this.options,
          f,
          d,
          c,
          h,
          g = [],
          i;if (e.complete || e.afterComplete) {
        for (c = 0; c < b.length; c++) {
          if (this.firstRowAsNames) b[c].name = b[c].shift();
        }f = [];d = this.getFreeIndexes(b.length, this.valueCount.seriesBuilders);for (c = 0; c < this.valueCount.seriesBuilders.length; c++) {
          i = this.valueCount.seriesBuilders[c], i.populateColumns(d) && g.push(i);
        }for (; d.length > 0;) {
          i = new l();i.addColumnReader(0, "x");c = s(0, d);c !== -1 && d.splice(c, 1);for (c = 0; c < this.valueCount.global; c++) {
            i.addColumnReader(void 0, this.valueCount.globalPointArrayMap[c]);
          }i.populateColumns(d) && g.push(i);
        }g.length > 0 && g[0].readers.length > 0 && (i = b[g[0].readers[0].columnIndex], i !== void 0 && (i.isDatetime ? a = "datetime" : i.isNumeric || (a = "category")));if (a === "category") for (c = 0; c < g.length; c++) {
          i = g[c];for (d = 0; d < i.readers.length; d++) {
            if (i.readers[d].configName === "x") i.readers[d].configName = "name";
          }
        }for (c = 0; c < g.length; c++) {
          i = g[c];d = [];for (h = 0; h < b[0].length; h++) {
            d[h] = i.read(b, h);
          }f[c] = { data: d };if (i.name) f[c].name = i.name;if (a === "category") f[c].turboThreshold = 0;
        }b = { series: f };if (a) b.xAxis = { type: a };e.complete && e.complete(b);e.afterComplete && e.afterComplete(b);
      }
    } });g.Data = p;g.data = function (b, a) {
    return new p(b, a);
  };g.wrap(g.Chart.prototype, "init", function (b, a, e) {
    var f = this;a && a.data ? g.data(g.extend(a.data, { afterComplete: function afterComplete(d) {
        var c, h;if (a.hasOwnProperty("series")) if (_typeof(a.series) === "object") for (c = Math.max(a.series.length, d.series.length); c--;) {
          h = a.series[c] || {}, a.series[c] = g.merge(h, d.series[c]);
        } else delete a.series;a = g.merge(d, a);b.call(f, a, e);
      } }), a) : b.call(f, a, e);
  });l = function l() {
    this.readers = [];this.pointIsArray = !0;
  };l.prototype.populateColumns = function (b) {
    var a = !0;k(this.readers, function (a) {
      if (a.columnIndex === void 0) a.columnIndex = b.shift();
    });k(this.readers, function (b) {
      b.columnIndex === void 0 && (a = !1);
    });return a;
  };l.prototype.read = function (b, a) {
    var e = this.pointIsArray,
        f = e ? [] : {},
        d;k(this.readers, function (c) {
      var d = b[c.columnIndex][a];e ? f.push(d) : f[c.configName] = d;
    });if (this.name === void 0 && this.readers.length >= 2 && (d = this.getReferencedColumnIndexes(), d.length >= 2)) d.shift(), d.sort(), this.name = b[d.shift()].name;return f;
  };l.prototype.addColumnReader = function (b, a) {
    this.readers.push({ columnIndex: b, configName: a });if (!(a === "x" || a === "y" || a === void 0)) this.pointIsArray = !1;
  };l.prototype.getReferencedColumnIndexes = function () {
    var b,
        a = [],
        e;for (b = 0; b < this.readers.length; b += 1) {
      e = this.readers[b], e.columnIndex !== void 0 && a.push(e.columnIndex);
    }return a;
  };l.prototype.hasReader = function (b) {
    var a, e;for (a = 0; a < this.readers.length; a += 1) {
      if (e = this.readers[a], e.configName === b) return !0;
    }
  };
});</script><script>
var VaadinCharts = VaadinCharts || {};

/**
 * Behavior that provides common configuration for charts web components.
 *
 * @polymerBehavior
 */
VaadinCharts.ChartCommonBehavior = {

    /**
     * Fired when the chart has been fully loaded.
     *
     * @event chart-loaded
     */

    properties: {

        /**
         * JS object created from the HTML configuration.
         *
         * @type {chart: object
         *        colors: array
         *        credits: object
         *        data: object
         *        drilldown: object
         *        exporting: object
         *        labels: object
         *        legend: object
         *        loading: object
         *        navigation: object
         *        noData: object
         *        pane: object
         *        plotOptions: object
         *        series: array
         *        subtitle: object
         *        title: object
         *        tooltip: object
         *        xAxis: object
         *        yAxis: object
         *       }
         **/
        chart: {
            type: Object,
            readOnly: true,
            notify: true,
            value: function value() {
                return {};
            }
        },

        timeline: {
            type: Boolean,
            value: false,
            observer: '_timelineChanged'
        },

        /**
         * Initial chart configuration before initial rendering.
         **/
        _chartConf: {
            type: Object,
            value: function value() {
                return {};
            }
        }
    },

    /**
     * Tells that the component has been initialized.
     **/
    isInitialized: function isInitialized() {
        return Object.keys(this.chart).length !== 0;
    },

    /**
     * List of properties that will always be copied from the chart element to the container div
     **/
    _copyStyleProperties: ["flex", "-webkit-flex", "-ms-flex"],

    /**
     *  Name of the chart events to add to the configuration and its corresponding event for the chart element
     **/
    _chartEventNames: {
        addSeries: "add-series",
        afterPrint: "after-print",
        beforePrint: "before-print",
        click: "chart-click",
        drilldown: "drilldown",
        drillup: "drillup",
        redraw: "redraw",
        selection: "selection"
    },
    /**
     *  Name of the series events to add to the configuration and its corresponding event for the chart element
     **/
    _seriesEventNames: {
        afterAnimate: "series-after-animate",
        checkboxClick: "series-checkbox-click",
        click: "series-click",
        hide: "series-hide",
        legendItemClick: "series-legend-item-click",
        mouseOut: "series-mouse-out",
        mouseOver: "series-mouse-over",
        show: "series-show"
    },
    /**
     *  Name of the point events to add to the configuration and its corresponding event for the chart element
     **/
    _pointEventNames: {
        click: "point-click",
        mouseOut: "point-mouse-out",
        mouseOver: "point-mouse-over",
        remove: "point-remove",
        select: "point-select",
        unselect: "point-unselect",
        update: "point-update"
    },

    /**
     * Reloads the chart with the original configuration defined in elements and its attributes.
     */
    reloadConfiguration: function reloadConfiguration() {
        this._chartConf = {};
        this._initConfiguration();
        this.chart.destroy();
        this._setChart({});
        this._reloadSeries();
        this._initChart();
    },

    /**
     * Reload all the chart's series
     */
    _reloadSeries: function _reloadSeries() {
        var series = Polymer.dom(this).querySelectorAll('data-series');
        for (var i = 0; i < series.length; i++) {
            series[i]._reloadConfiguration();
        }
    },

    /**
     * Dynamically add a new Series to this chart
     * @return The index of the added series in the series array
     **/
    _addSeries: function _addSeries(newSeries) {
        if (this._chartConf.series === undefined) {
            this._chartConf.series = [];
        }
        this._chartConf.series.push(newSeries);
        return this._chartConf.series.length - 1;
    },

    /**
     * Dynamically add a new Series to this chart's Drilldown configuration
     * @return The index of the added series in the drilldown series array
     **/
    _addDrilldownSeries: function _addDrilldownSeries(newSeries) {
        if (!this._chartConf.drilldown) {
            this._chartConf.drilldown = {};
        }
        if (!this._chartConf.drilldown.series) {
            this._chartConf.drilldown.series = [];
        }
        this._chartConf.drilldown.series.push(newSeries);
        return this._chartConf.drilldown.series.length - 1;
    },

    /* ----------- lifecycle ----------- */
    created: function created() {
        //Workaround to prevent _chartConf from being undefined when calling _addSeries from child component in FF
        this._chartConf = {};
    },

    attached: function attached() {
        if (!this.isInitialized()) {
            this._initLocalDom();
            this._initConfiguration();
            Polymer.dom(this).querySelectorAll("data-series").forEach(function (ds) {
                if (ds._initialize) {
                    ds._initialize();
                }
            });
            if (this._loadTheme) {
                this._loadTheme();
            }
            this._initChart();
        }
    },

    /**
     * Initializes the chart property using the json configuration.
     */
    _initChart: function _initChart() {
        if (this.timeline) {
            this._setChart(new Highcharts.StockChart(this._chartConf));
        } else {
            this._setChart(new Highcharts.Chart(this._chartConf));
        }
        this.fire("chart-loaded");
    },

    ready: function ready() {},

    _initLocalDom: function _initLocalDom() {
        var chartContainer = document.createElement('div');
        chartContainer.id = "chartContainer";
        this._updateStyles(chartContainer);
        Polymer.dom(this.root).appendChild(chartContainer);
        var licenseChecker = document.createElement('vaadin-license-checker');
        licenseChecker.productName = "vaadin-charts";
        licenseChecker.productVersion = "3";
        licenseChecker.productCaption = "Vaadin Charts";
        Polymer.dom(this.root).appendChild(licenseChecker);
        Polymer.dom.flush();
    },

    /**
     * Updates chartContainer and current chart style property depending on flex status
     */
    _updateStyles: function _updateStyles(chartContainer) {
        var isFlex = false;
        this._copyStyleProperties.forEach(function (property) {
            //Chrome returns default value if property is not set
            //check if flex is defined for chart, and different than default value
            if (getComputedStyle(this)[property] && getComputedStyle(this)[property] != "0 1 auto") {
                isFlex = true;
            }
        }, this);
        //If chart element is a flexible item the chartContainer should be flex too
        if (isFlex) {
            chartContainer.setAttribute("style", "flex: 1; -webkit-flex: 1; -ms-flex: 1; ");
            var style = '';
            if (this.hasAttribute("style")) {
                style = this.getAttribute("style");
                if (style.charAt(style.length - 1) !== ';') {
                    style += ';';
                }
            }
            style += "display: -ms-flexbox; display: -webkit-flex; display: flex;";
            this.setAttribute("style", style);
        } else {
            chartContainer.setAttribute("style", "height:100%; width:100%;");
        }
    },

    /**
     * Initializes the chart json configuration.
     */
    _initConfiguration: function _initConfiguration() {
        this._cleanNode(Polymer.dom(this));
        this._loadConfiguration(this._chartConf, Polymer.dom(this));

        if (!this._chartConf.chart) {
            this._chartConf.chart = {};
        }

        this._initEventListeners();
        this._chartConf.chart.type = this._getType();
        this._chartConf.chart.renderTo = Polymer.dom(this.root).querySelector('#chartContainer');
    },

    _initEventListeners: function _initEventListeners() {
        this._chartConf.chart.events = {};
        for (var key in this._chartEventNames) {
            if (this._chartEventNames.hasOwnProperty(key)) {
                this._addChartEvent(key, this._chartEventNames[key]);
            }
        }

        this._ensureObjectStructure(this._chartConf, "plotOptions.series");
        this._chartConf.plotOptions.series.events = {};
        for (var key in this._seriesEventNames) {
            if (this._seriesEventNames.hasOwnProperty(key)) {
                this._addSeriesEvent(key, this._seriesEventNames[key]);
            }
        }

        this._ensureObjectStructure(this._chartConf, "plotOptions.series.point");
        this._chartConf.plotOptions.series.point.events = {};
        for (var key in this._pointEventNames) {
            if (this._pointEventNames.hasOwnProperty(key)) {
                this._addPointEvent(key, this._pointEventNames[key]);
            }
        }
    },

    _addChartEvent: function _addChartEvent(highchartsName, vaadinChartsName) {
        var self = this;
        this._chartConf.chart.events[highchartsName] = function (e) {
            self.fire(vaadinChartsName, { originalEvent: e, chart: this });
        };
    },

    _addSeriesEvent: function _addSeriesEvent(highchartsName, vaadinChartsName) {
        var self = this;
        this._chartConf.plotOptions.series.events[highchartsName] = function (e) {
            self.fire(vaadinChartsName, { originalEvent: e, series: this });
        };
    },

    _addPointEvent: function _addPointEvent(highchartsName, vaadinChartsName) {
        var self = this;
        this._chartConf.plotOptions.series.point.events[highchartsName] = function (e) {
            self.fire(vaadinChartsName, { originalEvent: e, point: this });
        };
    },

    _timelineChanged: function _timelineChanged(newValue, oldValue) {
        // Observer might be called before _initChart
        if (this.isInitialized()) {
            this.reloadConfiguration();
        }
    }
};

/**
 * @polymerBehavior
 */
VaadinCharts.ChartBehavior = [VaadinCharts.ConfigurationReaderBehavior, VaadinCharts.ChartCommonBehavior];</script><dom-module id="vaadin-column-chart" assetpath="../bower_components/vaadin-charts/"><template></template><script>
Polymer({
    is: 'vaadin-column-chart',

    behaviors: [VaadinCharts.ValoThemeBehavior, VaadinCharts.ChartBehavior],

    _getType: function _getType() {
        return 'column';
    }

});</script></dom-module></div></body></html>